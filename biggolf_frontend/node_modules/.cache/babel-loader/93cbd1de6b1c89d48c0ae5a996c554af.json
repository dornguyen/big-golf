{"ast":null,"code":"\"use strict\";\n\nlet util = require(\"util\");\nlet zlib = require(\"zlib\");\nlet ChunkStream = require(\"./chunkstream\");\nlet FilterAsync = require(\"./filter-parse-async\");\nlet Parser = require(\"./parser\");\nlet bitmapper = require(\"./bitmapper\");\nlet formatNormaliser = require(\"./format-normaliser\");\nlet ParserAsync = module.exports = function (options) {\n  ChunkStream.call(this);\n  this._parser = new Parser(options, {\n    read: this.read.bind(this),\n    error: this._handleError.bind(this),\n    metadata: this._handleMetaData.bind(this),\n    gamma: this.emit.bind(this, \"gamma\"),\n    palette: this._handlePalette.bind(this),\n    transColor: this._handleTransColor.bind(this),\n    finished: this._finished.bind(this),\n    inflateData: this._inflateData.bind(this),\n    simpleTransparency: this._simpleTransparency.bind(this),\n    headersFinished: this._headersFinished.bind(this)\n  });\n  this._options = options;\n  this.writable = true;\n  this._parser.start();\n};\nutil.inherits(ParserAsync, ChunkStream);\nParserAsync.prototype._handleError = function (err) {\n  this.emit(\"error\", err);\n  this.writable = false;\n  this.destroy();\n  if (this._inflate && this._inflate.destroy) {\n    this._inflate.destroy();\n  }\n  if (this._filter) {\n    this._filter.destroy();\n    // For backward compatibility with Node 7 and below.\n    // Suppress errors due to _inflate calling write() even after\n    // it's destroy()'ed.\n    this._filter.on(\"error\", function () {});\n  }\n  this.errord = true;\n};\nParserAsync.prototype._inflateData = function (data) {\n  if (!this._inflate) {\n    if (this._bitmapInfo.interlace) {\n      this._inflate = zlib.createInflate();\n      this._inflate.on(\"error\", this.emit.bind(this, \"error\"));\n      this._filter.on(\"complete\", this._complete.bind(this));\n      this._inflate.pipe(this._filter);\n    } else {\n      let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;\n      let imageSize = rowSize * this._bitmapInfo.height;\n      let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);\n      this._inflate = zlib.createInflate({\n        chunkSize: chunkSize\n      });\n      let leftToInflate = imageSize;\n      let emitError = this.emit.bind(this, \"error\");\n      this._inflate.on(\"error\", function (err) {\n        if (!leftToInflate) {\n          return;\n        }\n        emitError(err);\n      });\n      this._filter.on(\"complete\", this._complete.bind(this));\n      let filterWrite = this._filter.write.bind(this._filter);\n      this._inflate.on(\"data\", function (chunk) {\n        if (!leftToInflate) {\n          return;\n        }\n        if (chunk.length > leftToInflate) {\n          chunk = chunk.slice(0, leftToInflate);\n        }\n        leftToInflate -= chunk.length;\n        filterWrite(chunk);\n      });\n      this._inflate.on(\"end\", this._filter.end.bind(this._filter));\n    }\n  }\n  this._inflate.write(data);\n};\nParserAsync.prototype._handleMetaData = function (metaData) {\n  this._metaData = metaData;\n  this._bitmapInfo = Object.create(metaData);\n  this._filter = new FilterAsync(this._bitmapInfo);\n};\nParserAsync.prototype._handleTransColor = function (transColor) {\n  this._bitmapInfo.transColor = transColor;\n};\nParserAsync.prototype._handlePalette = function (palette) {\n  this._bitmapInfo.palette = palette;\n};\nParserAsync.prototype._simpleTransparency = function () {\n  this._metaData.alpha = true;\n};\nParserAsync.prototype._headersFinished = function () {\n  // Up until this point, we don't know if we have a tRNS chunk (alpha)\n  // so we can't emit metadata any earlier\n  this.emit(\"metadata\", this._metaData);\n};\nParserAsync.prototype._finished = function () {\n  if (this.errord) {\n    return;\n  }\n  if (!this._inflate) {\n    this.emit(\"error\", \"No Inflate block\");\n  } else {\n    // no more data to inflate\n    this._inflate.end();\n  }\n};\nParserAsync.prototype._complete = function (filteredData) {\n  if (this.errord) {\n    return;\n  }\n  let normalisedBitmapData;\n  try {\n    let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);\n    normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo, this._options.skipRescale);\n    bitmapData = null;\n  } catch (ex) {\n    this._handleError(ex);\n    return;\n  }\n  this.emit(\"parsed\", normalisedBitmapData);\n};","map":{"version":3,"names":["util","require","zlib","ChunkStream","FilterAsync","Parser","bitmapper","formatNormaliser","ParserAsync","module","exports","options","call","_parser","read","bind","error","_handleError","metadata","_handleMetaData","gamma","emit","palette","_handlePalette","transColor","_handleTransColor","finished","_finished","inflateData","_inflateData","simpleTransparency","_simpleTransparency","headersFinished","_headersFinished","_options","writable","start","inherits","prototype","err","destroy","_inflate","_filter","on","errord","data","_bitmapInfo","interlace","createInflate","_complete","pipe","rowSize","width","bpp","depth","imageSize","height","chunkSize","Math","max","Z_MIN_CHUNK","leftToInflate","emitError","filterWrite","write","chunk","length","slice","end","metaData","_metaData","Object","create","alpha","filteredData","normalisedBitmapData","bitmapData","dataToBitMap","skipRescale","ex"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/pngjs/lib/parser-async.js"],"sourcesContent":["\"use strict\";\n\nlet util = require(\"util\");\nlet zlib = require(\"zlib\");\nlet ChunkStream = require(\"./chunkstream\");\nlet FilterAsync = require(\"./filter-parse-async\");\nlet Parser = require(\"./parser\");\nlet bitmapper = require(\"./bitmapper\");\nlet formatNormaliser = require(\"./format-normaliser\");\n\nlet ParserAsync = (module.exports = function (options) {\n  ChunkStream.call(this);\n\n  this._parser = new Parser(options, {\n    read: this.read.bind(this),\n    error: this._handleError.bind(this),\n    metadata: this._handleMetaData.bind(this),\n    gamma: this.emit.bind(this, \"gamma\"),\n    palette: this._handlePalette.bind(this),\n    transColor: this._handleTransColor.bind(this),\n    finished: this._finished.bind(this),\n    inflateData: this._inflateData.bind(this),\n    simpleTransparency: this._simpleTransparency.bind(this),\n    headersFinished: this._headersFinished.bind(this),\n  });\n  this._options = options;\n  this.writable = true;\n\n  this._parser.start();\n});\nutil.inherits(ParserAsync, ChunkStream);\n\nParserAsync.prototype._handleError = function (err) {\n  this.emit(\"error\", err);\n\n  this.writable = false;\n\n  this.destroy();\n\n  if (this._inflate && this._inflate.destroy) {\n    this._inflate.destroy();\n  }\n\n  if (this._filter) {\n    this._filter.destroy();\n    // For backward compatibility with Node 7 and below.\n    // Suppress errors due to _inflate calling write() even after\n    // it's destroy()'ed.\n    this._filter.on(\"error\", function () {});\n  }\n\n  this.errord = true;\n};\n\nParserAsync.prototype._inflateData = function (data) {\n  if (!this._inflate) {\n    if (this._bitmapInfo.interlace) {\n      this._inflate = zlib.createInflate();\n\n      this._inflate.on(\"error\", this.emit.bind(this, \"error\"));\n      this._filter.on(\"complete\", this._complete.bind(this));\n\n      this._inflate.pipe(this._filter);\n    } else {\n      let rowSize =\n        ((this._bitmapInfo.width *\n          this._bitmapInfo.bpp *\n          this._bitmapInfo.depth +\n          7) >>\n          3) +\n        1;\n      let imageSize = rowSize * this._bitmapInfo.height;\n      let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);\n\n      this._inflate = zlib.createInflate({ chunkSize: chunkSize });\n      let leftToInflate = imageSize;\n\n      let emitError = this.emit.bind(this, \"error\");\n      this._inflate.on(\"error\", function (err) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        emitError(err);\n      });\n      this._filter.on(\"complete\", this._complete.bind(this));\n\n      let filterWrite = this._filter.write.bind(this._filter);\n      this._inflate.on(\"data\", function (chunk) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        if (chunk.length > leftToInflate) {\n          chunk = chunk.slice(0, leftToInflate);\n        }\n\n        leftToInflate -= chunk.length;\n\n        filterWrite(chunk);\n      });\n\n      this._inflate.on(\"end\", this._filter.end.bind(this._filter));\n    }\n  }\n  this._inflate.write(data);\n};\n\nParserAsync.prototype._handleMetaData = function (metaData) {\n  this._metaData = metaData;\n  this._bitmapInfo = Object.create(metaData);\n\n  this._filter = new FilterAsync(this._bitmapInfo);\n};\n\nParserAsync.prototype._handleTransColor = function (transColor) {\n  this._bitmapInfo.transColor = transColor;\n};\n\nParserAsync.prototype._handlePalette = function (palette) {\n  this._bitmapInfo.palette = palette;\n};\n\nParserAsync.prototype._simpleTransparency = function () {\n  this._metaData.alpha = true;\n};\n\nParserAsync.prototype._headersFinished = function () {\n  // Up until this point, we don't know if we have a tRNS chunk (alpha)\n  // so we can't emit metadata any earlier\n  this.emit(\"metadata\", this._metaData);\n};\n\nParserAsync.prototype._finished = function () {\n  if (this.errord) {\n    return;\n  }\n\n  if (!this._inflate) {\n    this.emit(\"error\", \"No Inflate block\");\n  } else {\n    // no more data to inflate\n    this._inflate.end();\n  }\n};\n\nParserAsync.prototype._complete = function (filteredData) {\n  if (this.errord) {\n    return;\n  }\n\n  let normalisedBitmapData;\n\n  try {\n    let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);\n\n    normalisedBitmapData = formatNormaliser(\n      bitmapData,\n      this._bitmapInfo,\n      this._options.skipRescale\n    );\n    bitmapData = null;\n  } catch (ex) {\n    this._handleError(ex);\n    return;\n  }\n\n  this.emit(\"parsed\", normalisedBitmapData);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}