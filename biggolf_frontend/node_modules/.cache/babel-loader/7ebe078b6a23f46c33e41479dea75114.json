{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsePlistFile = parsePlistFile;\nexports.parsePlist = parsePlist;\nexports.createPlist = createPlist;\nexports.updatePlistFile = updatePlistFile;\nexports.createBinaryPlist = createBinaryPlist;\nexports.parseBinaryPlist = parseBinaryPlist;\nrequire(\"source-map-support/register\");\nvar _plist = _interopRequireDefault(require(\"plist\"));\nvar _bplistCreator = _interopRequireDefault(require(\"bplist-creator\"));\nvar _bplistParser = _interopRequireDefault(require(\"bplist-parser\"));\nvar _fs = _interopRequireDefault(require(\"./fs\"));\nvar _logger = _interopRequireDefault(require(\"./logger\"));\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nconst BPLIST_IDENTIFIER = {\n  BUFFER: Buffer.from('bplist00'),\n  TEXT: 'bplist00'\n};\nconst PLIST_IDENTIFIER = {\n  BUFFER: Buffer.from('<'),\n  TEXT: '<'\n};\nasync function parseXmlPlistFile(plistFilename) {\n  let xmlContent = await _fs.default.readFile(plistFilename, 'utf8');\n  return _plist.default.parse(xmlContent);\n}\nasync function parsePlistFile(plist) {\n  let mustExist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let quiet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!(await _fs.default.exists(plist))) {\n    if (mustExist) {\n      _logger.default.errorAndThrow(`Plist file doesn't exist: '${plist}'`);\n    } else {\n      _logger.default.debug(`Plist file '${plist}' does not exist. Returning an empty plist.`);\n      return {};\n    }\n  }\n  let obj = {};\n  let type = 'binary';\n  try {\n    obj = await _bplistParser.default.parseFile(plist);\n    if (obj.length) {\n      obj = obj[0];\n    } else {\n      throw new Error(`Binary file '${plist}'' appears to be empty`);\n    }\n  } catch (ign) {\n    try {\n      obj = await parseXmlPlistFile(plist);\n      type = 'xml';\n    } catch (err) {\n      _logger.default.errorAndThrow(`Could not parse plist file '${plist}' as XML: ${err.message}`);\n    }\n  }\n  if (!quiet) {\n    _logger.default.debug(`Parsed plist file '${plist}' as ${type}`);\n  }\n  return obj;\n}\nasync function updatePlistFile(plist, updatedFields) {\n  let binary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let mustExist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let quiet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let obj;\n  try {\n    obj = await parsePlistFile(plist, mustExist);\n  } catch (err) {\n    _logger.default.errorAndThrow(`Could not update plist: ${err.message}`);\n  }\n  _lodash.default.extend(obj, updatedFields);\n  let newPlist = binary ? (0, _bplistCreator.default)(obj) : _plist.default.build(obj);\n  try {\n    await _fs.default.writeFile(plist, newPlist);\n  } catch (err) {\n    _logger.default.errorAndThrow(`Could not save plist: ${err.message}`);\n  }\n  if (!quiet) {\n    _logger.default.debug(`Wrote plist file '${plist}'`);\n  }\n}\nfunction createBinaryPlist(data) {\n  return (0, _bplistCreator.default)(data);\n}\nfunction parseBinaryPlist(data) {\n  return _bplistParser.default.parseBuffer(data);\n}\nfunction getXmlPlist(data) {\n  if (_lodash.default.isString(data) && data.startsWith(PLIST_IDENTIFIER.TEXT)) {\n    return data;\n  }\n  if (_lodash.default.isBuffer(data) && PLIST_IDENTIFIER.BUFFER.compare(data, 0, PLIST_IDENTIFIER.BUFFER.length) === 0) {\n    return data.toString();\n  }\n  return null;\n}\nfunction getBinaryPlist(data) {\n  if (_lodash.default.isString(data) && data.startsWith(BPLIST_IDENTIFIER.TEXT)) {\n    return Buffer.from(data);\n  }\n  if (_lodash.default.isBuffer(data) && BPLIST_IDENTIFIER.BUFFER.compare(data, 0, BPLIST_IDENTIFIER.BUFFER.length) === 0) {\n    return data;\n  }\n  return null;\n}\nfunction createPlist(object) {\n  let binary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (binary) {\n    return createBinaryPlist(object);\n  } else {\n    return _plist.default.build(object);\n  }\n}\nfunction parsePlist(data) {\n  let textPlist = getXmlPlist(data);\n  if (textPlist) {\n    return _plist.default.parse(textPlist);\n  }\n  let binaryPlist = getBinaryPlist(data);\n  if (binaryPlist) {\n    return parseBinaryPlist(binaryPlist)[0];\n  }\n  throw new Error(`Unknown type of plist, data: ${data.toString()}`);\n}\nrequire('source-map-support').install();","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA,MAAMA,iBAAiB,GAAG;EACxBC,MAAM,EAAEC,MAAM,CAACC,IAAP,CAAY,UAAZ,CADgB;EAExBC,IAAI,EAAE;AAFkB,CAA1B;AAIA,MAAMC,gBAAgB,GAAG;EACvBJ,MAAM,EAAEC,MAAM,CAACC,IAAP,CAAY,GAAZ,CADe;EAEvBC,IAAI,EAAE;AAFiB,CAAzB;AAMA,eAAeE,iBAAf,CAAkCC,aAAlC,EAAiD;EAC/C,IAAIC,UAAU,GAAG,MAAMC,YAAGC,QAAH,CAAYH,aAAZ,EAA2B,MAA3B,CAAvB;EACA,OAAOI,eAASC,KAAT,CAAeJ,UAAf,CAAP;AACD;AASD,eAAeK,cAAf,CAA+BC,KAA/B,EAAsE;EAAA,IAAhCC,SAAS,uEAAG,IAAlD;EAAA,IAAwDC,KAAK,uEAAG,IAAhE;EAEE,IAAI,EAAC,MAAMP,YAAGQ,MAAH,CAAUH,KAAV,CAAP,CAAJ,EAA6B;IAC3B,IAAIC,SAAJ,EAAe;MACbG,gBAAIC,aAAJ,CAAmB,8BAA6BL,KAAM,GAAtD;IACD,CAFD,MAEO;MACLI,gBAAIE,KAAJ,CAAW,eAAcN,KAAM,6CAA/B;MACA,OAAO,EAAP;IACD;EACF;EAED,IAAIO,GAAG,GAAG,EAAV;EACA,IAAIC,IAAI,GAAG,QAAX;EACA,IAAI;IACFD,GAAG,GAAG,MAAME,sBAAYC,SAAZ,CAAsBV,KAAtB,CAAZ;IACA,IAAIO,GAAG,CAACI,MAAR,EAAgB;MACdJ,GAAG,GAAGA,GAAG,CAAC,CAAD,CAAT;IACD,CAFD,MAEO;MACL,MAAM,IAAIK,KAAJ,CAAW,gBAAeZ,KAAM,wBAAhC,CAAN;IACD;EACF,CAPD,CAOE,OAAOa,GAAP,EAAY;IACZ,IAAI;MACFN,GAAG,GAAG,MAAMf,iBAAiB,CAACQ,KAAD,CAA7B;MACAQ,IAAI,GAAG,KAAP;IACD,CAHD,CAGE,OAAOM,GAAP,EAAY;MACZV,gBAAIC,aAAJ,CAAmB,+BAA8BL,KAAM,aAAYc,GAAG,CAACC,OAAQ,EAA/E;IACD;EACF;EAED,IAAI,CAACb,KAAL,EAAY;IACVE,gBAAIE,KAAJ,CAAW,sBAAqBN,KAAM,QAAOQ,IAAK,EAAlD;EACD;EACD,OAAOD,GAAP;AACD;AAUD,eAAeS,eAAf,CAAgChB,KAAhC,EAAuCiB,aAAvC,EAAqG;EAAA,IAA/CC,MAAM,uEAAG,IAA/D;EAAA,IAAqEjB,SAAS,uEAAG,IAAjF;EAAA,IAAuFC,KAAK,uEAAG,IAA/F;EACE,IAAIK,GAAJ;EACA,IAAI;IACFA,GAAG,GAAG,MAAMR,cAAc,CAACC,KAAD,EAAQC,SAAR,CAA1B;EACD,CAFD,CAEE,OAAOa,GAAP,EAAY;IACZV,gBAAIC,aAAJ,CAAmB,2BAA0BS,GAAG,CAACC,OAAQ,EAAzD;EACD;EACDI,gBAAEC,MAAF,CAASb,GAAT,EAAcU,aAAd;EACA,IAAII,QAAQ,GAAGH,MAAM,GAAG,4BAAaX,GAAb,CAAH,GAAuBV,eAASyB,KAAT,CAAef,GAAf,CAA5C;EACA,IAAI;IACF,MAAMZ,YAAG4B,SAAH,CAAavB,KAAb,EAAoBqB,QAApB,CAAN;EACD,CAFD,CAEE,OAAOP,GAAP,EAAY;IACZV,gBAAIC,aAAJ,CAAmB,yBAAwBS,GAAG,CAACC,OAAQ,EAAvD;EACD;EACD,IAAI,CAACb,KAAL,EAAY;IACVE,gBAAIE,KAAJ,CAAW,qBAAoBN,KAAM,GAArC;EACD;AACF;AAMD,SAASwB,iBAAT,CAA4BC,IAA5B,EAAkC;EAChC,OAAO,4BAAaA,IAAb,CAAP;AACD;AAMD,SAASC,gBAAT,CAA2BD,IAA3B,EAAiC;EAC/B,OAAOhB,sBAAYkB,WAAZ,CAAwBF,IAAxB,CAAP;AACD;AAED,SAASG,WAAT,CAAsBH,IAAtB,EAA4B;EAC1B,IAAIN,gBAAEU,QAAF,CAAWJ,IAAX,KAAoBA,IAAI,CAACK,UAAL,CAAgBvC,gBAAgB,CAACD,IAAjC,CAAxB,EAAgE;IAC9D,OAAOmC,IAAP;EACD;EACD,IAAIN,gBAAEY,QAAF,CAAWN,IAAX,KAAoBlC,gBAAgB,CAACJ,MAAjB,CAAwB6C,OAAxB,CAAgCP,IAAhC,EAAsC,CAAtC,EAAyClC,gBAAgB,CAACJ,MAAjB,CAAwBwB,MAAjE,MAA6E,CAArG,EAAwG;IACtG,OAAOc,IAAI,CAACQ,QAAL,EAAP;EACD;EACD,OAAO,IAAP;AACD;AAED,SAASC,cAAT,CAAyBT,IAAzB,EAA+B;EAC7B,IAAIN,gBAAEU,QAAF,CAAWJ,IAAX,KAAoBA,IAAI,CAACK,UAAL,CAAgB5C,iBAAiB,CAACI,IAAlC,CAAxB,EAAiE;IAC/D,OAAOF,MAAM,CAACC,IAAP,CAAYoC,IAAZ,CAAP;EACD;EAED,IAAIN,gBAAEY,QAAF,CAAWN,IAAX,KAAoBvC,iBAAiB,CAACC,MAAlB,CAAyB6C,OAAzB,CAAiCP,IAAjC,EAAuC,CAAvC,EAA0CvC,iBAAiB,CAACC,MAAlB,CAAyBwB,MAAnE,MAA+E,CAAvG,EAA0G;IACxG,OAAOc,IAAP;EACD;EACD,OAAO,IAAP;AACD;AAQD,SAASU,WAAT,CAAsBC,MAAtB,EAA8C;EAAA,IAAhBlB,MAAM,uEAAG,KAAvC;EACE,IAAIA,MAAJ,EAAY;IACV,OAAOM,iBAAiB,CAACY,MAAD,CAAxB;EACD,CAFD,MAEO;IACL,OAAOvC,eAASyB,KAAT,CAAec,MAAf,CAAP;EACD;AACF;AAQD,SAASC,UAAT,CAAqBZ,IAArB,EAA2B;EACzB,IAAIa,SAAS,GAAGV,WAAW,CAACH,IAAD,CAA3B;EACA,IAAIa,SAAJ,EAAe;IACb,OAAOzC,eAASC,KAAT,CAAewC,SAAf,CAAP;EACD;EAED,IAAIC,WAAW,GAAGL,cAAc,CAACT,IAAD,CAAhC;EACA,IAAIc,WAAJ,EAAiB;IACf,OAAOb,gBAAgB,CAACa,WAAD,CAAhB,CAA8B,CAA9B,CAAP;EACD;EAED,MAAM,IAAI3B,KAAJ,CAAW,gCAA+Ba,IAAI,CAACQ,QAAL,EAAgB,EAA1D,CAAN;AACD;AAAAO","names":["BPLIST_IDENTIFIER","BUFFER","Buffer","from","TEXT","PLIST_IDENTIFIER","parseXmlPlistFile","plistFilename","xmlContent","fs","readFile","xmlplist","parse","parsePlistFile","plist","mustExist","quiet","exists","log","errorAndThrow","debug","obj","type","bplistParse","parseFile","length","Error","ign","err","message","updatePlistFile","updatedFields","binary","_","extend","newPlist","build","writeFile","createBinaryPlist","data","parseBinaryPlist","parseBuffer","getXmlPlist","isString","startsWith","isBuffer","compare","toString","getBinaryPlist","createPlist","object","parsePlist","textPlist","binaryPlist","require"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\plist.js"],"sourcesContent":["import xmlplist from 'plist';\nimport bplistCreate from 'bplist-creator';\nimport bplistParse from 'bplist-parser';\nimport fs from './fs';\nimport log from './logger';\nimport _ from 'lodash';\n\n\nconst BPLIST_IDENTIFIER = {\n  BUFFER: Buffer.from('bplist00'),\n  TEXT: 'bplist00'\n};\nconst PLIST_IDENTIFIER = {\n  BUFFER: Buffer.from('<'),\n  TEXT: '<'\n};\n\n// XML Plist library helper\nasync function parseXmlPlistFile (plistFilename) {\n  let xmlContent = await fs.readFile(plistFilename, 'utf8');\n  return xmlplist.parse(xmlContent);\n}\n\n/**\n * Parses a file in xml or binary format of plist\n * @param {string} plist The plist file path\n * @param {boolean} mustExist If set to false, this method will return an empty object when the file doesn't exist\n * @param {boolean} quiet If set to false, the plist path will be logged in debug level\n * @returns {Object} parsed plist JS Object\n */\nasync function parsePlistFile (plist, mustExist = true, quiet = true) {\n  // handle nonexistant file\n  if (!await fs.exists(plist)) {\n    if (mustExist) {\n      log.errorAndThrow(`Plist file doesn't exist: '${plist}'`);\n    } else {\n      log.debug(`Plist file '${plist}' does not exist. Returning an empty plist.`);\n      return {};\n    }\n  }\n\n  let obj = {};\n  let type = 'binary';\n  try {\n    obj = await bplistParse.parseFile(plist);\n    if (obj.length) {\n      obj = obj[0];\n    } else {\n      throw new Error(`Binary file '${plist}'' appears to be empty`);\n    }\n  } catch (ign) {\n    try {\n      obj = await parseXmlPlistFile(plist);\n      type = 'xml';\n    } catch (err) {\n      log.errorAndThrow(`Could not parse plist file '${plist}' as XML: ${err.message}`);\n    }\n  }\n\n  if (!quiet) {\n    log.debug(`Parsed plist file '${plist}' as ${type}`);\n  }\n  return obj;\n}\n\n/**\n * Updates a plist file with the given fields\n * @param {string} plist The plist file path\n * @param {Object} updatedFields The updated fields-value pairs\n * @param {boolean} binary If set to false, the file will be created as a xml plist\n * @param {boolean} mustExist If set to false, this method will update an empty plist\n * @param {boolean} quiet If set to false, the plist path will be logged in debug level\n */\nasync function updatePlistFile (plist, updatedFields, binary = true, mustExist = true, quiet = true) {\n  let obj;\n  try {\n    obj = await parsePlistFile(plist, mustExist);\n  } catch (err) {\n    log.errorAndThrow(`Could not update plist: ${err.message}`);\n  }\n  _.extend(obj, updatedFields);\n  let newPlist = binary ? bplistCreate(obj) : xmlplist.build(obj);\n  try {\n    await fs.writeFile(plist, newPlist);\n  } catch (err) {\n    log.errorAndThrow(`Could not save plist: ${err.message}`);\n  }\n  if (!quiet) {\n    log.debug(`Wrote plist file '${plist}'`);\n  }\n}\n/**\n * Creates a binary plist Buffer from an object\n * @param {Object} data The object to be turned into a binary plist\n * @returns {Buffer} plist in the form of a binary buffer\n */\nfunction createBinaryPlist (data) {\n  return bplistCreate(data);\n}\n\n/**\n * Parses a Buffer into an Object\n * @param {Buffer} data The beffer of a binary plist\n */\nfunction parseBinaryPlist (data) {\n  return bplistParse.parseBuffer(data);\n}\n\nfunction getXmlPlist (data) {\n  if (_.isString(data) && data.startsWith(PLIST_IDENTIFIER.TEXT)) {\n    return data;\n  }\n  if (_.isBuffer(data) && PLIST_IDENTIFIER.BUFFER.compare(data, 0, PLIST_IDENTIFIER.BUFFER.length) === 0) {\n    return data.toString();\n  }\n  return null;\n}\n\nfunction getBinaryPlist (data) {\n  if (_.isString(data) && data.startsWith(BPLIST_IDENTIFIER.TEXT)) {\n    return Buffer.from(data);\n  }\n\n  if (_.isBuffer(data) && BPLIST_IDENTIFIER.BUFFER.compare(data, 0, BPLIST_IDENTIFIER.BUFFER.length) === 0) {\n    return data;\n  }\n  return null;\n}\n\n/**\n * Creates a plist from an object\n * @param {Object} object The JS object to be turned into a plist\n * @param {boolean} binary Set it to true for a binary plist\n * @returns {string|Buffer} returns a buffer or a string in respect to the binary parameter\n */\nfunction createPlist (object, binary = false) {\n  if (binary) {\n    return createBinaryPlist(object);\n  } else {\n    return xmlplist.build(object);\n  }\n}\n\n/**\n * Parses an buffer or a string to a JS object a plist from an object\n * @param {string|Buffer} data The plist in the form of string or Buffer\n * @returns {Object} parsed plist JS Object\n * @throws Will throw an error if the plist type is unknown\n */\nfunction parsePlist (data) {\n  let textPlist = getXmlPlist(data);\n  if (textPlist) {\n    return xmlplist.parse(textPlist);\n  }\n\n  let binaryPlist = getBinaryPlist(data);\n  if (binaryPlist) {\n    return parseBinaryPlist(binaryPlist)[0];\n  }\n\n  throw new Error(`Unknown type of plist, data: ${data.toString()}`);\n}\n\nexport { parsePlistFile, parsePlist, createPlist, updatePlistFile, createBinaryPlist, parseBinaryPlist };\n"]},"metadata":{},"sourceType":"script"}