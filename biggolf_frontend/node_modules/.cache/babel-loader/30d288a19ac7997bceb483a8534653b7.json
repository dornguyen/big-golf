{"ast":null,"code":"var util = require(\"util\"),\n  stream = require(\"stream\"),\n  constants = require(\"./constants\");\n\n// TODO: clear up specs on returning false from a write and emitting a drain event.\n// Does this mean if I return false from a write, I should ignore any write requests between that false return and the drain event?\nvar WritableStreamBuffer = module.exports = function (opts) {\n  var that = this;\n  stream.Stream.call(this);\n  opts = opts || {};\n  var initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;\n  var incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;\n  var buffer = new Buffer(initialSize);\n  var size = 0;\n  this.writable = true;\n  this.readable = false;\n  this.size = function () {\n    return size;\n  };\n  this.maxSize = function () {\n    return buffer.length;\n  };\n  this.getContents = function (length) {\n    if (!size) return false;\n    var data = new Buffer(Math.min(length || size, size));\n    buffer.copy(data, 0, 0, data.length);\n    if (data.length < size) buffer.copy(buffer, 0, data.length);\n    size -= data.length;\n    return data;\n  };\n  this.getContentsAsString = function (encoding, length) {\n    if (!size) return false;\n    var data = buffer.toString(encoding || \"utf8\", 0, Math.min(length || size, size));\n    var dataLength = Buffer.byteLength(data);\n    if (dataLength < size) buffer.copy(buffer, 0, dataLength);\n    size -= dataLength;\n    return data;\n  };\n  var increaseBufferIfNecessary = function (incomingDataSize) {\n    if (buffer.length - size < incomingDataSize) {\n      var factor = Math.ceil((incomingDataSize - (buffer.length - size)) / incrementAmount);\n      var newBuffer = new Buffer(buffer.length + incrementAmount * factor);\n      buffer.copy(newBuffer, 0, 0, size);\n      buffer = newBuffer;\n    }\n  };\n  this.write = function (data, encoding, callback) {\n    if (!that.writable) return;\n    if (Buffer.isBuffer(data)) {\n      increaseBufferIfNecessary(data.length);\n      data.copy(buffer, size, 0);\n      size += data.length;\n    } else {\n      data = data + \"\";\n      increaseBufferIfNecessary(Buffer.byteLength(data));\n      buffer.write(data, size, encoding || \"utf8\");\n      size += Buffer.byteLength(data);\n    }\n    if (typeof callback === \"function\") {\n      callback();\n    }\n  };\n  this.end = function () {\n    var args = Array.prototype.slice.apply(arguments);\n    if (args.length) that.write.apply(that, args);\n    that.emit('finish');\n    that.destroy();\n  };\n  this.destroySoon = this.destroy = function () {\n    that.writable = false;\n    that.emit(\"close\");\n  };\n};\nutil.inherits(WritableStreamBuffer, stream.Stream);","map":{"version":3,"names":["util","require","stream","constants","WritableStreamBuffer","module","exports","opts","that","Stream","call","initialSize","DEFAULT_INITIAL_SIZE","incrementAmount","DEFAULT_INCREMENT_AMOUNT","buffer","Buffer","size","writable","readable","maxSize","length","getContents","data","Math","min","copy","getContentsAsString","encoding","toString","dataLength","byteLength","increaseBufferIfNecessary","incomingDataSize","factor","ceil","newBuffer","write","callback","isBuffer","end","args","Array","prototype","slice","apply","arguments","emit","destroy","destroySoon","inherits"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/stream-buffers/lib/writable_streambuffer.js"],"sourcesContent":["var util = require(\"util\"),\r\n\tstream = require(\"stream\"),\r\n\tconstants = require(\"./constants\");\r\n\r\n// TODO: clear up specs on returning false from a write and emitting a drain event.\r\n// Does this mean if I return false from a write, I should ignore any write requests between that false return and the drain event?\r\nvar WritableStreamBuffer = module.exports = function(opts) {\r\n\tvar that = this;\r\n\r\n\tstream.Stream.call(this);\r\n\r\n\topts = opts || {};\r\n\tvar initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;\r\n\tvar incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;\r\n\r\n\tvar buffer = new Buffer(initialSize);\r\n\tvar size = 0;\r\n\r\n\tthis.writable = true;\r\n\tthis.readable = false;\r\n\r\n\tthis.size = function() {\r\n\t\treturn size;\r\n\t};\r\n\r\n\tthis.maxSize = function() {\r\n\t\treturn buffer.length;\r\n\t};\r\n\r\n\tthis.getContents = function(length) {\r\n\t\tif(!size) return false;\r\n\r\n\t\tvar data = new Buffer(Math.min(length || size, size));\r\n\t\tbuffer.copy(data, 0, 0, data.length);\r\n\r\n\t\tif(data.length < size)\r\n\t\t\tbuffer.copy(buffer, 0, data.length);\r\n\r\n\t\tsize -= data.length;\r\n\r\n\t\treturn data;\r\n\t};\r\n\r\n\tthis.getContentsAsString = function(encoding, length) {\r\n\t\tif(!size) return false;\r\n\r\n\t\tvar data = buffer.toString(encoding || \"utf8\", 0, Math.min(length || size, size));\r\n\t\tvar dataLength = Buffer.byteLength(data);\r\n\r\n\t\tif(dataLength < size)\r\n\t\t\tbuffer.copy(buffer, 0, dataLength);\r\n\r\n\t\tsize -= dataLength;\r\n\t\treturn data;\r\n\t};\r\n\r\n\tvar increaseBufferIfNecessary = function(incomingDataSize) {\r\n\t\tif((buffer.length - size) < incomingDataSize) {\r\n\t\t\tvar factor = Math.ceil((incomingDataSize - (buffer.length - size)) / incrementAmount);\r\n\r\n\t\t\tvar newBuffer = new Buffer(buffer.length + (incrementAmount * factor));\r\n\t\t\tbuffer.copy(newBuffer, 0, 0, size);\r\n\t\t\tbuffer = newBuffer;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.write = function(data, encoding, callback) {\r\n\t\tif(!that.writable) return;\r\n\r\n\t\tif(Buffer.isBuffer(data)) {\r\n\t\t\tincreaseBufferIfNecessary(data.length);\r\n\t\t\tdata.copy(buffer, size, 0);\r\n\t\t\tsize += data.length;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdata = data + \"\";\r\n\t\t\tincreaseBufferIfNecessary(Buffer.byteLength(data));\r\n\t\t\tbuffer.write(data, size, encoding || \"utf8\");\r\n\t\t\tsize += Buffer.byteLength(data);\r\n\t\t}\r\n\t\t\r\n\t\tif(typeof callback === \"function\") { callback() ;}\r\n\t};\r\n\r\n\tthis.end = function() {\r\n\t\tvar args = Array.prototype.slice.apply(arguments);\r\n\t\tif(args.length) that.write.apply(that, args);\r\n\t\tthat.emit('finish');\r\n\t\tthat.destroy();\r\n\t};\r\n\r\n\tthis.destroySoon = this.destroy = function() {\r\n\t\tthat.writable = false;\r\n\t\tthat.emit(\"close\");\r\n\t};\r\n};\r\nutil.inherits(WritableStreamBuffer, stream.Stream);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}