{"ast":null,"code":"/* eslint-disable no-console */\n\n'use strict';\n\n// adapted from https://github.com/3breadt/dd-plist\nconst fs = require('fs');\nconst bigInt = require('big-integer');\nconst debug = false;\nexports.maxObjectSize = 100 * 1000 * 1000; // 100Meg\nexports.maxObjectCount = 32768;\n\n// EPOCH = new SimpleDateFormat(\"yyyy MM dd zzz\").parse(\"2001 01 01 GMT\").getTime();\n// ...but that's annoying in a static initializer because it can throw exceptions, ick.\n// So we just hardcode the correct value.\nconst EPOCH = 978307200000;\n\n// UID object definition\nconst UID = exports.UID = function (id) {\n  this.UID = id;\n};\nexports.parseFile = function (fileNameOrBuffer, callback) {\n  return new Promise(function (resolve, reject) {\n    function tryParseBuffer(buffer) {\n      let err = null;\n      let result;\n      try {\n        result = parseBuffer(buffer);\n        resolve(result);\n      } catch (ex) {\n        err = ex;\n        reject(err);\n      } finally {\n        if (callback) callback(err, result);\n      }\n    }\n    if (Buffer.isBuffer(fileNameOrBuffer)) {\n      return tryParseBuffer(fileNameOrBuffer);\n    }\n    fs.readFile(fileNameOrBuffer, function (err, data) {\n      if (err) {\n        reject(err);\n        return callback(err);\n      }\n      tryParseBuffer(data);\n    });\n  });\n};\nconst parseBuffer = exports.parseBuffer = function (buffer) {\n  // check header\n  const header = buffer.slice(0, 'bplist'.length).toString('utf8');\n  if (header !== 'bplist') {\n    throw new Error(\"Invalid binary plist. Expected 'bplist' at offset 0.\");\n  }\n\n  // Handle trailer, last 32 bytes of the file\n  const trailer = buffer.slice(buffer.length - 32, buffer.length);\n  // 6 null bytes (index 0 to 5)\n  const offsetSize = trailer.readUInt8(6);\n  if (debug) {\n    console.log(\"offsetSize: \" + offsetSize);\n  }\n  const objectRefSize = trailer.readUInt8(7);\n  if (debug) {\n    console.log(\"objectRefSize: \" + objectRefSize);\n  }\n  const numObjects = readUInt64BE(trailer, 8);\n  if (debug) {\n    console.log(\"numObjects: \" + numObjects);\n  }\n  const topObject = readUInt64BE(trailer, 16);\n  if (debug) {\n    console.log(\"topObject: \" + topObject);\n  }\n  const offsetTableOffset = readUInt64BE(trailer, 24);\n  if (debug) {\n    console.log(\"offsetTableOffset: \" + offsetTableOffset);\n  }\n  if (numObjects > exports.maxObjectCount) {\n    throw new Error(\"maxObjectCount exceeded\");\n  }\n\n  // Handle offset table\n  const offsetTable = [];\n  for (let i = 0; i < numObjects; i++) {\n    const offsetBytes = buffer.slice(offsetTableOffset + i * offsetSize, offsetTableOffset + (i + 1) * offsetSize);\n    offsetTable[i] = readUInt(offsetBytes, 0);\n    if (debug) {\n      console.log(\"Offset for Object #\" + i + \" is \" + offsetTable[i] + \" [\" + offsetTable[i].toString(16) + \"]\");\n    }\n  }\n\n  // Parses an object inside the currently parsed binary property list.\n  // For the format specification check\n  // <a href=\"https://www.opensource.apple.com/source/CF/CF-635/CFBinaryPList.c\">\n  // Apple's binary property list parser implementation</a>.\n  function parseObject(tableOffset) {\n    const offset = offsetTable[tableOffset];\n    const type = buffer[offset];\n    const objType = (type & 0xF0) >> 4; //First  4 bits\n    const objInfo = type & 0x0F; //Second 4 bits\n    switch (objType) {\n      case 0x0:\n        return parseSimple();\n      case 0x1:\n        return parseInteger();\n      case 0x8:\n        return parseUID();\n      case 0x2:\n        return parseReal();\n      case 0x3:\n        return parseDate();\n      case 0x4:\n        return parseData();\n      case 0x5:\n        // ASCII\n        return parsePlistString();\n      case 0x6:\n        // UTF-16\n        return parsePlistString(true);\n      case 0xA:\n        return parseArray();\n      case 0xD:\n        return parseDictionary();\n      default:\n        throw new Error(\"Unhandled type 0x\" + objType.toString(16));\n    }\n    function parseSimple() {\n      //Simple\n      switch (objInfo) {\n        case 0x0:\n          // null\n          return null;\n        case 0x8:\n          // false\n          return false;\n        case 0x9:\n          // true\n          return true;\n        case 0xF:\n          // filler byte\n          return null;\n        default:\n          throw new Error(\"Unhandled simple type 0x\" + objType.toString(16));\n      }\n    }\n    function bufferToHexString(buffer) {\n      let str = '';\n      let i;\n      for (i = 0; i < buffer.length; i++) {\n        if (buffer[i] != 0x00) {\n          break;\n        }\n      }\n      for (; i < buffer.length; i++) {\n        const part = '00' + buffer[i].toString(16);\n        str += part.substr(part.length - 2);\n      }\n      return str;\n    }\n    function parseInteger() {\n      const length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        const data = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 16) {\n          const str = bufferToHexString(data);\n          return bigInt(str, 16);\n        }\n        return data.reduce((acc, curr) => {\n          acc <<= 8;\n          acc |= curr & 255;\n          return acc;\n        });\n      } else {\n        throw new Error(\"To little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n    function parseUID() {\n      const length = objInfo + 1;\n      if (length < exports.maxObjectSize) {\n        return new UID(readUInt(buffer.slice(offset + 1, offset + 1 + length)));\n      }\n      throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n    }\n    function parseReal() {\n      const length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        const realBuffer = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 4) {\n          return realBuffer.readFloatBE(0);\n        }\n        if (length === 8) {\n          return realBuffer.readDoubleBE(0);\n        }\n      } else {\n        throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n    function parseDate() {\n      if (objInfo != 0x3) {\n        console.error(\"Unknown date type :\" + objInfo + \". Parsing anyway...\");\n      }\n      const dateBuffer = buffer.slice(offset + 1, offset + 9);\n      return new Date(EPOCH + 1000 * dateBuffer.readDoubleBE(0));\n    }\n    function parseData() {\n      let dataoffset = 1;\n      let length = objInfo;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"0x4: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        dataoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length < exports.maxObjectSize) {\n        return buffer.slice(offset + dataoffset, offset + dataoffset + length);\n      }\n      throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n    }\n    function parsePlistString(isUtf16) {\n      isUtf16 = isUtf16 || 0;\n      let enc = \"utf8\";\n      let length = objInfo;\n      let stroffset = 1;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        stroffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      // length is String length -> to get byte length multiply by 2, as 1 character takes 2 bytes in UTF-16\n      length *= isUtf16 + 1;\n      if (length < exports.maxObjectSize) {\n        let plistString = Buffer.from(buffer.slice(offset + stroffset, offset + stroffset + length));\n        if (isUtf16) {\n          plistString = swapBytes(plistString);\n          enc = \"ucs2\";\n        }\n        return plistString.toString(enc);\n      }\n      throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n    }\n    function parseArray() {\n      let length = objInfo;\n      let arrayoffset = 1;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"0xa: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        arrayoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * objectRefSize > exports.maxObjectSize) {\n        throw new Error(\"Too little heap space available!\");\n      }\n      const array = [];\n      for (let i = 0; i < length; i++) {\n        const objRef = readUInt(buffer.slice(offset + arrayoffset + i * objectRefSize, offset + arrayoffset + (i + 1) * objectRefSize));\n        array[i] = parseObject(objRef);\n      }\n      return array;\n    }\n    function parseDictionary() {\n      let length = objInfo;\n      let dictoffset = 1;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"0xD: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        dictoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * 2 * objectRefSize > exports.maxObjectSize) {\n        throw new Error(\"Too little heap space available!\");\n      }\n      if (debug) {\n        console.log(\"Parsing dictionary #\" + tableOffset);\n      }\n      const dict = {};\n      for (let i = 0; i < length; i++) {\n        const keyRef = readUInt(buffer.slice(offset + dictoffset + i * objectRefSize, offset + dictoffset + (i + 1) * objectRefSize));\n        const valRef = readUInt(buffer.slice(offset + dictoffset + length * objectRefSize + i * objectRefSize, offset + dictoffset + length * objectRefSize + (i + 1) * objectRefSize));\n        const key = parseObject(keyRef);\n        const val = parseObject(valRef);\n        if (debug) {\n          console.log(\"  DICT #\" + tableOffset + \": Mapped \" + key + \" to \" + val);\n        }\n        dict[key] = val;\n      }\n      return dict;\n    }\n  }\n  return [parseObject(topObject)];\n};\nfunction readUInt(buffer, start) {\n  start = start || 0;\n  let l = 0;\n  for (let i = start; i < buffer.length; i++) {\n    l <<= 8;\n    l |= buffer[i] & 0xFF;\n  }\n  return l;\n}\n\n// we're just going to toss the high order bits because javascript doesn't have 64-bit ints\nfunction readUInt64BE(buffer, start) {\n  const data = buffer.slice(start, start + 8);\n  return data.readUInt32BE(4, 8);\n}\nfunction swapBytes(buffer) {\n  const len = buffer.length;\n  for (let i = 0; i < len; i += 2) {\n    const a = buffer[i];\n    buffer[i] = buffer[i + 1];\n    buffer[i + 1] = a;\n  }\n  return buffer;\n}","map":{"version":3,"names":["fs","require","bigInt","debug","exports","maxObjectSize","maxObjectCount","EPOCH","UID","id","parseFile","fileNameOrBuffer","callback","Promise","resolve","reject","tryParseBuffer","buffer","err","result","parseBuffer","ex","Buffer","isBuffer","readFile","data","header","slice","length","toString","Error","trailer","offsetSize","readUInt8","console","log","objectRefSize","numObjects","readUInt64BE","topObject","offsetTableOffset","offsetTable","i","offsetBytes","readUInt","parseObject","tableOffset","offset","type","objType","objInfo","parseSimple","parseInteger","parseUID","parseReal","parseDate","parseData","parsePlistString","parseArray","parseDictionary","bufferToHexString","str","part","substr","Math","pow","reduce","acc","curr","realBuffer","readFloatBE","readDoubleBE","error","dateBuffer","Date","dataoffset","int_type","intType","intInfo","intLength","isUtf16","enc","stroffset","plistString","from","swapBytes","arrayoffset","array","objRef","dictoffset","dict","keyRef","valRef","key","val","start","l","readUInt32BE","len","a"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/bplist-parser/bplistParser.js"],"sourcesContent":["/* eslint-disable no-console */\n\n'use strict';\n\n// adapted from https://github.com/3breadt/dd-plist\n\nconst fs = require('fs');\nconst bigInt = require('big-integer');\nconst debug = false;\n\nexports.maxObjectSize = 100 * 1000 * 1000; // 100Meg\nexports.maxObjectCount = 32768;\n\n// EPOCH = new SimpleDateFormat(\"yyyy MM dd zzz\").parse(\"2001 01 01 GMT\").getTime();\n// ...but that's annoying in a static initializer because it can throw exceptions, ick.\n// So we just hardcode the correct value.\nconst EPOCH = 978307200000;\n\n// UID object definition\nconst UID = exports.UID = function(id) {\n  this.UID = id;\n};\n\nexports.parseFile = function (fileNameOrBuffer, callback) {\n  return new Promise(function (resolve, reject) {\n    function tryParseBuffer(buffer) {\n      let err = null;\n      let result;\n      try {\n        result = parseBuffer(buffer);\n        resolve(result);\n      } catch (ex) {\n        err = ex;\n        reject(err);\n      } finally {\n        if (callback) callback(err, result);\n      }\n    }\n\n    if (Buffer.isBuffer(fileNameOrBuffer)) {\n      return tryParseBuffer(fileNameOrBuffer);\n    }\n    fs.readFile(fileNameOrBuffer, function (err, data) {\n      if (err) {\n        reject(err);\n        return callback(err);\n      }\n      tryParseBuffer(data);\n    });\n  });\n};\n\nconst parseBuffer = exports.parseBuffer = function (buffer) {\n  // check header\n  const header = buffer.slice(0, 'bplist'.length).toString('utf8');\n  if (header !== 'bplist') {\n    throw new Error(\"Invalid binary plist. Expected 'bplist' at offset 0.\");\n  }\n\n  // Handle trailer, last 32 bytes of the file\n  const trailer = buffer.slice(buffer.length - 32, buffer.length);\n  // 6 null bytes (index 0 to 5)\n  const offsetSize = trailer.readUInt8(6);\n  if (debug) {\n    console.log(\"offsetSize: \" + offsetSize);\n  }\n  const objectRefSize = trailer.readUInt8(7);\n  if (debug) {\n    console.log(\"objectRefSize: \" + objectRefSize);\n  }\n  const numObjects = readUInt64BE(trailer, 8);\n  if (debug) {\n    console.log(\"numObjects: \" + numObjects);\n  }\n  const topObject = readUInt64BE(trailer, 16);\n  if (debug) {\n    console.log(\"topObject: \" + topObject);\n  }\n  const offsetTableOffset = readUInt64BE(trailer, 24);\n  if (debug) {\n    console.log(\"offsetTableOffset: \" + offsetTableOffset);\n  }\n\n  if (numObjects > exports.maxObjectCount) {\n    throw new Error(\"maxObjectCount exceeded\");\n  }\n\n  // Handle offset table\n  const offsetTable = [];\n\n  for (let i = 0; i < numObjects; i++) {\n    const offsetBytes = buffer.slice(offsetTableOffset + i * offsetSize, offsetTableOffset + (i + 1) * offsetSize);\n    offsetTable[i] = readUInt(offsetBytes, 0);\n    if (debug) {\n      console.log(\"Offset for Object #\" + i + \" is \" + offsetTable[i] + \" [\" + offsetTable[i].toString(16) + \"]\");\n    }\n  }\n\n  // Parses an object inside the currently parsed binary property list.\n  // For the format specification check\n  // <a href=\"https://www.opensource.apple.com/source/CF/CF-635/CFBinaryPList.c\">\n  // Apple's binary property list parser implementation</a>.\n  function parseObject(tableOffset) {\n    const offset = offsetTable[tableOffset];\n    const type = buffer[offset];\n    const objType = (type & 0xF0) >> 4; //First  4 bits\n    const objInfo = (type & 0x0F);      //Second 4 bits\n    switch (objType) {\n    case 0x0:\n      return parseSimple();\n    case 0x1:\n      return parseInteger();\n    case 0x8:\n      return parseUID();\n    case 0x2:\n      return parseReal();\n    case 0x3:\n      return parseDate();\n    case 0x4:\n      return parseData();\n    case 0x5: // ASCII\n      return parsePlistString();\n    case 0x6: // UTF-16\n      return parsePlistString(true);\n    case 0xA:\n      return parseArray();\n    case 0xD:\n      return parseDictionary();\n    default:\n      throw new Error(\"Unhandled type 0x\" + objType.toString(16));\n    }\n\n    function parseSimple() {\n      //Simple\n      switch (objInfo) {\n      case 0x0: // null\n        return null;\n      case 0x8: // false\n        return false;\n      case 0x9: // true\n        return true;\n      case 0xF: // filler byte\n        return null;\n      default:\n        throw new Error(\"Unhandled simple type 0x\" + objType.toString(16));\n      }\n    }\n\n    function bufferToHexString(buffer) {\n      let str = '';\n      let i;\n      for (i = 0; i < buffer.length; i++) {\n        if (buffer[i] != 0x00) {\n          break;\n        }\n      }\n      for (; i < buffer.length; i++) {\n        const part = '00' + buffer[i].toString(16);\n        str += part.substr(part.length - 2);\n      }\n      return str;\n    }\n\n    function parseInteger() {\n      const length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        const data = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 16) {\n          const str = bufferToHexString(data);\n          return bigInt(str, 16);\n        }\n        return data.reduce((acc, curr) => {\n          acc <<= 8;\n          acc |= curr & 255;\n          return acc;\n        });\n      } else {\n        throw new Error(\"To little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n\n    function parseUID() {\n      const length = objInfo + 1;\n      if (length < exports.maxObjectSize) {\n        return new UID(readUInt(buffer.slice(offset + 1, offset + 1 + length)));\n      }\n      throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n    }\n\n    function parseReal() {\n      const length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        const realBuffer = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 4) {\n          return realBuffer.readFloatBE(0);\n        }\n        if (length === 8) {\n          return realBuffer.readDoubleBE(0);\n        }\n      } else {\n        throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n      }\n    }\n\n    function parseDate() {\n      if (objInfo != 0x3) {\n        console.error(\"Unknown date type :\" + objInfo + \". Parsing anyway...\");\n      }\n      const dateBuffer = buffer.slice(offset + 1, offset + 9);\n      return new Date(EPOCH + (1000 * dateBuffer.readDoubleBE(0)));\n    }\n\n    function parseData() {\n      let dataoffset = 1;\n      let length = objInfo;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"0x4: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        dataoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length < exports.maxObjectSize) {\n        return buffer.slice(offset + dataoffset, offset + dataoffset + length);\n      }\n      throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n    }\n\n    function parsePlistString (isUtf16) {\n      isUtf16 = isUtf16 || 0;\n      let enc = \"utf8\";\n      let length = objInfo;\n      let stroffset = 1;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        stroffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      // length is String length -> to get byte length multiply by 2, as 1 character takes 2 bytes in UTF-16\n      length *= (isUtf16 + 1);\n      if (length < exports.maxObjectSize) {\n        let plistString = Buffer.from(buffer.slice(offset + stroffset, offset + stroffset + length));\n        if (isUtf16) {\n          plistString = swapBytes(plistString);\n          enc = \"ucs2\";\n        }\n        return plistString.toString(enc);\n      }\n      throw new Error(\"Too little heap space available! Wanted to read \" + length + \" bytes, but only \" + exports.maxObjectSize + \" are available.\");\n    }\n\n    function parseArray() {\n      let length = objInfo;\n      let arrayoffset = 1;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"0xa: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        arrayoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * objectRefSize > exports.maxObjectSize) {\n        throw new Error(\"Too little heap space available!\");\n      }\n      const array = [];\n      for (let i = 0; i < length; i++) {\n        const objRef = readUInt(buffer.slice(offset + arrayoffset + i * objectRefSize, offset + arrayoffset + (i + 1) * objectRefSize));\n        array[i] = parseObject(objRef);\n      }\n      return array;\n    }\n\n    function parseDictionary() {\n      let length = objInfo;\n      let dictoffset = 1;\n      if (objInfo == 0xF) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xF0) / 0x10;\n        if (intType != 0x1) {\n          console.error(\"0xD: UNEXPECTED LENGTH-INT TYPE! \" + intType);\n        }\n        const intInfo = int_type & 0x0F;\n        const intLength = Math.pow(2, intInfo);\n        dictoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * 2 * objectRefSize > exports.maxObjectSize) {\n        throw new Error(\"Too little heap space available!\");\n      }\n      if (debug) {\n        console.log(\"Parsing dictionary #\" + tableOffset);\n      }\n      const dict = {};\n      for (let i = 0; i < length; i++) {\n        const keyRef = readUInt(buffer.slice(offset + dictoffset + i * objectRefSize, offset + dictoffset + (i + 1) * objectRefSize));\n        const valRef = readUInt(buffer.slice(offset + dictoffset + (length * objectRefSize) + i * objectRefSize, offset + dictoffset + (length * objectRefSize) + (i + 1) * objectRefSize));\n        const key = parseObject(keyRef);\n        const val = parseObject(valRef);\n        if (debug) {\n          console.log(\"  DICT #\" + tableOffset + \": Mapped \" + key + \" to \" + val);\n        }\n        dict[key] = val;\n      }\n      return dict;\n    }\n  }\n\n  return [ parseObject(topObject) ];\n};\n\nfunction readUInt(buffer, start) {\n  start = start || 0;\n\n  let l = 0;\n  for (let i = start; i < buffer.length; i++) {\n    l <<= 8;\n    l |= buffer[i] & 0xFF;\n  }\n  return l;\n}\n\n// we're just going to toss the high order bits because javascript doesn't have 64-bit ints\nfunction readUInt64BE(buffer, start) {\n  const data = buffer.slice(start, start + 8);\n  return data.readUInt32BE(4, 8);\n}\n\nfunction swapBytes(buffer) {\n  const len = buffer.length;\n  for (let i = 0; i < len; i += 2) {\n    const a = buffer[i];\n    buffer[i] = buffer[i+1];\n    buffer[i+1] = a;\n  }\n  return buffer;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}