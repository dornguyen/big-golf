{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = composite;\nvar _utils = require(\"@jimp/utils\");\nvar constants = _interopRequireWildcard(require(\"../constants\"));\nvar compositeModes = _interopRequireWildcard(require(\"./composite-modes\"));\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nfunction composite(src, x, y) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var cb = arguments.length > 4 ? arguments[4] : undefined;\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  if (!(src instanceof this.constructor)) {\n    return _utils.throwError.call(this, 'The source must be a Jimp image', cb);\n  }\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return _utils.throwError.call(this, 'x and y must be numbers', cb);\n  }\n  var _options = options,\n    mode = _options.mode,\n    opacitySource = _options.opacitySource,\n    opacityDest = _options.opacityDest;\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n  if (typeof opacitySource !== 'number' || opacitySource < 0 || opacitySource > 1) {\n    opacitySource = 1.0;\n  }\n  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n  var blendmode = compositeModes[mode]; // round input\n\n  x = Math.round(x);\n  y = Math.round(y);\n  var baseImage = this;\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n    var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    var blended = blendmode({\n      r: this.bitmap.data[idx + 0] / 255,\n      g: this.bitmap.data[idx + 1] / 255,\n      b: this.bitmap.data[idx + 2] / 255,\n      a: this.bitmap.data[idx + 3] / 255\n    }, {\n      r: baseImage.bitmap.data[dstIdx + 0] / 255,\n      g: baseImage.bitmap.data[dstIdx + 1] / 255,\n      b: baseImage.bitmap.data[dstIdx + 2] / 255,\n      a: baseImage.bitmap.data[dstIdx + 3] / 255\n    }, opacitySource);\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);\n  });\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n  return this;\n}","map":{"version":3,"mappings":"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","names":["composite","src","x","y","options","cb","constructor","throwError","call","mode","opacitySource","opacityDest","constants","BLEND_SOURCE_OVER","blendmode","compositeModes","Math","round","baseImage","opacity","scanQuiet","bitmap","width","height","sx","sy","idx","dstIdx","getPixelIndex","EDGE_CROP","blended","r","data","g","b","a","limit255"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\@jimp\\core\\src\\composite\\index.js"],"sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\nimport * as constants from '../constants';\n\nimport * as compositeModes from './composite-modes';\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default function composite(src, x, y, options = {}, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!(src instanceof this.constructor)) {\n    return throwError.call(this, 'The source must be a Jimp image', cb);\n  }\n\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  let { mode, opacitySource, opacityDest } = options;\n\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n\n  if (\n    typeof opacitySource !== 'number' ||\n    opacitySource < 0 ||\n    opacitySource > 1\n  ) {\n    opacitySource = 1.0;\n  }\n\n  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  const blendmode = compositeModes[mode];\n\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n\n  const baseImage = this;\n\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(\n    sx,\n    sy,\n    idx\n  ) {\n    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    const blended = blendmode(\n      {\n        r: this.bitmap.data[idx + 0] / 255,\n        g: this.bitmap.data[idx + 1] / 255,\n        b: this.bitmap.data[idx + 2] / 255,\n        a: this.bitmap.data[idx + 3] / 255\n      },\n      {\n        r: baseImage.bitmap.data[dstIdx + 0] / 255,\n        g: baseImage.bitmap.data[dstIdx + 1] / 255,\n        b: baseImage.bitmap.data[dstIdx + 2] / 255,\n        a: baseImage.bitmap.data[dstIdx + 3] / 255\n      },\n      opacitySource\n    );\n\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(\n      blended.r * 255\n    );\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(\n      blended.g * 255\n    );\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(\n      blended.b * 255\n    );\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(\n      blended.a * 255\n    );\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"script"}