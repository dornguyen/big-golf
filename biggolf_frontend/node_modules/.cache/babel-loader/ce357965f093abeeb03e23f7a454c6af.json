{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exec = exec;\nexports.default = void 0;\nrequire(\"source-map-support/register\");\nvar _child_process = require(\"child_process\");\nvar _shellQuote = require(\"shell-quote\");\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _helpers = require(\"./helpers\");\nconst MAX_BUFFER_SIZE = 100 * 1024 * 1024;\nasync function exec(cmd) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const rep = (0, _shellQuote.quote)([cmd, ...args]);\n  opts = Object.assign({\n    timeout: null,\n    encoding: 'utf8',\n    killSignal: 'SIGTERM',\n    cwd: undefined,\n    env: process.env,\n    ignoreOutput: false,\n    stdio: 'inherit',\n    isBuffer: false,\n    shell: undefined,\n    logger: undefined,\n    maxStdoutBufferSize: MAX_BUFFER_SIZE,\n    maxStderrBufferSize: MAX_BUFFER_SIZE\n  }, opts);\n  return await new _bluebird.default((resolve, reject) => {\n    let proc = (0, _child_process.spawn)(cmd, args, {\n      cwd: opts.cwd,\n      env: opts.env,\n      shell: opts.shell\n    });\n    let stdoutArr = [],\n      stderrArr = [],\n      timer = null;\n    proc.on('error', err => {\n      if (err.errno === 'ENOENT') {\n        err = (0, _helpers.formatEnoent)(err, cmd, opts.cwd);\n      }\n      reject(err);\n    });\n    if (proc.stdin) {\n      proc.stdin.on('error', err => {\n        reject(new Error(`Standard input '${err.syscall}' error: ${err.stack}`));\n      });\n    }\n    const handleStream = (streamType, streamProps) => {\n      if (!proc[streamType]) {\n        return;\n      }\n      proc[streamType].on('error', err => {\n        reject(new Error(`${_lodash.default.capitalize(streamType)} '${err.syscall}' error: ${err.stack}`));\n      });\n      if (opts.ignoreOutput) {\n        proc[streamType].on('data', () => {});\n        return;\n      }\n      const {\n        chunks,\n        maxSize\n      } = streamProps;\n      let size = 0;\n      proc[streamType].on('data', chunk => {\n        chunks.push(chunk);\n        size += chunk.length;\n        while (chunks.length > 1 && size >= maxSize) {\n          size -= chunks[0].length;\n          chunks.shift();\n        }\n        if (opts.logger && _lodash.default.isFunction(opts.logger.debug)) {\n          opts.logger.debug(chunk.toString());\n        }\n      });\n    };\n    handleStream('stdout', {\n      maxSize: opts.maxStdoutBufferSize,\n      chunks: stdoutArr\n    });\n    handleStream('stderr', {\n      maxSize: opts.maxStderrBufferSize,\n      chunks: stderrArr\n    });\n    function getStdio(isBuffer) {\n      let stdout, stderr;\n      if (isBuffer) {\n        stdout = Buffer.concat(stdoutArr);\n        stderr = Buffer.concat(stderrArr);\n      } else {\n        stdout = Buffer.concat(stdoutArr).toString(opts.encoding);\n        stderr = Buffer.concat(stderrArr).toString(opts.encoding);\n      }\n      return {\n        stdout,\n        stderr\n      };\n    }\n    proc.on('close', code => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      let {\n        stdout,\n        stderr\n      } = getStdio(opts.isBuffer);\n      if (code === 0) {\n        resolve({\n          stdout,\n          stderr,\n          code\n        });\n      } else {\n        let err = new Error(`Command '${rep}' exited with code ${code}`);\n        err = Object.assign(err, {\n          stdout,\n          stderr,\n          code\n        });\n        reject(err);\n      }\n    });\n    if (opts.timeout) {\n      timer = setTimeout(() => {\n        let {\n          stdout,\n          stderr\n        } = getStdio(opts.isBuffer);\n        let err = new Error(`Command '${rep}' timed out after ${opts.timeout}ms`);\n        err = Object.assign(err, {\n          stdout,\n          stderr,\n          code: null\n        });\n        reject(err);\n        proc.kill(opts.killSignal);\n      }, opts.timeout);\n    }\n  });\n}\nvar _default = exec;\nexports.default = _default;\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["MAX_BUFFER_SIZE","exec","cmd","args","opts","rep","Object","assign","timeout","encoding","killSignal","cwd","undefined","env","process","ignoreOutput","stdio","isBuffer","shell","logger","maxStdoutBufferSize","maxStderrBufferSize","B","resolve","reject","proc","stdoutArr","stderrArr","timer","on","err","errno","stdin","Error","syscall","stack","handleStream","streamType","streamProps","_","capitalize","chunks","maxSize","size","chunk","push","length","shift","isFunction","debug","toString","getStdio","stdout","stderr","Buffer","concat","code","clearTimeout","setTimeout","kill"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\teen_process\\lib\\exec.js"],"sourcesContent":["/* eslint-disable promise/prefer-await-to-callbacks */\n\nimport { spawn } from 'child_process';\nimport { quote } from 'shell-quote';\nimport B from 'bluebird';\nimport _ from 'lodash';\nimport { formatEnoent } from './helpers';\n\nconst MAX_BUFFER_SIZE = 100 * 1024 * 1024;\n\nasync function exec (cmd, args = [], opts = {}) {\n  // get a quoted representation of the command for error strings\n  const rep = quote([cmd, ...args]);\n\n  // extend default options; we're basically re-implementing exec's options\n  // for use here with spawn under the hood\n  opts = Object.assign({\n    timeout: null,\n    encoding: 'utf8',\n    killSignal: 'SIGTERM',\n    cwd: undefined,\n    env: process.env,\n    ignoreOutput: false,\n    stdio: 'inherit',\n    isBuffer: false,\n    shell: undefined,\n    logger: undefined,\n    maxStdoutBufferSize: MAX_BUFFER_SIZE,\n    maxStderrBufferSize: MAX_BUFFER_SIZE,\n  }, opts);\n\n  // this is an async function, so return a promise\n  return await new B((resolve, reject) => {\n    // spawn the child process with options; we don't currently expose any of\n    // the other 'spawn' options through the API\n    let proc = spawn(cmd, args, {cwd: opts.cwd, env: opts.env, shell: opts.shell});\n    let stdoutArr = [], stderrArr = [], timer = null;\n\n    // if the process errors out, reject the promise\n    proc.on('error', (err) => {\n      if (err.errno === 'ENOENT') {\n        err = formatEnoent(err, cmd, opts.cwd);\n      }\n      reject(err);\n    });\n    if (proc.stdin) {\n      proc.stdin.on('error', (err) => {\n        reject(new Error(`Standard input '${err.syscall}' error: ${err.stack}`));\n      });\n    }\n    const handleStream = (streamType, streamProps) => {\n      if (!proc[streamType]) {\n        return;\n      }\n\n      proc[streamType].on('error', (err) => {\n        reject(new Error(`${_.capitalize(streamType)} '${err.syscall}' error: ${err.stack}`));\n      });\n\n      if (opts.ignoreOutput) {\n        // https://github.com/nodejs/node/issues/4236\n        proc[streamType].on('data', () => {});\n        return;\n      }\n\n      // keep track of the stream if we don't want to ignore it\n      const {chunks, maxSize} = streamProps;\n      let size = 0;\n      proc[streamType].on('data', (chunk) => {\n        chunks.push(chunk);\n        size += chunk.length;\n        while (chunks.length > 1 && size >= maxSize) {\n          size -= chunks[0].length;\n          chunks.shift();\n        }\n        if (opts.logger && _.isFunction(opts.logger.debug)) {\n          opts.logger.debug(chunk.toString());\n        }\n      });\n    };\n    handleStream('stdout', {\n      maxSize: opts.maxStdoutBufferSize,\n      chunks: stdoutArr,\n    });\n    handleStream('stderr', {\n      maxSize: opts.maxStderrBufferSize,\n      chunks: stderrArr,\n    });\n\n    function getStdio (isBuffer) {\n      let stdout, stderr;\n      if (isBuffer) {\n        stdout = Buffer.concat(stdoutArr);\n        stderr = Buffer.concat(stderrArr);\n      } else {\n        stdout = Buffer.concat(stdoutArr).toString(opts.encoding);\n        stderr = Buffer.concat(stderrArr).toString(opts.encoding);\n      }\n      return {stdout, stderr};\n    }\n\n    // if the process ends, either resolve or reject the promise based on the\n    // exit code of the process. either way, attach stdout, stderr, and code.\n    // Also clean up the timer if it exists\n    proc.on('close', (code) => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      let {stdout, stderr} = getStdio(opts.isBuffer);\n      if (code === 0) {\n        resolve({stdout, stderr, code});\n      } else {\n        let err = new Error(`Command '${rep}' exited with code ${code}`);\n        err = Object.assign(err, {stdout, stderr, code});\n        reject(err);\n      }\n    });\n\n    // if we set a timeout on the child process, cut into the execution and\n    // reject if the timeout is reached. Attach the stdout/stderr we currently\n    // have in case it's helpful in debugging\n    if (opts.timeout) {\n      timer = setTimeout(() => {\n        let {stdout, stderr} = getStdio(opts.isBuffer);\n        let err = new Error(`Command '${rep}' timed out after ${opts.timeout}ms`);\n        err = Object.assign(err, {stdout, stderr, code: null});\n        reject(err);\n        // reject and THEN kill to avoid race conditions with the handlers\n        // above\n        proc.kill(opts.killSignal);\n      }, opts.timeout);\n    }\n  });\n}\n\nexport { exec };\nexport default exec;\n"]},"metadata":{},"sourceType":"script"}