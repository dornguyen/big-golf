{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBitmap = parseBitmap;\nexports.getBuffer = getBuffer;\nexports.getBufferAsync = getBufferAsync;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _fileType = _interopRequireDefault(require(\"file-type\"));\nvar _exifParser = _interopRequireDefault(require(\"exif-parser\"));\nvar _utils = require(\"@jimp/utils\");\nvar constants = _interopRequireWildcard(require(\"../constants\"));\nvar MIME = _interopRequireWildcard(require(\"./mime\"));\nvar _promisify = _interopRequireDefault(require(\"./promisify\"));\nfunction getMIMEFromBuffer(buffer, path) {\n  var fileTypeFromBuffer = (0, _fileType[\"default\"])(buffer);\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n  return null;\n}\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\n\nfunction getExifOrientation(img) {\n  return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;\n}\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\n\nfunction getExifOrientationTransformation(img) {\n  var w = img.getWidth();\n  var h = img.getHeight();\n  switch (getExifOrientation(img)) {\n    case 1:\n      // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n    case 2:\n      // Mirror horizontal\n      return function (x, y) {\n        return [w - x - 1, y];\n      };\n    case 3:\n      // Rotate 180\n      return function (x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n    case 4:\n      // Mirror vertical\n      return function (x, y) {\n        return [x, h - y - 1];\n      };\n    case 5:\n      // Mirror horizontal and rotate 270 CW\n      return function (x, y) {\n        return [y, x];\n      };\n    case 6:\n      // Rotate 90 CW\n      return function (x, y) {\n        return [y, h - x - 1];\n      };\n    case 7:\n      // Mirror horizontal and rotate 90 CW\n      return function (x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n    case 8:\n      // Rotate 270 CW\n      return function (x, y) {\n        return [w - y - 1, x];\n      };\n    default:\n      return null;\n  }\n}\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\n\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  var _data = img.bitmap.data;\n  var _width = img.bitmap.width;\n  var data = Buffer.alloc(_data.length);\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var _transformation = transformation(x, y),\n        _transformation2 = (0, _slicedToArray2[\"default\"])(_transformation, 2),\n        _x = _transformation2[0],\n        _y = _transformation2[1];\n      var idx = width * y + x << 2;\n      var _idx = _width * _y + _x << 2;\n      var pixel = _data.readUInt32BE(_idx);\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\n\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n  var transformation = getExifOrientationTransformation(img);\n  var swapDimensions = getExifOrientation(img) > 4;\n  var newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  var newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n  transformBitmap(img, newWidth, newHeight, transformation);\n} // parses a bitmap from the constructor to the JIMP bitmap property\n\nfunction parseBitmap(data, path, cb) {\n  var mime = getMIMEFromBuffer(data, path);\n  if (typeof mime !== 'string') {\n    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));\n  }\n  this._originalMime = mime.toLowerCase();\n  try {\n    var _mime = this.getMIME();\n    if (this.constructor.decoders[_mime]) {\n      this.bitmap = this.constructor.decoders[_mime](data);\n    } else {\n      return _utils.throwError.call(this, 'Unsupported MIME type: ' + _mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n  try {\n    this._exif = _exifParser[\"default\"].create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n  cb.call(this, null, this);\n  return this;\n}\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;\n}\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\n\nfunction getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n  if (typeof mime !== 'string') {\n    return _utils.throwError.call(this, 'mime must be a string', cb);\n  }\n  if (typeof cb !== 'function') {\n    return _utils.throwError.call(this, 'cb must be a function', cb);\n  }\n  mime = mime.toLowerCase();\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;\n  }\n  if (this.constructor.encoders[mime]) {\n    var buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, 'Unsupported MIME type: ' + mime);\n  }\n  return this;\n}\nfunction getBufferAsync(mime) {\n  return (0, _promisify[\"default\"])(getBuffer, this, mime);\n}","map":{"version":3,"mappings":"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","names":["getMIMEFromBuffer","buffer","path","fileTypeFromBuffer","mime","MIME","getType","getExifOrientation","img","_exif","tags","Orientation","getExifOrientationTransformation","w","getWidth","h","getHeight","x","y","transformBitmap","width","height","transformation","_data","bitmap","data","_width","Buffer","alloc","length","_transformation2","_x","_y","idx","_idx","pixel","readUInt32BE","writeUInt32BE","exifRotate","swapDimensions","newWidth","newHeight","parseBitmap","cb","Error","_originalMime","toLowerCase","getMIME","constructor","decoders","throwError","call","error","EXIFParser","create","parse","compositeBitmapOverBackground","Jimp","image","_background","composite","getBuffer","constants","AUTO","_rgba","hasAlpha","from","encoders","getBufferAsync"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\@jimp\\core\\src\\utils\\image-bitmap.js"],"sourcesContent":["import fileType from 'file-type';\n\nimport EXIFParser from 'exif-parser';\nimport { throwError } from '@jimp/utils';\n\nimport * as constants from '../constants';\nimport * as MIME from './mime';\nimport promisify from './promisify';\n\nfunction getMIMEFromBuffer(buffer, path) {\n  const fileTypeFromBuffer = fileType(buffer);\n\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n\n  return null;\n}\n\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\nfunction getExifOrientation(img) {\n  return (img._exif && img._exif.tags && img._exif.tags.Orientation) || 1;\n}\n\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\nfunction getExifOrientationTransformation(img) {\n  const w = img.getWidth();\n  const h = img.getHeight();\n\n  switch (getExifOrientation(img)) {\n    case 1: // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n\n    case 2: // Mirror horizontal\n      return function(x, y) {\n        return [w - x - 1, y];\n      };\n\n    case 3: // Rotate 180\n      return function(x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n\n    case 4: // Mirror vertical\n      return function(x, y) {\n        return [x, h - y - 1];\n      };\n\n    case 5: // Mirror horizontal and rotate 270 CW\n      return function(x, y) {\n        return [y, x];\n      };\n\n    case 6: // Rotate 90 CW\n      return function(x, y) {\n        return [y, h - x - 1];\n      };\n\n    case 7: // Mirror horizontal and rotate 90 CW\n      return function(x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n\n    case 8: // Rotate 270 CW\n      return function(x, y) {\n        return [w - y - 1, x];\n      };\n\n    default:\n      return null;\n  }\n}\n\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  const _data = img.bitmap.data;\n  const _width = img.bitmap.width;\n\n  const data = Buffer.alloc(_data.length);\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const [_x, _y] = transformation(x, y);\n\n      const idx = (width * y + x) << 2;\n      const _idx = (_width * _y + _x) << 2;\n\n      const pixel = _data.readUInt32BE(_idx);\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n\n  const transformation = getExifOrientationTransformation(img);\n  const swapDimensions = getExifOrientation(img) > 4;\n\n  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n\n  transformBitmap(img, newWidth, newHeight, transformation);\n}\n\n// parses a bitmap from the constructor to the JIMP bitmap property\nexport function parseBitmap(data, path, cb) {\n  const mime = getMIMEFromBuffer(data, path);\n\n  if (typeof mime !== 'string') {\n    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));\n  }\n\n  this._originalMime = mime.toLowerCase();\n\n  try {\n    const mime = this.getMIME();\n\n    if (this.constructor.decoders[mime]) {\n      this.bitmap = this.constructor.decoders[mime](data);\n    } else {\n      return throwError.call(this, 'Unsupported MIME type: ' + mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n\n  try {\n    this._exif = EXIFParser.create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n\n  cb.call(this, null, this);\n\n  return this;\n}\n\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(\n    image.bitmap.width,\n    image.bitmap.height,\n    image._background\n  ).composite(image, 0, 0).bitmap;\n}\n\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\nexport function getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n\n  if (typeof mime !== 'string') {\n    return throwError.call(this, 'mime must be a string', cb);\n  }\n\n  if (typeof cb !== 'function') {\n    return throwError.call(this, 'cb must be a function', cb);\n  }\n\n  mime = mime.toLowerCase();\n\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(\n      this.constructor,\n      this\n    ).data;\n  }\n\n  if (this.constructor.encoders[mime]) {\n    const buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, 'Unsupported MIME type: ' + mime);\n  }\n\n  return this;\n}\n\nexport function getBufferAsync(mime) {\n  return promisify(getBuffer, this, mime);\n}\n"]},"metadata":{},"sourceType":"script"}