{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.fs = void 0;\nrequire(\"source-map-support/register\");\nvar _fs2 = _interopRequireDefault(require(\"fs\"));\nvar _rimraf = _interopRequireDefault(require(\"rimraf\"));\nvar _ncp = _interopRequireDefault(require(\"ncp\"));\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _mv = _interopRequireDefault(require(\"mv\"));\nvar _which = _interopRequireDefault(require(\"which\"));\nvar _glob = _interopRequireDefault(require(\"glob\"));\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\nvar _klaw = _interopRequireDefault(require(\"klaw\"));\nvar _sanitizeFilename = _interopRequireDefault(require(\"sanitize-filename\"));\nvar _util = require(\"./util\");\nvar _logger = _interopRequireDefault(require(\"./logger\"));\nvar _timing = _interopRequireDefault(require(\"./timing\"));\nconst mkdirAsync = _bluebird.default.promisify(_fs2.default.mkdir);\nconst ncpAsync = _bluebird.default.promisify(_ncp.default);\nconst fs = {\n  async hasAccess(path) {\n    try {\n      await this.access(path, _fs2.default.R_OK);\n    } catch (err) {\n      return false;\n    }\n    return true;\n  },\n  exists(path) {\n    return this.hasAccess(path);\n  },\n  rimraf: _bluebird.default.promisify(_rimraf.default),\n  rimrafSync: _rimraf.default.sync.bind(_rimraf.default),\n  async mkdir() {\n    try {\n      return await mkdirAsync(...arguments);\n    } catch (err) {\n      if (err && err.code !== 'EEXIST') {\n        throw err;\n      }\n    }\n  },\n  async copyFile(source, destination) {\n    if (!(await this.hasAccess(source))) {\n      throw new Error(`The file at '${source}' does not exist or is not accessible`);\n    }\n    for (var _len = arguments.length, otherArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      otherArgs[_key - 2] = arguments[_key];\n    }\n    return await ncpAsync(source, destination, ...otherArgs);\n  },\n  async md5(filePath) {\n    return await this.hash(filePath, 'md5');\n  },\n  mv: _bluebird.default.promisify(_mv.default),\n  which: _bluebird.default.promisify(_which.default),\n  glob: _bluebird.default.promisify(_glob.default),\n  sanitizeName: _sanitizeFilename.default,\n  async hash(filePath) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sha1';\n    return await new _bluebird.default((resolve, reject) => {\n      const fileHash = _crypto.default.createHash(algorithm);\n      const readStream = _fs2.default.createReadStream(filePath);\n      readStream.on('error', e => reject(new Error(`Cannot calculate ${algorithm} hash for '${filePath}'. Original error: ${e.message}`)));\n      readStream.on('data', chunk => fileHash.update(chunk));\n      readStream.on('end', () => resolve(fileHash.digest('hex')));\n    });\n  },\n  async walkDir(dir, recursive, callback) {\n    let isValidRoot = false;\n    let errMsg = null;\n    try {\n      isValidRoot = (await fs.stat(dir)).isDirectory();\n    } catch (e) {\n      errMsg = e.message;\n    }\n    if (!isValidRoot) {\n      throw Error(`'${dir}' is not a valid root directory` + (errMsg ? `. Original error: ${errMsg}` : ''));\n    }\n    let walker;\n    let fileCount = 0;\n    let directoryCount = 0;\n    const timer = new _timing.default().start();\n    return await new _bluebird.default(function (resolve, reject) {\n      let lastFileProcessed = _bluebird.default.resolve();\n      walker = (0, _klaw.default)(dir, {\n        depthLimit: recursive ? -1 : 0\n      });\n      walker.on('data', function (item) {\n        walker.pause();\n        if (!item.stats.isDirectory()) {\n          fileCount++;\n        } else {\n          directoryCount++;\n        }\n        lastFileProcessed = _bluebird.default.try(async () => await callback(item.path, item.stats.isDirectory())).then(function () {\n          let done = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n          if (done) {\n            resolve(item.path);\n          } else {\n            walker.resume();\n          }\n        }).catch(reject);\n      }).on('error', function (err, item) {\n        _logger.default.warn(`Got an error while walking '${item.path}': ${err.message}`);\n        if (err.code === 'ENOENT') {\n          _logger.default.warn('All files may not have been accessed');\n          reject(err);\n        }\n      }).on('end', function () {\n        lastFileProcessed.then(resolve).catch(function (err) {\n          _logger.default.warn(`Unexpected error: ${err.message}`);\n          reject(err);\n        });\n      });\n    }).finally(function () {\n      _logger.default.debug(`Traversed ${(0, _util.pluralize)('directory', directoryCount, true)} ` + `and ${(0, _util.pluralize)('file', fileCount, true)} ` + `in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);\n      if (walker) {\n        walker.destroy();\n      }\n    });\n  }\n};\nexports.fs = fs;\nconst simples = ['open', 'close', 'access', 'readFile', 'writeFile', 'write', 'read', 'readlink', 'chmod', 'unlink', 'readdir', 'stat', 'rename', 'lstat', 'appendFile', 'realpath', 'symlink'];\nfor (const s of simples) {\n  fs[s] = _bluebird.default.promisify(_fs2.default[s]);\n}\nconst syncFunctions = ['createReadStream', 'createWriteStream'];\nfor (const s of syncFunctions) {\n  fs[s] = _fs2.default[s];\n}\nconst constants = ['F_OK', 'R_OK', 'W_OK', 'X_OK', 'constants'];\nfor (const c of constants) {\n  fs[c] = _fs2.default[c];\n}\nvar _default = fs;\nexports.default = _default;\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["mkdirAsync","B","promisify","_fs","mkdir","ncpAsync","ncp","fs","hasAccess","path","access","R_OK","err","exists","rimraf","rimrafSync","sync","bind","code","copyFile","source","destination","Error","otherArgs","md5","filePath","hash","mv","which","glob","sanitizeName","sanitize","algorithm","resolve","reject","fileHash","crypto","createHash","readStream","createReadStream","on","e","message","chunk","update","digest","walkDir","dir","recursive","callback","isValidRoot","errMsg","stat","isDirectory","walker","fileCount","directoryCount","timer","Timer","start","lastFileProcessed","depthLimit","item","pause","stats","try","then","done","resume","catch","log","warn","finally","debug","getDuration","asMilliSeconds","toFixed","destroy","simples","s","syncFunctions","constants","c"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\fs.js"],"sourcesContent":["// jshint ignore: start\nimport _fs from 'fs';\nimport rimraf from 'rimraf';\nimport ncp from 'ncp';\nimport B from 'bluebird';\nimport mv from 'mv';\nimport which from 'which';\nimport glob from 'glob';\nimport crypto from 'crypto';\nimport klaw from 'klaw';\nimport sanitize from 'sanitize-filename';\nimport { pluralize } from './util';\nimport log from './logger';\nimport Timer from './timing';\n\nconst mkdirAsync = B.promisify(_fs.mkdir);\nconst ncpAsync = B.promisify(ncp);\n\nconst fs = {\n  async hasAccess (path) {\n    try {\n      await this.access(path, _fs.R_OK);\n    } catch (err) {\n      return false;\n    }\n    return true;\n  },\n  exists (path) { return this.hasAccess(path); },\n  rimraf: B.promisify(rimraf),\n  rimrafSync: rimraf.sync.bind(rimraf),\n  async mkdir (...args) {\n    try {\n      return await mkdirAsync(...args);\n    } catch (err) {\n      if (err && err.code !== 'EEXIST') {\n        throw err;\n      }\n    }\n  },\n  async copyFile (source, destination, ...otherArgs) {\n    if (!await this.hasAccess(source)) {\n      throw new Error(`The file at '${source}' does not exist or is not accessible`);\n    }\n    return await ncpAsync(source, destination, ...otherArgs);\n  },\n  async md5 (filePath) {\n    return await this.hash(filePath, 'md5');\n  },\n  mv: B.promisify(mv),\n  which: B.promisify(which),\n  glob: B.promisify(glob),\n  sanitizeName: sanitize,\n  async hash (filePath, algorithm = 'sha1') {\n    return await new B((resolve, reject) => {\n      const fileHash = crypto.createHash(algorithm);\n      const readStream = _fs.createReadStream(filePath);\n      readStream.on('error', (e) => reject(\n        new Error(`Cannot calculate ${algorithm} hash for '${filePath}'. Original error: ${e.message}`)));\n      readStream.on('data', (chunk) => fileHash.update(chunk));\n      readStream.on('end', () => resolve(fileHash.digest('hex')));\n    });\n  },\n  /** The callback function which will be called during the directory walking\n   * @name WalkDirCallback\n   * @function\n   * @param {string} itemPath The path of the file or folder\n   * @param {boolean} isDirectory Shows if it is a directory or a file\n   * @return {boolean} return true if you want to stop walking\n  */\n\n  /**\n   * Walks a directory given according to the parameters given. The callback will be invoked with a path joined with the dir parameter\n   * @param {string} dir Directory path where we will start walking\n   * @param {boolean} recursive Set it to true if you want to continue walking sub directories\n   * @param {WalkDirCallback} callback The callback to be called when a new path is found\n   * @throws {Error} If the `dir` parameter contains a path to an invalid folder\n   * @return {?string} returns the found path or null if the item was not found\n   */\n  async walkDir (dir, recursive, callback) { //eslint-disable-line promise/prefer-await-to-callbacks\n    let isValidRoot = false;\n    let errMsg = null;\n    try {\n      isValidRoot = (await fs.stat(dir)).isDirectory();\n    } catch (e) {\n      errMsg = e.message;\n    }\n    if (!isValidRoot) {\n      throw Error(`'${dir}' is not a valid root directory` + (errMsg ? `. Original error: ${errMsg}` : ''));\n    }\n\n    let walker;\n    let fileCount = 0;\n    let directoryCount = 0;\n    const timer = new Timer().start();\n    return await new B(function (resolve, reject) {\n      let lastFileProcessed = B.resolve();\n      walker = klaw(dir, {\n        depthLimit: recursive ? -1 : 0,\n      });\n      walker.on('data', function (item) {\n        walker.pause();\n\n        if (!item.stats.isDirectory()) {\n          fileCount++;\n        } else {\n          directoryCount++;\n        }\n\n        // eslint-disable-next-line promise/prefer-await-to-callbacks\n        lastFileProcessed = B.try(async () => await callback(item.path, item.stats.isDirectory()))\n          .then(function (done = false) {\n            if (done) {\n              resolve(item.path);\n            } else {\n              walker.resume();\n            }\n          })\n          .catch(reject);\n      })\n      .on('error', function (err, item) {\n        log.warn(`Got an error while walking '${item.path}': ${err.message}`);\n        // klaw cannot get back from an ENOENT error\n        if (err.code === 'ENOENT') {\n          log.warn('All files may not have been accessed');\n          reject(err);\n        }\n      })\n      .on('end', function () {\n        lastFileProcessed\n          .then(resolve)\n          .catch(function (err) {\n            log.warn(`Unexpected error: ${err.message}`);\n            reject(err);\n          });\n      });\n    }).finally(function () {\n      log.debug(`Traversed ${pluralize('directory', directoryCount, true)} ` +\n        `and ${pluralize('file', fileCount, true)} ` +\n        `in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);\n      if (walker) {\n        walker.destroy();\n      }\n    });\n  }\n};\n\n// add the supported `fs` functions\nconst simples = [\n  'open', 'close', 'access', 'readFile', 'writeFile', 'write', 'read',\n  'readlink', 'chmod', 'unlink', 'readdir', 'stat', 'rename', 'lstat',\n  'appendFile', 'realpath', 'symlink',\n];\nfor (const s of simples) {\n  fs[s] = B.promisify(_fs[s]);\n}\n\nconst syncFunctions = [\n  'createReadStream',\n  'createWriteStream',\n];\nfor (const s of syncFunctions) {\n  fs[s] = _fs[s];\n}\n\n// add the constants from `fs`\nconst constants = [\n  'F_OK', 'R_OK', 'W_OK', 'X_OK', 'constants',\n];\nfor (const c of constants) {\n  fs[c] = _fs[c];\n}\n\nexport { fs };\nexport default fs;\n"]},"metadata":{},"sourceType":"script"}