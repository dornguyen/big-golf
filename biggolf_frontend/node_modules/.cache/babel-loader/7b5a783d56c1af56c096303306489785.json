{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cropBase64Image = cropBase64Image;\nexports.base64ToImage = base64ToImage;\nexports.imageToBase64 = imageToBase64;\nexports.cropImage = cropImage;\nexports.getImagesMatches = getImagesMatches;\nexports.getImagesSimilarity = getImagesSimilarity;\nexports.getImageOccurrence = getImageOccurrence;\nexports.getJimpImage = getJimpImage;\nexports.MIME_BMP = exports.MIME_PNG = exports.MIME_JPEG = void 0;\nrequire(\"source-map-support/register\");\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _jimp = _interopRequireDefault(require(\"jimp\"));\nvar _buffer = require(\"buffer\");\nvar _pngjs = require(\"pngjs\");\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _util = require(\"./util\");\nvar _logger = _interopRequireDefault(require(\"./logger\"));\nvar _node = require(\"./node\");\nconst {\n  MIME_JPEG,\n  MIME_PNG,\n  MIME_BMP\n} = _jimp.default;\nexports.MIME_BMP = MIME_BMP;\nexports.MIME_PNG = MIME_PNG;\nexports.MIME_JPEG = MIME_JPEG;\nlet cv = null;\nconst BYTES_IN_PIXEL_BLOCK = 4;\nconst SCANLINE_FILTER_METHOD = 4;\nconst DEFAULT_MATCH_THRESHOLD = 0.5;\nconst MATCH_NEIGHBOUR_THRESHOLD = 10;\nconst AVAILABLE_DETECTORS = ['AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB'];\nconst AVAILABLE_MATCHING_FUNCTIONS = ['FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2'];\nconst MATCHING_METHODS = ['TM_CCOEFF', 'TM_CCOEFF_NORMED', 'TM_CCORR', 'TM_CCORR_NORMED', 'TM_SQDIFF', 'TM_SQDIFF_NORMED'];\nconst DEFAULT_MATCHING_METHOD = 'TM_CCOEFF_NORMED';\nfunction toMatchingMethod(name) {\n  if (!MATCHING_METHODS.includes(name)) {\n    throw new Error(`The matching method '${name}' is unknown. ` + `Only the following matching methods are supported: ${MATCHING_METHODS}`);\n  }\n  return cv[name];\n}\nasync function getJimpImage(data) {\n  return await new _bluebird.default((resolve, reject) => {\n    if (!_lodash.default.isString(data) && !_lodash.default.isBuffer(data)) {\n      return reject(new Error('Must initialize jimp object with string or buffer'));\n    }\n    if (_lodash.default.isString(data)) {\n      data = _buffer.Buffer.from(data, 'base64');\n    }\n    new _jimp.default(data, (err, imgObj) => {\n      if (err) {\n        return reject(err);\n      }\n      if (!imgObj) {\n        return reject(new Error('Could not create jimp image from that data'));\n      }\n      imgObj._getBuffer = imgObj.getBuffer.bind(imgObj);\n      imgObj.getBuffer = _bluebird.default.promisify(imgObj._getBuffer, {\n        context: imgObj\n      });\n      resolve(imgObj);\n    });\n  });\n}\nasync function initOpenCV() {\n  if (cv) {\n    return;\n  }\n  _logger.default.debug(`Initializing opencv`);\n  try {\n    cv = await (0, _node.requirePackage)('opencv4nodejs');\n  } catch (err) {\n    _logger.default.warn(`Unable to load 'opencv4nodejs': ${err.message}`);\n  }\n  if (!cv) {\n    throw new Error(`'opencv4nodejs' module is required to use OpenCV features. ` + `Please install it first ('npm i -g opencv4nodejs') and restart Appium. ` + 'Read https://github.com/justadudewhohacks/opencv4nodejs#how-to-install for more details on this topic.');\n  }\n}\nasync function detectAndCompute(img, detector) {\n  const keyPoints = await detector.detectAsync(img);\n  const descriptor = await detector.computeAsync(img, keyPoints);\n  return {\n    keyPoints,\n    descriptor\n  };\n}\nfunction calculateMatchedRect(matchedPoints) {\n  if (matchedPoints.length < 2) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  const pointsSortedByDistance = matchedPoints.map(point => [Math.sqrt(point.x * point.x + point.y * point.y), point]).sort((pair1, pair2) => pair1[0] >= pair2[0]).map(pair => pair[1]);\n  const firstPoint = _lodash.default.head(pointsSortedByDistance);\n  const lastPoint = _lodash.default.last(pointsSortedByDistance);\n  const topLeftPoint = {\n    x: firstPoint.x <= lastPoint.x ? firstPoint.x : lastPoint.x,\n    y: firstPoint.y <= lastPoint.y ? firstPoint.y : lastPoint.y\n  };\n  const bottomRightPoint = {\n    x: firstPoint.x >= lastPoint.x ? firstPoint.x : lastPoint.x,\n    y: firstPoint.y >= lastPoint.y ? firstPoint.y : lastPoint.y\n  };\n  return {\n    x: topLeftPoint.x,\n    y: topLeftPoint.y,\n    width: bottomRightPoint.x - topLeftPoint.x,\n    height: bottomRightPoint.y - topLeftPoint.y\n  };\n}\nfunction highlightRegion(mat, region) {\n  if (region.width <= 0 || region.height <= 0) {\n    return;\n  }\n  const color = new cv.Vec(0, 0, 255);\n  const thickness = 2;\n  mat.drawRectangle(new cv.Rect(region.x, region.y, region.width, region.height), color, thickness, cv.LINE_8);\n  return mat;\n}\nasync function getImagesMatches(img1Data, img2Data) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  await initOpenCV();\n  const {\n    detectorName = 'ORB',\n    visualize = false,\n    goodMatchesFactor,\n    matchFunc = 'BruteForce'\n  } = options;\n  if (!_lodash.default.includes(AVAILABLE_DETECTORS, detectorName)) {\n    throw new Error(`'${detectorName}' detector is unknown. ` + `Only ${JSON.stringify(AVAILABLE_DETECTORS)} detectors are supported.`);\n  }\n  if (!_lodash.default.includes(AVAILABLE_MATCHING_FUNCTIONS, matchFunc)) {\n    throw new Error(`'${matchFunc}' matching function is unknown. ` + `Only ${JSON.stringify(AVAILABLE_MATCHING_FUNCTIONS)} matching functions are supported.`);\n  }\n  const detector = new cv[`${detectorName}Detector`]();\n  const [img1, img2] = await _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]);\n  const [result1, result2] = await _bluebird.default.all([detectAndCompute(img1, detector), detectAndCompute(img2, detector)]);\n  let matches = [];\n  try {\n    matches = await cv[`match${matchFunc}Async`](result1.descriptor, result2.descriptor);\n  } catch (e) {\n    throw new Error(`Cannot find any matches between the given images. Try another detection algorithm. ` + ` Original error: ${e}`);\n  }\n  const totalCount = matches.length;\n  if ((0, _util.hasValue)(goodMatchesFactor)) {\n    if (_lodash.default.isFunction(goodMatchesFactor)) {\n      const distances = matches.map(match => match.distance);\n      const minDistance = _lodash.default.min(distances);\n      const maxDistance = _lodash.default.max(distances);\n      matches = matches.filter(match => goodMatchesFactor(match.distance, minDistance, maxDistance));\n    } else {\n      if (matches.length > goodMatchesFactor) {\n        matches = matches.sort((match1, match2) => match1.distance - match2.distance).slice(0, goodMatchesFactor);\n      }\n    }\n  }\n  const extractPoint = (keyPoints, indexPropertyName) => match => {\n    const {\n      pt,\n      point\n    } = keyPoints[match[indexPropertyName]];\n    return pt || point;\n  };\n  const points1 = matches.map(extractPoint(result1.keyPoints, 'queryIdx'));\n  const rect1 = calculateMatchedRect(points1);\n  const points2 = matches.map(extractPoint(result2.keyPoints, 'trainIdx'));\n  const rect2 = calculateMatchedRect(points2);\n  const result = {\n    points1,\n    rect1,\n    points2,\n    rect2,\n    totalCount,\n    count: matches.length\n  };\n  if (visualize) {\n    const visualization = cv.drawMatches(img1, img2, result1.keyPoints, result2.keyPoints, matches);\n    highlightRegion(visualization, rect1);\n    highlightRegion(visualization, {\n      x: img1.cols + rect2.x,\n      y: rect2.y,\n      width: rect2.width,\n      height: rect2.height\n    });\n    result.visualization = await cv.imencodeAsync('.png', visualization);\n  }\n  return result;\n}\nasync function getImagesSimilarity(img1Data, img2Data) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  await initOpenCV();\n  const {\n    method = DEFAULT_MATCHING_METHOD,\n    visualize = false\n  } = options;\n  let [template, reference] = await _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]);\n  if (template.rows !== reference.rows || template.cols !== reference.cols) {\n    throw new Error('Both images are expected to have the same size in order to ' + 'calculate the similarity score.');\n  }\n  [template, reference] = await _bluebird.default.all([template.convertToAsync(cv.CV_8UC3), reference.convertToAsync(cv.CV_8UC3)]);\n  let matched;\n  try {\n    matched = await reference.matchTemplateAsync(template, toMatchingMethod(method));\n  } catch (e) {\n    throw new Error(`The reference image did not match to the template one. Original error: ${e.message}`);\n  }\n  const minMax = await matched.minMaxLocAsync();\n  const result = {\n    score: minMax.maxVal\n  };\n  if (visualize) {\n    const resultMat = new cv.Mat(template.rows, template.cols * 2, cv.CV_8UC3);\n    await _bluebird.default.all([reference.copyToAsync(resultMat.getRegion(new cv.Rect(0, 0, reference.cols, reference.rows))), template.copyToAsync(resultMat.getRegion(new cv.Rect(reference.cols, 0, template.cols, template.rows)))]);\n    let mask = reference.absdiff(template);\n    mask = await mask.cvtColorAsync(cv.COLOR_BGR2GRAY);\n    let contours = [];\n    try {\n      mask = await mask.thresholdAsync(128, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);\n      contours = await mask.findContoursAsync(cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);\n    } catch (ign) {}\n    for (const contour of contours) {\n      const boundingRect = contour.boundingRect();\n      highlightRegion(resultMat, boundingRect);\n      highlightRegion(resultMat, {\n        x: reference.cols + boundingRect.x,\n        y: boundingRect.y,\n        width: boundingRect.width,\n        height: boundingRect.height\n      });\n    }\n    result.visualization = await cv.imencodeAsync('.png', resultMat);\n  }\n  return result;\n}\nasync function getImageOccurrence(fullImgData, partialImgData) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  await initOpenCV();\n  const {\n    visualize = false,\n    threshold = DEFAULT_MATCH_THRESHOLD,\n    multiple = false,\n    matchNeighbourThreshold = MATCH_NEIGHBOUR_THRESHOLD,\n    method = DEFAULT_MATCHING_METHOD\n  } = options;\n  const [fullImg, partialImg] = await _bluebird.default.all([cv.imdecodeAsync(fullImgData), cv.imdecodeAsync(partialImgData)]);\n  const results = [];\n  let visualization = null;\n  try {\n    const matched = await fullImg.matchTemplateAsync(partialImg, toMatchingMethod(method));\n    const minMax = await matched.minMaxLocAsync();\n    if (multiple) {\n      const nonZeroMatchResults = matched.threshold(threshold, 1, cv.THRESH_BINARY).convertTo(cv.CV_8U).findNonZero();\n      const matches = filterNearMatches(nonZeroMatchResults, matchNeighbourThreshold);\n      for (const {\n        x,\n        y\n      } of matches) {\n        results.push({\n          score: matched.at(y, x),\n          rect: {\n            x,\n            y,\n            width: partialImg.cols,\n            height: partialImg.rows\n          }\n        });\n      }\n    } else if (minMax.maxVal >= threshold) {\n      const {\n        x,\n        y\n      } = method.includes('SQDIFF') ? minMax.minLoc : minMax.maxLoc;\n      results.push({\n        score: minMax.maxVal,\n        rect: {\n          x,\n          y,\n          width: partialImg.cols,\n          height: partialImg.rows\n        }\n      });\n    }\n    if (_lodash.default.isEmpty(results)) {\n      throw new Error(`Match threshold: ${threshold}. Highest match value ` + `found was ${minMax.maxVal}`);\n    }\n  } catch (e) {\n    throw new Error(`Cannot find any occurrences of the partial image in the full image. ` + `Original error: ${e.message}`);\n  }\n  if (visualize) {\n    const fullHighlightedImage = fullImg.copy();\n    for (const result of results) {\n      const singleHighlightedImage = fullImg.copy();\n      highlightRegion(singleHighlightedImage, result.rect);\n      highlightRegion(fullHighlightedImage, result.rect);\n      result.visualization = await cv.imencodeAsync('.png', singleHighlightedImage);\n    }\n    visualization = await cv.imencodeAsync('.png', fullHighlightedImage);\n  }\n  return {\n    rect: results[0].rect,\n    score: results[0].score,\n    visualization,\n    multiple: results\n  };\n}\nfunction filterNearMatches(nonZeroMatchResults, matchNeighbourThreshold) {\n  return nonZeroMatchResults.reduce((acc, element) => {\n    if (!acc.some(match => distance(match, element) <= matchNeighbourThreshold)) {\n      acc.push(element);\n    }\n    return acc;\n  }, []);\n}\nfunction distance(point1, point2) {\n  const a2 = Math.pow(point1.x - point2.x, 2);\n  const b2 = Math.pow(point1.y - point2.y, 2);\n  return Math.sqrt(a2 + b2);\n}\nasync function cropBase64Image(base64Image, rect) {\n  const image = await base64ToImage(base64Image);\n  cropImage(image, rect);\n  return await imageToBase64(image);\n}\nasync function base64ToImage(base64Image) {\n  const imageBuffer = _buffer.Buffer.from(base64Image, 'base64');\n  return await new _bluebird.default((resolve, reject) => {\n    const image = new _pngjs.PNG({\n      filterType: SCANLINE_FILTER_METHOD\n    });\n    image.parse(imageBuffer, (err, image) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(image);\n    });\n  });\n}\nasync function imageToBase64(image) {\n  return await new _bluebird.default((resolve, reject) => {\n    const chunks = [];\n    image.pack().on('data', chunk => chunks.push(chunk)).on('end', () => {\n      resolve(_buffer.Buffer.concat(chunks).toString('base64'));\n    }).on('error', err => {\n      reject(err);\n    });\n  });\n}\nfunction cropImage(image, rect) {\n  const imageRect = {\n    width: image.width,\n    height: image.height\n  };\n  const interRect = getRectIntersection(rect, imageRect);\n  if (interRect.width < rect.width || interRect.height < rect.height) {\n    throw new Error(`Cannot crop ${JSON.stringify(rect)} from ${JSON.stringify(imageRect)} because the intersection between them was not the size of the rect`);\n  }\n  const firstVerticalPixel = interRect.top;\n  const lastVerticalPixel = interRect.top + interRect.height;\n  const firstHorizontalPixel = interRect.left;\n  const lastHorizontalPixel = interRect.left + interRect.width;\n  const croppedArray = [];\n  for (let y = firstVerticalPixel; y < lastVerticalPixel; y++) {\n    for (let x = firstHorizontalPixel; x < lastHorizontalPixel; x++) {\n      const firstByteIdxInPixelBlock = imageRect.width * y + x << 2;\n      for (let byteIdx = 0; byteIdx < BYTES_IN_PIXEL_BLOCK; byteIdx++) {\n        croppedArray.push(image.data[firstByteIdxInPixelBlock + byteIdx]);\n      }\n    }\n  }\n  image.data = _buffer.Buffer.from(croppedArray);\n  image.width = interRect.width;\n  image.height = interRect.height;\n  return image;\n}\nfunction getRectIntersection(rect, imageSize) {\n  const left = rect.left >= imageSize.width ? imageSize.width : rect.left;\n  const top = rect.top >= imageSize.height ? imageSize.height : rect.top;\n  const width = imageSize.width >= left + rect.width ? rect.width : imageSize.width - left;\n  const height = imageSize.height >= top + rect.height ? rect.height : imageSize.height - top;\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n}\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["MIME_JPEG","MIME_PNG","MIME_BMP","Jimp","cv","BYTES_IN_PIXEL_BLOCK","SCANLINE_FILTER_METHOD","DEFAULT_MATCH_THRESHOLD","MATCH_NEIGHBOUR_THRESHOLD","AVAILABLE_DETECTORS","AVAILABLE_MATCHING_FUNCTIONS","MATCHING_METHODS","DEFAULT_MATCHING_METHOD","toMatchingMethod","name","includes","Error","getJimpImage","data","B","resolve","reject","_","isString","isBuffer","Buffer","from","err","imgObj","_getBuffer","getBuffer","bind","promisify","context","initOpenCV","log","debug","warn","message","detectAndCompute","img","detector","keyPoints","detectAsync","descriptor","computeAsync","calculateMatchedRect","matchedPoints","length","x","y","width","height","pointsSortedByDistance","map","point","Math","sqrt","sort","pair1","pair2","pair","firstPoint","head","lastPoint","last","topLeftPoint","bottomRightPoint","highlightRegion","mat","region","color","Vec","thickness","drawRectangle","Rect","LINE_8","getImagesMatches","img1Data","img2Data","options","detectorName","visualize","goodMatchesFactor","matchFunc","JSON","stringify","img1","img2","all","imdecodeAsync","result1","result2","matches","e","totalCount","isFunction","distances","match","distance","minDistance","min","maxDistance","max","filter","match1","match2","slice","extractPoint","indexPropertyName","pt","points1","rect1","points2","rect2","result","count","visualization","drawMatches","cols","imencodeAsync","getImagesSimilarity","method","template","reference","rows","convertToAsync","CV_8UC3","matched","matchTemplateAsync","minMax","minMaxLocAsync","score","maxVal","resultMat","Mat","copyToAsync","getRegion","mask","absdiff","cvtColorAsync","COLOR_BGR2GRAY","contours","thresholdAsync","THRESH_BINARY","THRESH_OTSU","findContoursAsync","RETR_EXTERNAL","CHAIN_APPROX_SIMPLE","ign","contour","boundingRect","getImageOccurrence","fullImgData","partialImgData","threshold","multiple","matchNeighbourThreshold","fullImg","partialImg","results","nonZeroMatchResults","convertTo","CV_8U","findNonZero","filterNearMatches","push","at","rect","minLoc","maxLoc","isEmpty","fullHighlightedImage","copy","singleHighlightedImage","reduce","acc","element","some","point1","point2","a2","pow","b2","cropBase64Image","base64Image","image","base64ToImage","cropImage","imageToBase64","imageBuffer","PNG","filterType","parse","chunks","pack","on","chunk","concat","toString","imageRect","interRect","getRectIntersection","firstVerticalPixel","top","lastVerticalPixel","firstHorizontalPixel","left","lastHorizontalPixel","croppedArray","firstByteIdxInPixelBlock","byteIdx","imageSize","require"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\image-util.js"],"sourcesContent":["import _ from 'lodash';\nimport Jimp from 'jimp';\nimport { Buffer } from 'buffer';\nimport { PNG } from 'pngjs';\nimport B from 'bluebird';\nimport { hasValue } from './util';\nimport log from './logger';\nimport { requirePackage } from './node';\n\n\nconst { MIME_JPEG, MIME_PNG, MIME_BMP } = Jimp;\nlet cv = null;\n\n/**\n * @typedef {Object} Region\n * @property {number} left - The offset from the left side\n * @property {number} top - The offset from the top\n * @property {number} width - The width\n * @property {number} height - The height\n */\n\n/**\n * @typedef {Object} Point\n * @property {number} x - The x coordinate\n * @property {number} y - The y coordinate\n */\n\n/**\n * @typedef {Object} Rect\n * @property {number} x - The top left coordinate\n * @property {number} y - The bottom right coordinate\n * @property {number} width - The width\n * @property {number} height - The height\n */\n\nconst BYTES_IN_PIXEL_BLOCK = 4;\nconst SCANLINE_FILTER_METHOD = 4;\nconst DEFAULT_MATCH_THRESHOLD = 0.5;\nconst MATCH_NEIGHBOUR_THRESHOLD = 10;\n\nconst AVAILABLE_DETECTORS = [\n  'AKAZE',\n  'AGAST',\n  'BRISK',\n  'FAST',\n  'GFTT',\n  'KAZE',\n  'MSER',\n  'SIFT',\n  'ORB',\n];\n\nconst AVAILABLE_MATCHING_FUNCTIONS = [\n  'FlannBased',\n  'BruteForce',\n  'BruteForceL1',\n  'BruteForceHamming',\n  'BruteForceHammingLut',\n  'BruteForceSL2',\n];\n\nconst MATCHING_METHODS = [\n  'TM_CCOEFF',\n  'TM_CCOEFF_NORMED',\n  'TM_CCORR',\n  'TM_CCORR_NORMED',\n  'TM_SQDIFF',\n  'TM_SQDIFF_NORMED',\n];\nconst DEFAULT_MATCHING_METHOD = 'TM_CCOEFF_NORMED';\n\n/**\n * Transforms matching method name to the actual\n * constant value from OpenCV library\n *\n * @param {string} name One of supported method names\n * (see MATCHING_METHODS array above)\n * @returns {number} The method value\n * @throws {Error} if an unsupported method name is given\n */\nfunction toMatchingMethod (name) {\n  if (!MATCHING_METHODS.includes(name)) {\n    throw new Error(`The matching method '${name}' is unknown. ` +\n      `Only the following matching methods are supported: ${MATCHING_METHODS}`);\n  }\n  return cv[name];\n}\n\n/**\n * Utility function to get a Jimp image object from buffer or base64 data. Jimp\n * is a great library however it does IO in the constructor so it's not\n * convenient for our async/await model.\n *\n * @param {Buffer|string} data - binary image buffer or base64-encoded image\n * string\n * @returns {Jimp} - the jimp image object\n */\nasync function getJimpImage (data) {\n  return await new B((resolve, reject) => {\n    if (!_.isString(data) && !_.isBuffer(data)) {\n      return reject(new Error('Must initialize jimp object with string or buffer'));\n    }\n    // if data is a string, assume it is a base64-encoded image\n    if (_.isString(data)) {\n      data = Buffer.from(data, 'base64');\n    }\n    new Jimp(data, (err, imgObj) => {\n      if (err) {\n        return reject(err);\n      }\n      if (!imgObj) {\n        return reject(new Error('Could not create jimp image from that data'));\n      }\n      imgObj._getBuffer = imgObj.getBuffer.bind(imgObj);\n      imgObj.getBuffer = B.promisify(imgObj._getBuffer, {context: imgObj});\n      resolve(imgObj);\n    });\n  });\n}\n\n/**\n * @throws {Error} If opencv4nodejs module is not installed or cannot be loaded\n */\nasync function initOpenCV () {\n  if (cv) {\n    return;\n  }\n\n  log.debug(`Initializing opencv`);\n  try {\n    cv = await requirePackage('opencv4nodejs');\n  } catch (err) {\n    log.warn(`Unable to load 'opencv4nodejs': ${err.message}`);\n  }\n\n  if (!cv) {\n    throw new Error(`'opencv4nodejs' module is required to use OpenCV features. ` +\n                    `Please install it first ('npm i -g opencv4nodejs') and restart Appium. ` +\n                    'Read https://github.com/justadudewhohacks/opencv4nodejs#how-to-install for more details on this topic.');\n  }\n}\n\n/**\n * @typedef {Object} MatchComputationResult\n * @property {cv.DescriptorMatch} desciptor - OpenCV match descriptor\n * @property {Array<cv.KeyPoint>} keyPoints - The array of key points\n */\n\n/**\n * Calculates an OpenCV match descriptor of an image, which can be used\n * for brute-force matching.\n * Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html\n * for more details.\n *\n * @param {cv.Mat} img Image data\n * @param {cv.FeatureDetector} detector OpenCV feature detector instance\n *\n * @returns {MatchComputationResult}\n */\nasync function detectAndCompute (img, detector) {\n  const keyPoints = await detector.detectAsync(img);\n  const descriptor = await detector.computeAsync(img, keyPoints);\n  return {\n    keyPoints,\n    descriptor\n  };\n}\n\n/**\n * Calculated the bounding rect coordinates for the array of matching points\n *\n * @param {Array<Point>} matchedPoints Array of matching points\n * @returns {Rect} The matching bounding rect or a zero rect if no match\n * can be found.\n */\nfunction calculateMatchedRect (matchedPoints) {\n  if (matchedPoints.length < 2) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n\n  const pointsSortedByDistance = matchedPoints\n    .map((point) => [Math.sqrt(point.x * point.x + point.y * point.y), point])\n    .sort((pair1, pair2) => pair1[0] >= pair2[0])\n    .map((pair) => pair[1]);\n  const firstPoint = _.head(pointsSortedByDistance);\n  const lastPoint = _.last(pointsSortedByDistance);\n  const topLeftPoint = {\n    x: firstPoint.x <= lastPoint.x ? firstPoint.x : lastPoint.x,\n    y: firstPoint.y <= lastPoint.y ? firstPoint.y : lastPoint.y,\n  };\n  const bottomRightPoint = {\n    x: firstPoint.x >= lastPoint.x ? firstPoint.x : lastPoint.x,\n    y: firstPoint.y >= lastPoint.y ? firstPoint.y : lastPoint.y,\n  };\n  return {\n    x: topLeftPoint.x,\n    y: topLeftPoint.y,\n    width: bottomRightPoint.x - topLeftPoint.x,\n    height: bottomRightPoint.y - topLeftPoint.y\n  };\n}\n\n/**\n * Draws a rectanngle on the given image matrix\n *\n * @param {cv.Mat} mat The source image\n * @param {Rect} region The region to highlight\n *\n * @returns {cv.Mat} The same image with the rectangle on it\n */\nfunction highlightRegion (mat, region) {\n  if (region.width <= 0 || region.height <= 0) {\n    return;\n  }\n\n  // highlight in red\n  const color = new cv.Vec(0, 0, 255);\n  const thickness = 2;\n  mat.drawRectangle(new cv.Rect(region.x, region.y, region.width, region.height), color, thickness, cv.LINE_8);\n  return mat;\n}\n\n/**\n * @typedef {Object} MatchingOptions\n * @property {?string} detectorName ['ORB'] One of possible OpenCV feature detector names\n * from `AVAILABLE_DETECTORS` array.\n * Some of these methods (FAST, AGAST, GFTT, FAST, SIFT and MSER) are not available\n * in the default OpenCV installation and have to be enabled manually before\n * library compilation.\n * @property {?string} matchFunc ['BruteForce'] The name of the matching function.\n * Should be one of `AVAILABLE_MATCHING_FUNCTIONS` array.\n * @property {?number|Function} goodMatchesFactor The maximum count of \"good\" matches\n * (e. g. with minimal distances) or a function, which accepts 3 arguments: the current distance,\n * minimal distance, maximum distance and returns true or false to include or exclude the match.\n * @property {?boolean} visualize [false] Whether to return the resulting visalization\n * as an image (useful for debugging purposes)\n */\n\n/**\n * @typedef {Object} MatchingResult\n * @property {number} count The count of matched edges on both images.\n * The more matching edges there are no both images the more similar they are.\n * @property {number} totalCount The total count of matched edges on both images.\n * It is equal to `count` if `goodMatchesFactor` does not limit the matches,\n * otherwise it contains the total count of matches before `goodMatchesFactor` is\n * applied.\n * @property {?Buffer} visualization The visualization of the matching result\n * represented as PNG image buffer. This visualization looks like\n * https://user-images.githubusercontent.com/31125521/29702731-c79e3142-8972-11e7-947e-db109d415469.jpg\n * @property {Array<Point>} points1 The array of matching points on the first image\n * @property {Rect} rect1 The bounding rect for the `matchedPoints1` set or a zero rect\n * if not enough matching points are found\n * @property {Array<Point>} points2 The array of matching points on the second image\n * @property {Rect} rect2 The bounding rect for the `matchedPoints2` set or a zero rect\n * if not enough matching points are found\n */\n\n/**\n * Calculates the count of common edges between two images.\n * The images might be rotated or resized relatively to each other.\n *\n * @param {Buffer} img1Data The data of the first image packed into a NodeJS buffer\n * @param {Buffer} img2Data The data of the second image packed into a NodeJS buffer\n * @param {?MatchingOptions} options [{}] Set of matching options\n *\n * @returns {MatchingResult} Maching result\n * @throws {Error} If `detectorName` value is unknown.\n */\nasync function getImagesMatches (img1Data, img2Data, options = {}) {\n  await initOpenCV();\n\n  const {detectorName = 'ORB', visualize = false,\n         goodMatchesFactor, matchFunc = 'BruteForce'} = options;\n  if (!_.includes(AVAILABLE_DETECTORS, detectorName)) {\n    throw new Error(`'${detectorName}' detector is unknown. ` +\n                    `Only ${JSON.stringify(AVAILABLE_DETECTORS)} detectors are supported.`);\n  }\n  if (!_.includes(AVAILABLE_MATCHING_FUNCTIONS, matchFunc)) {\n    throw new Error(`'${matchFunc}' matching function is unknown. ` +\n                    `Only ${JSON.stringify(AVAILABLE_MATCHING_FUNCTIONS)} matching functions are supported.`);\n  }\n\n  const detector = new cv[`${detectorName}Detector`]();\n  const [img1, img2] = await B.all([\n    cv.imdecodeAsync(img1Data),\n    cv.imdecodeAsync(img2Data)\n  ]);\n  const [result1, result2] = await B.all([\n    detectAndCompute(img1, detector),\n    detectAndCompute(img2, detector)\n  ]);\n  let matches = [];\n  try {\n    matches = await cv[`match${matchFunc}Async`](result1.descriptor, result2.descriptor);\n  } catch (e) {\n    throw new Error(`Cannot find any matches between the given images. Try another detection algorithm. ` +\n                    ` Original error: ${e}`);\n  }\n  const totalCount = matches.length;\n  if (hasValue(goodMatchesFactor)) {\n    if (_.isFunction(goodMatchesFactor)) {\n      const distances = matches.map((match) => match.distance);\n      const minDistance = _.min(distances);\n      const maxDistance = _.max(distances);\n      matches = matches\n        .filter((match) => goodMatchesFactor(match.distance, minDistance, maxDistance));\n    } else {\n      if (matches.length > goodMatchesFactor) {\n        matches = matches\n          .sort((match1, match2) => match1.distance - match2.distance)\n          .slice(0, goodMatchesFactor);\n      }\n    }\n  }\n\n  const extractPoint = (keyPoints, indexPropertyName) => (match) => {\n    const {pt, point} = keyPoints[match[indexPropertyName]];\n    // https://github.com/justadudewhohacks/opencv4nodejs/issues/584\n    return (pt || point);\n  };\n  const points1 = matches.map(extractPoint(result1.keyPoints, 'queryIdx'));\n  const rect1 = calculateMatchedRect(points1);\n  const points2 = matches.map(extractPoint(result2.keyPoints, 'trainIdx'));\n  const rect2 = calculateMatchedRect(points2);\n\n  const result = {\n    points1,\n    rect1,\n    points2,\n    rect2,\n    totalCount,\n    count: matches.length,\n  };\n  if (visualize) {\n    const visualization = cv.drawMatches(img1, img2, result1.keyPoints, result2.keyPoints, matches);\n    highlightRegion(visualization, rect1);\n    highlightRegion(visualization, {\n      x: img1.cols + rect2.x,\n      y: rect2.y,\n      width: rect2.width,\n      height: rect2.height\n    });\n    result.visualization = await cv.imencodeAsync('.png', visualization);\n  }\n  return result;\n}\n\n/**\n * @typedef {Object} SimilarityOptions\n * @property {?boolean} visualize [false] Whether to return the resulting visalization\n * as an image (useful for debugging purposes)\n * @property {string} method [TM_CCOEFF_NORMED] The name of the template matching method.\n * Acceptable values are:\n * - TM_CCOEFF\n * - TM_CCOEFF_NORMED (default)\n * - TM_CCORR\n * - TM_CCORR_NORMED\n * - TM_SQDIFF\n * - TM_SQDIFF_NORMED\n * Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html\n * for more details.\n */\n\n/**\n * @typedef {Object} SimilarityResult\n * @property {number} score The similarity score as a float number in range [0.0, 1.0].\n * 1.0 is the highest score (means both images are totally equal).\n * @property {?Buffer} visualization The visualization of the matching result\n * represented as PNG image buffer. This image includes both input pictures where\n * difference regions are highlighted with rectangles.\n */\n\n/**\n * Calculates the similarity score between two images.\n * It is expected, that both images have the same resolution.\n *\n * @param {Buffer} img1Data The data of the first image packed into a NodeJS buffer\n * @param {Buffer} img2Data The data of the second image packed into a NodeJS buffer\n * @param {?SimilarityOptions} options [{}] Set of similarity calculation options\n *\n * @returns {SimilarityResult} The calculation result\n * @throws {Error} If the given images have different resolution.\n */\nasync function getImagesSimilarity (img1Data, img2Data, options = {}) {\n  await initOpenCV();\n\n  const {\n    method = DEFAULT_MATCHING_METHOD,\n    visualize = false,\n  } = options;\n  let [template, reference] = await B.all([\n    cv.imdecodeAsync(img1Data),\n    cv.imdecodeAsync(img2Data)\n  ]);\n  if (template.rows !== reference.rows || template.cols !== reference.cols) {\n    throw new Error('Both images are expected to have the same size in order to ' +\n                    'calculate the similarity score.');\n  }\n  [template, reference] = await B.all([\n    template.convertToAsync(cv.CV_8UC3),\n    reference.convertToAsync(cv.CV_8UC3)\n  ]);\n\n  let matched;\n  try {\n    matched = await reference.matchTemplateAsync(template, toMatchingMethod(method));\n  } catch (e) {\n    throw new Error(`The reference image did not match to the template one. Original error: ${e.message}`);\n  }\n  const minMax = await matched.minMaxLocAsync();\n  const result = {\n    score: minMax.maxVal\n  };\n  if (visualize) {\n    const resultMat = new cv.Mat(template.rows, template.cols * 2, cv.CV_8UC3);\n    await B.all([\n      reference.copyToAsync(\n        resultMat.getRegion(new cv.Rect(0, 0, reference.cols, reference.rows))),\n      template.copyToAsync(\n        resultMat.getRegion(new cv.Rect(reference.cols, 0, template.cols, template.rows)))\n    ]);\n    let mask = reference.absdiff(template);\n    mask = await mask.cvtColorAsync(cv.COLOR_BGR2GRAY);\n    let contours = [];\n    try {\n      mask = await mask.thresholdAsync(128, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);\n      contours = await mask.findContoursAsync(cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);\n    } catch (ign) {\n      // No contours can be found, which means, most likely, that images are equal\n    }\n    for (const contour of contours) {\n      const boundingRect = contour.boundingRect();\n      highlightRegion(resultMat, boundingRect);\n      highlightRegion(resultMat, {\n        x: reference.cols + boundingRect.x,\n        y: boundingRect.y,\n        width: boundingRect.width,\n        height: boundingRect.height\n      });\n    }\n    result.visualization = await cv.imencodeAsync('.png', resultMat);\n  }\n  return result;\n}\n\n/**\n * @typedef {Object} OccurrenceOptions\n * @property {?boolean} visualize [false] Whether to return the resulting visalization\n * as an image (useful for debugging purposes)\n * @property {?float} threshold [0.5] At what normalized threshold to reject\n * a match\n * @property {?float} multiple [false] find multiple matches in the image\n * @property {?number} matchNeighbourThreshold [10] The pixel distance between matches we consider\n * to be part of the same template match\n */\n\n/**\n * @typedef {Object} OccurrenceResult\n * @property {Rect} rect The region of the partial image occurence\n * on the full image\n * @property {?Buffer} visualization The visualization of the matching result\n * represented as PNG image buffer. On this image the matching\n * region is highlighted with a rectangle. If the multiple option is passed,\n * all results are highlighted here.\n * @property {number} score The similarity score as a float number in range [0.0, 1.0].\n * 1.0 is the highest score (means both images are totally equal).\n * @property {Array<OccurrenceResult>} multiple The array of matching OccurenceResults\n * - only when multiple option is passed\n * @property {string} method [TM_CCOEFF_NORMED] The name of the template matching method.\n * Acceptable values are:\n * - TM_CCOEFF\n * - TM_CCOEFF_NORMED (default)\n * - TM_CCORR\n * - TM_CCORR_NORMED\n * - TM_SQDIFF\n * - TM_SQDIFF_NORMED\n * Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html\n * for more details.\n */\n\n/**\n * Calculates the occurrence position of a partial image in the full\n * image.\n *\n * @param {Buffer} fullImgData The data of the full image packed into a NodeJS buffer\n * @param {Buffer} partialImgData The data of the partial image packed into a NodeJS buffer\n * @param {?OccurrenceOptions} options [{}] Set of occurrence calculation options\n *\n * @returns {OccurrenceResult}\n * @throws {Error} If no occurrences of the partial image can be found in the full image\n */\nasync function getImageOccurrence (fullImgData, partialImgData, options = {}) {\n  await initOpenCV();\n\n  const {\n    visualize = false,\n    threshold = DEFAULT_MATCH_THRESHOLD,\n    multiple = false,\n    matchNeighbourThreshold = MATCH_NEIGHBOUR_THRESHOLD,\n    method = DEFAULT_MATCHING_METHOD,\n  } = options;\n\n  const [fullImg, partialImg] = await B.all([\n    cv.imdecodeAsync(fullImgData),\n    cv.imdecodeAsync(partialImgData)\n  ]);\n  const results = [];\n  let visualization = null;\n\n  try {\n    const matched = await fullImg.matchTemplateAsync(partialImg, toMatchingMethod(method));\n    const minMax = await matched.minMaxLocAsync();\n\n    if (multiple) {\n      const nonZeroMatchResults = matched.threshold(threshold, 1, cv.THRESH_BINARY)\n        .convertTo(cv.CV_8U)\n        .findNonZero();\n      const matches = filterNearMatches(nonZeroMatchResults, matchNeighbourThreshold);\n\n      for (const {x, y} of matches) {\n        results.push({\n          score: matched.at(y, x),\n          rect: {\n            x, y,\n            width: partialImg.cols,\n            height: partialImg.rows\n          }\n        });\n      }\n    } else if (minMax.maxVal >= threshold) {\n      const {x, y} = method.includes('SQDIFF') ? minMax.minLoc : minMax.maxLoc;\n      results.push({\n        score: minMax.maxVal,\n        rect: {\n          x, y,\n          width: partialImg.cols,\n          height: partialImg.rows\n        }\n      });\n    }\n\n    if (_.isEmpty(results)) {\n      // Below error message, `Cannot find any occurrences` is referenced in find by image\n      throw new Error(`Match threshold: ${threshold}. Highest match value ` +\n                      `found was ${minMax.maxVal}`);\n    }\n  } catch (e) {\n    // Below error message, `Cannot find any occurrences` is referenced in find by image\n    throw new Error(`Cannot find any occurrences of the partial image in the full image. ` +\n      `Original error: ${e.message}`);\n  }\n\n  if (visualize) {\n    const fullHighlightedImage = fullImg.copy();\n\n    for (const result of results) {\n      const singleHighlightedImage = fullImg.copy();\n\n      highlightRegion(singleHighlightedImage, result.rect);\n      highlightRegion(fullHighlightedImage, result.rect);\n      result.visualization = await cv.imencodeAsync('.png', singleHighlightedImage);\n    }\n    visualization = await cv.imencodeAsync('.png', fullHighlightedImage);\n  }\n\n  return {\n    rect: results[0].rect,\n    score: results[0].score,\n    visualization,\n    multiple: results\n  };\n}\n\n/**\n * Filter out match results which have a matched neighbour\n *\n * @param {Array<Point>} nonZeroMatchResults matrix of image match results\n * @param {number} matchNeighbourThreshold The pixel distance within which we\n * consider an element being a neighbour of an existing match\n * @return {Array<Point>} the filtered array of matched points\n */\nfunction filterNearMatches (nonZeroMatchResults, matchNeighbourThreshold) {\n  return nonZeroMatchResults.reduce((acc, element) => {\n    if (!acc.some((match) => distance(match, element) <= matchNeighbourThreshold)) {\n      acc.push(element);\n    }\n    return acc;\n  }, []);\n}\n\n/**\n * Find the distance between two points\n *\n * @param {Point} point1 The first point\n * @param {Point} point2 The second point\n * @return {number} the distance\n */\nfunction distance (point1, point2) {\n  const a2 = Math.pow((point1.x - point2.x), 2);\n  const b2 = Math.pow((point1.y - point2.y), 2);\n  return Math.sqrt(a2 + b2);\n}\n\n/**\n * Crop the image by given rectangle (use base64 string as input and output)\n *\n * @param {string} base64Image The string with base64 encoded image\n * @param {Region} rect The selected region of image\n * @return {string} base64 encoded string of cropped image\n */\nasync function cropBase64Image (base64Image, rect) {\n  const image = await base64ToImage(base64Image);\n  cropImage(image, rect);\n  return await imageToBase64(image);\n}\n\n/**\n * Create a pngjs image from given base64 image\n *\n * @param {string} base64Image The string with base64 encoded image\n * @return {PNG} The image object\n */\nasync function base64ToImage (base64Image) {\n  const imageBuffer = Buffer.from(base64Image, 'base64');\n  return await new B((resolve, reject) => {\n    const image = new PNG({filterType: SCANLINE_FILTER_METHOD});\n    image.parse(imageBuffer, (err, image) => { // eslint-disable-line promise/prefer-await-to-callbacks\n      if (err) {\n        return reject(err);\n      }\n      resolve(image);\n    });\n  });\n}\n\n/**\n * Create a base64 string for given image object\n *\n * @param {PNG} image The image object\n * @return {string} The string with base64 encoded image\n */\nasync function imageToBase64 (image) {\n  return await new B((resolve, reject) => {\n    const chunks = [];\n    image.pack()\n    .on('data', (chunk) => chunks.push(chunk)).on('end', () => {\n      resolve(Buffer.concat(chunks).toString('base64'));\n    })\n    .on('error', (err) => { // eslint-disable-line promise/prefer-await-to-callbacks\n      reject(err);\n    });\n  });\n}\n\n/**\n * Crop the image by given rectangle\n *\n * @param {PNG} image The image to mutate by cropping\n * @param {Region} rect The selected region of image\n */\nfunction cropImage (image, rect) {\n  const imageRect = {width: image.width, height: image.height};\n  const interRect = getRectIntersection(rect, imageRect);\n  if (interRect.width < rect.width || interRect.height < rect.height) {\n    throw new Error(`Cannot crop ${JSON.stringify(rect)} from ${JSON.stringify(imageRect)} because the intersection between them was not the size of the rect`);\n  }\n\n  const firstVerticalPixel = interRect.top;\n  const lastVerticalPixel = interRect.top + interRect.height;\n\n  const firstHorizontalPixel = interRect.left;\n  const lastHorizontalPixel = interRect.left + interRect.width;\n\n  const croppedArray = [];\n  for (let y = firstVerticalPixel; y < lastVerticalPixel; y++) {\n    for (let x = firstHorizontalPixel; x < lastHorizontalPixel; x++) {\n      const firstByteIdxInPixelBlock = (imageRect.width * y + x) << 2;\n      for (let byteIdx = 0; byteIdx < BYTES_IN_PIXEL_BLOCK; byteIdx++) {\n        croppedArray.push(image.data[firstByteIdxInPixelBlock + byteIdx]);\n      }\n    }\n  }\n\n  image.data = Buffer.from(croppedArray);\n  image.width = interRect.width;\n  image.height = interRect.height;\n  return image;\n}\n\nfunction getRectIntersection (rect, imageSize) {\n  const left = rect.left >= imageSize.width ? imageSize.width : rect.left;\n  const top = rect.top >= imageSize.height ? imageSize.height : rect.top;\n  const width = imageSize.width >= (left + rect.width) ? rect.width : (imageSize.width - left);\n  const height = imageSize.height >= (top + rect.height) ? rect.height : (imageSize.height - top);\n  return {left, top, width, height};\n}\n\nexport {\n  cropBase64Image, base64ToImage, imageToBase64, cropImage, getImagesMatches,\n  getImagesSimilarity, getImageOccurrence, getJimpImage, MIME_JPEG, MIME_PNG,\n  MIME_BMP,\n};\n"]},"metadata":{},"sourceType":"script"}