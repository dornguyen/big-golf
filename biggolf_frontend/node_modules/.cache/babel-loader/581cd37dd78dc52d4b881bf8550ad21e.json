{"ast":null,"code":"var fs = require('fs');\nvar wx = 'wx';\nif (process.version.match(/^v0\\.[0-6]/)) {\n  var c = require('constants');\n  wx = c.O_TRUNC | c.O_CREAT | c.O_WRONLY | c.O_EXCL;\n}\nvar os = require('os');\nexports.filetime = 'ctime';\nif (os.platform() == \"win32\") {\n  exports.filetime = 'mtime';\n}\nvar debug;\nvar util = require('util');\nif (util.debuglog) debug = util.debuglog('LOCKFILE');else if (/\\blockfile\\b/i.test(process.env.NODE_DEBUG)) debug = function () {\n  var msg = util.format.apply(util, arguments);\n  console.error('LOCKFILE %d %s', process.pid, msg);\n};else debug = function () {};\nvar locks = {};\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nvar onExit = require('signal-exit');\nonExit(function () {\n  debug('exit listener');\n  // cleanup\n  Object.keys(locks).forEach(exports.unlockSync);\n});\n\n// XXX https://github.com/joyent/node/issues/3555\n// Remove when node 0.8 is deprecated.\nif (/^v0\\.[0-8]\\./.test(process.version)) {\n  debug('uncaughtException, version = %s', process.version);\n  process.on('uncaughtException', function H(er) {\n    debug('uncaughtException');\n    var l = process.listeners('uncaughtException').filter(function (h) {\n      return h !== H;\n    });\n    if (!l.length) {\n      // cleanup\n      try {\n        Object.keys(locks).forEach(exports.unlockSync);\n      } catch (e) {}\n      process.removeListener('uncaughtException', H);\n      throw er;\n    }\n  });\n}\nexports.unlock = function (path, cb) {\n  debug('unlock', path);\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  delete locks[path];\n  fs.unlink(path, function (unlinkEr) {\n    cb && cb();\n  });\n};\nexports.unlockSync = function (path) {\n  debug('unlockSync', path);\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  try {\n    fs.unlinkSync(path);\n  } catch (er) {}\n  delete locks[path];\n};\n\n// if the file can be opened in readonly mode, then it's there.\n// if the error is something other than ENOENT, then it's not.\nexports.check = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {};\n  debug('check', path, opts);\n  fs.open(path, 'r', function (er, fd) {\n    if (er) {\n      if (er.code !== 'ENOENT') return cb(er);\n      return cb(null, false);\n    }\n    if (!opts.stale) {\n      return fs.close(fd, function (er) {\n        return cb(er, true);\n      });\n    }\n    fs.fstat(fd, function (er, st) {\n      if (er) return fs.close(fd, function (er2) {\n        return cb(er);\n      });\n      fs.close(fd, function (er) {\n        var age = Date.now() - st[exports.filetime].getTime();\n        return cb(er, age <= opts.stale);\n      });\n    });\n  });\n};\nexports.checkSync = function (path, opts) {\n  opts = opts || {};\n  debug('checkSync', path, opts);\n  if (opts.wait) {\n    throw new Error('opts.wait not supported sync for obvious reasons');\n  }\n  try {\n    var fd = fs.openSync(path, 'r');\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er;\n    return false;\n  }\n  if (!opts.stale) {\n    try {\n      fs.closeSync(fd);\n    } catch (er) {}\n    return true;\n  }\n\n  // file exists.  however, might be stale\n  if (opts.stale) {\n    try {\n      var st = fs.fstatSync(fd);\n    } finally {\n      fs.closeSync(fd);\n    }\n    var age = Date.now() - st[exports.filetime].getTime();\n    return age <= opts.stale;\n  }\n};\nvar req = 1;\nexports.lock = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {};\n  opts.req = opts.req || req++;\n  debug('lock', path, opts);\n  opts.start = opts.start || Date.now();\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    debug('has retries', opts.retries);\n    var retries = opts.retries;\n    opts.retries = 0;\n    cb = function (orig) {\n      return function cb(er, fd) {\n        debug('retry-mutated callback');\n        retries -= 1;\n        if (!er || retries < 0) return orig(er, fd);\n        debug('lock retry', path, opts);\n        if (opts.retryWait) setTimeout(retry, opts.retryWait);else retry();\n        function retry() {\n          opts.start = Date.now();\n          debug('retrying', opts.start);\n          exports.lock(path, opts, cb);\n        }\n      };\n    }(cb);\n  }\n\n  // try to engage the lock.\n  // if this succeeds, then we're in business.\n  fs.open(path, wx, function (er, fd) {\n    if (!er) {\n      debug('locked', path, fd);\n      locks[path] = fd;\n      return fs.close(fd, function () {\n        return cb();\n      });\n    }\n    debug('failed to acquire lock', er);\n\n    // something other than \"currently locked\"\n    // maybe eperm or something.\n    if (er.code !== 'EEXIST') {\n      debug('not EEXIST error', er);\n      return cb(er);\n    }\n\n    // someone's got this one.  see if it's valid.\n    if (!opts.stale) return notStale(er, path, opts, cb);\n    return maybeStale(er, path, opts, false, cb);\n  });\n  debug('lock return');\n};\n\n// Staleness checking algorithm\n// 1. acquire $lock, fail\n// 2. stat $lock, find that it is stale\n// 3. acquire $lock.STALE\n// 4. stat $lock, assert that it is still stale\n// 5. unlink $lock\n// 6. link $lock.STALE $lock\n// 7. unlink $lock.STALE\n// On any failure, clean up whatever we've done, and raise the error.\nfunction maybeStale(originalEr, path, opts, hasStaleLock, cb) {\n  fs.stat(path, function (statEr, st) {\n    if (statEr) {\n      if (statEr.code === 'ENOENT') {\n        // expired already!\n        opts.stale = false;\n        debug('lock stale enoent retry', path, opts);\n        exports.lock(path, opts, cb);\n        return;\n      }\n      return cb(statEr);\n    }\n    var age = Date.now() - st[exports.filetime].getTime();\n    if (age <= opts.stale) return notStale(originalEr, path, opts, cb);\n    debug('lock stale', path, opts);\n    if (hasStaleLock) {\n      exports.unlock(path, function (er) {\n        if (er) return cb(er);\n        debug('lock stale retry', path, opts);\n        fs.link(path + '.STALE', path, function (er) {\n          fs.unlink(path + '.STALE', function () {\n            // best effort.  if the unlink fails, oh well.\n            cb(er);\n          });\n        });\n      });\n    } else {\n      debug('acquire .STALE file lock', opts);\n      exports.lock(path + '.STALE', opts, function (er) {\n        if (er) return cb(er);\n        maybeStale(originalEr, path, opts, true, cb);\n      });\n    }\n  });\n}\nfunction notStale(er, path, opts, cb) {\n  debug('notStale', path, opts);\n\n  // if we can't wait, then just call it a failure\n  if (typeof opts.wait !== 'number' || opts.wait <= 0) {\n    debug('notStale, wait is not a number');\n    return cb(er);\n  }\n\n  // poll for some ms for the lock to clear\n  var now = Date.now();\n  var start = opts.start || now;\n  var end = start + opts.wait;\n  if (end <= now) return cb(er);\n  debug('now=%d, wait until %d (delta=%d)', start, end, end - start);\n  var wait = Math.min(end - start, opts.pollPeriod || 100);\n  var timer = setTimeout(poll, wait);\n  function poll() {\n    debug('notStale, polling', path, opts);\n    exports.lock(path, opts, cb);\n  }\n}\nexports.lockSync = function (path, opts) {\n  opts = opts || {};\n  opts.req = opts.req || req++;\n  debug('lockSync', path, opts);\n  if (opts.wait || opts.retryWait) {\n    throw new Error('opts.wait not supported sync for obvious reasons');\n  }\n  try {\n    var fd = fs.openSync(path, wx);\n    locks[path] = fd;\n    try {\n      fs.closeSync(fd);\n    } catch (er) {}\n    debug('locked sync!', path, fd);\n    return;\n  } catch (er) {\n    if (er.code !== 'EEXIST') return retryThrow(path, opts, er);\n    if (opts.stale) {\n      var st = fs.statSync(path);\n      var ct = st[exports.filetime].getTime();\n      if (!(ct % 1000) && opts.stale % 1000) {\n        // probably don't have subsecond resolution.\n        // round up the staleness indicator.\n        // Yes, this will be wrong 1/1000 times on platforms\n        // with subsecond stat precision, but that's acceptable\n        // in exchange for not mistakenly removing locks on\n        // most other systems.\n        opts.stale = 1000 * Math.ceil(opts.stale / 1000);\n      }\n      var age = Date.now() - ct;\n      if (age > opts.stale) {\n        debug('lockSync stale', path, opts, age);\n        exports.unlockSync(path);\n        return exports.lockSync(path, opts);\n      }\n    }\n\n    // failed to lock!\n    debug('failed to lock', path, opts, er);\n    return retryThrow(path, opts, er);\n  }\n};\nfunction retryThrow(path, opts, er) {\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    var newRT = opts.retries - 1;\n    debug('retryThrow', path, opts, newRT);\n    opts.retries = newRT;\n    return exports.lockSync(path, opts);\n  }\n  throw er;\n}","map":{"version":3,"names":["fs","require","wx","process","version","match","c","O_TRUNC","O_CREAT","O_WRONLY","O_EXCL","os","exports","filetime","platform","debug","util","debuglog","test","env","NODE_DEBUG","msg","format","apply","arguments","console","error","pid","locks","hasOwnProperty","obj","prop","Object","prototype","call","onExit","keys","forEach","unlockSync","on","H","er","l","listeners","filter","h","length","e","removeListener","unlock","path","cb","unlink","unlinkEr","unlinkSync","check","opts","open","fd","code","stale","close","fstat","st","er2","age","Date","now","getTime","checkSync","wait","Error","openSync","closeSync","fstatSync","req","lock","start","retries","orig","retryWait","setTimeout","retry","notStale","maybeStale","originalEr","hasStaleLock","stat","statEr","link","end","Math","min","pollPeriod","timer","poll","lockSync","retryThrow","statSync","ct","ceil","newRT"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/lockfile/lockfile.js"],"sourcesContent":["var fs = require('fs')\n\nvar wx = 'wx'\nif (process.version.match(/^v0\\.[0-6]/)) {\n  var c = require('constants')\n  wx = c.O_TRUNC | c.O_CREAT | c.O_WRONLY | c.O_EXCL\n}\n\nvar os = require('os')\nexports.filetime = 'ctime'\nif (os.platform() == \"win32\") {\n  exports.filetime = 'mtime'\n}\n\nvar debug\nvar util = require('util')\nif (util.debuglog)\n  debug = util.debuglog('LOCKFILE')\nelse if (/\\blockfile\\b/i.test(process.env.NODE_DEBUG))\n  debug = function() {\n    var msg = util.format.apply(util, arguments)\n    console.error('LOCKFILE %d %s', process.pid, msg)\n  }\nelse\n  debug = function() {}\n\nvar locks = {}\n\nfunction hasOwnProperty (obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\nvar onExit = require('signal-exit')\nonExit(function () {\n  debug('exit listener')\n  // cleanup\n  Object.keys(locks).forEach(exports.unlockSync)\n})\n\n// XXX https://github.com/joyent/node/issues/3555\n// Remove when node 0.8 is deprecated.\nif (/^v0\\.[0-8]\\./.test(process.version)) {\n  debug('uncaughtException, version = %s', process.version)\n  process.on('uncaughtException', function H (er) {\n    debug('uncaughtException')\n    var l = process.listeners('uncaughtException').filter(function (h) {\n      return h !== H\n    })\n    if (!l.length) {\n      // cleanup\n      try { Object.keys(locks).forEach(exports.unlockSync) } catch (e) {}\n      process.removeListener('uncaughtException', H)\n      throw er\n    }\n  })\n}\n\nexports.unlock = function (path, cb) {\n  debug('unlock', path)\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  delete locks[path]\n  fs.unlink(path, function (unlinkEr) { cb && cb() })\n}\n\nexports.unlockSync = function (path) {\n  debug('unlockSync', path)\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  try { fs.unlinkSync(path) } catch (er) {}\n  delete locks[path]\n}\n\n\n// if the file can be opened in readonly mode, then it's there.\n// if the error is something other than ENOENT, then it's not.\nexports.check = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {}\n  debug('check', path, opts)\n  fs.open(path, 'r', function (er, fd) {\n    if (er) {\n      if (er.code !== 'ENOENT') return cb(er)\n      return cb(null, false)\n    }\n\n    if (!opts.stale) {\n      return fs.close(fd, function (er) {\n        return cb(er, true)\n      })\n    }\n\n    fs.fstat(fd, function (er, st) {\n      if (er) return fs.close(fd, function (er2) {\n        return cb(er)\n      })\n\n      fs.close(fd, function (er) {\n        var age = Date.now() - st[exports.filetime].getTime()\n        return cb(er, age <= opts.stale)\n      })\n    })\n  })\n}\n\nexports.checkSync = function (path, opts) {\n  opts = opts || {}\n  debug('checkSync', path, opts)\n  if (opts.wait) {\n    throw new Error('opts.wait not supported sync for obvious reasons')\n  }\n\n  try {\n    var fd = fs.openSync(path, 'r')\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er\n    return false\n  }\n\n  if (!opts.stale) {\n    try { fs.closeSync(fd) } catch (er) {}\n    return true\n  }\n\n  // file exists.  however, might be stale\n  if (opts.stale) {\n    try {\n      var st = fs.fstatSync(fd)\n    } finally {\n      fs.closeSync(fd)\n    }\n    var age = Date.now() - st[exports.filetime].getTime()\n    return (age <= opts.stale)\n  }\n}\n\n\n\nvar req = 1\nexports.lock = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {}\n  opts.req = opts.req || req++\n  debug('lock', path, opts)\n  opts.start = opts.start || Date.now()\n\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    debug('has retries', opts.retries)\n    var retries = opts.retries\n    opts.retries = 0\n    cb = (function (orig) { return function cb (er, fd) {\n      debug('retry-mutated callback')\n      retries -= 1\n      if (!er || retries < 0) return orig(er, fd)\n\n      debug('lock retry', path, opts)\n\n      if (opts.retryWait) setTimeout(retry, opts.retryWait)\n      else retry()\n\n      function retry () {\n        opts.start = Date.now()\n        debug('retrying', opts.start)\n        exports.lock(path, opts, cb)\n      }\n    }})(cb)\n  }\n\n  // try to engage the lock.\n  // if this succeeds, then we're in business.\n  fs.open(path, wx, function (er, fd) {\n    if (!er) {\n      debug('locked', path, fd)\n      locks[path] = fd\n      return fs.close(fd, function () {\n        return cb()\n      })\n    }\n\n    debug('failed to acquire lock', er)\n\n    // something other than \"currently locked\"\n    // maybe eperm or something.\n    if (er.code !== 'EEXIST') {\n      debug('not EEXIST error', er)\n      return cb(er)\n    }\n\n    // someone's got this one.  see if it's valid.\n    if (!opts.stale) return notStale(er, path, opts, cb)\n\n    return maybeStale(er, path, opts, false, cb)\n  })\n  debug('lock return')\n}\n\n\n// Staleness checking algorithm\n// 1. acquire $lock, fail\n// 2. stat $lock, find that it is stale\n// 3. acquire $lock.STALE\n// 4. stat $lock, assert that it is still stale\n// 5. unlink $lock\n// 6. link $lock.STALE $lock\n// 7. unlink $lock.STALE\n// On any failure, clean up whatever we've done, and raise the error.\nfunction maybeStale (originalEr, path, opts, hasStaleLock, cb) {\n  fs.stat(path, function (statEr, st) {\n    if (statEr) {\n      if (statEr.code === 'ENOENT') {\n        // expired already!\n        opts.stale = false\n        debug('lock stale enoent retry', path, opts)\n        exports.lock(path, opts, cb)\n        return\n      }\n      return cb(statEr)\n    }\n\n    var age = Date.now() - st[exports.filetime].getTime()\n    if (age <= opts.stale) return notStale(originalEr, path, opts, cb)\n\n    debug('lock stale', path, opts)\n    if (hasStaleLock) {\n      exports.unlock(path, function (er) {\n        if (er) return cb(er)\n        debug('lock stale retry', path, opts)\n        fs.link(path + '.STALE', path, function (er) {\n          fs.unlink(path + '.STALE', function () {\n            // best effort.  if the unlink fails, oh well.\n            cb(er)\n          })\n        })\n      })\n    } else {\n      debug('acquire .STALE file lock', opts)\n      exports.lock(path + '.STALE', opts, function (er) {\n        if (er) return cb(er)\n        maybeStale(originalEr, path, opts, true, cb)\n      })\n    }\n  })\n}\n\nfunction notStale (er, path, opts, cb) {\n  debug('notStale', path, opts)\n\n  // if we can't wait, then just call it a failure\n  if (typeof opts.wait !== 'number' || opts.wait <= 0) {\n    debug('notStale, wait is not a number')\n    return cb(er)\n  }\n\n  // poll for some ms for the lock to clear\n  var now = Date.now()\n  var start = opts.start || now\n  var end = start + opts.wait\n\n  if (end <= now)\n    return cb(er)\n\n  debug('now=%d, wait until %d (delta=%d)', start, end, end-start)\n  var wait = Math.min(end - start, opts.pollPeriod || 100)\n  var timer = setTimeout(poll, wait)\n\n  function poll () {\n    debug('notStale, polling', path, opts)\n    exports.lock(path, opts, cb)\n  }\n}\n\nexports.lockSync = function (path, opts) {\n  opts = opts || {}\n  opts.req = opts.req || req++\n  debug('lockSync', path, opts)\n  if (opts.wait || opts.retryWait) {\n    throw new Error('opts.wait not supported sync for obvious reasons')\n  }\n\n  try {\n    var fd = fs.openSync(path, wx)\n    locks[path] = fd\n    try { fs.closeSync(fd) } catch (er) {}\n    debug('locked sync!', path, fd)\n    return\n  } catch (er) {\n    if (er.code !== 'EEXIST') return retryThrow(path, opts, er)\n\n    if (opts.stale) {\n      var st = fs.statSync(path)\n      var ct = st[exports.filetime].getTime()\n      if (!(ct % 1000) && (opts.stale % 1000)) {\n        // probably don't have subsecond resolution.\n        // round up the staleness indicator.\n        // Yes, this will be wrong 1/1000 times on platforms\n        // with subsecond stat precision, but that's acceptable\n        // in exchange for not mistakenly removing locks on\n        // most other systems.\n        opts.stale = 1000 * Math.ceil(opts.stale / 1000)\n      }\n      var age = Date.now() - ct\n      if (age > opts.stale) {\n        debug('lockSync stale', path, opts, age)\n        exports.unlockSync(path)\n        return exports.lockSync(path, opts)\n      }\n    }\n\n    // failed to lock!\n    debug('failed to lock', path, opts, er)\n    return retryThrow(path, opts, er)\n  }\n}\n\nfunction retryThrow (path, opts, er) {\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    var newRT = opts.retries - 1\n    debug('retryThrow', path, opts, newRT)\n    opts.retries = newRT\n    return exports.lockSync(path, opts)\n  }\n  throw er\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}