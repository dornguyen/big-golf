{"ast":null,"code":"'use strict';\n\nconst Omggif = require('omggif');\nconst {\n  Gif,\n  GifError\n} = require('./gif');\nlet GifUtil; // allow circular dependency with GifUtil\nprocess.nextTick(() => {\n  GifUtil = require('./gifutil');\n});\nconst {\n  GifFrame\n} = require('./gifframe');\nconst PER_GIF_OVERHEAD = 200; // these are guesses at upper limits\nconst PER_FRAME_OVERHEAD = 100;\n\n// Note: I experimented with accepting a global color table when encoding and returning the global color table when decoding. Doing this properly greatly increased the complexity of the code and the amount of clock cycles required. The main issue is that each frame can specify any color of the global color table to be transparent within the frame, while this GIF library strives to hide GIF formatting details from its clients. E.g. it's possible to have 256 colors in the global color table and different transparencies in each frame, requiring clients to either provide per-frame transparency indexes, or for arcane reasons that won't be apparent to client developers, encode some GIFs with local color tables that previously decoded with global tables.\n\n/** @class GifCodec */\n\nclass GifCodec {\n  // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest\n\n  /**\n   * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.\n   * \n   * Instances of this class are stateless and can be shared across multiple encodings and decodings.\n   * \n   * Its constructor takes one option argument:\n   * \n   * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.\n   */\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._transparentRGB = null; // 0x000000\n    if (typeof options.transparentRGB === 'number' && options.transparentRGB !== 0) {\n      this._transparentRGBA = options.transparentRGB * 256;\n    }\n    this._testInitialBufferSize = 0; // assume no buffer scaling test\n  }\n\n  /**\n   * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.\n   * \n   * @param {Buffer} buffer Bytes of an encoded GIF to decode.\n   * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.\n   * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.\n   */\n\n  decodeGif(buffer) {\n    try {\n      let reader;\n      try {\n        reader = new Omggif.GifReader(buffer);\n      } catch (err) {\n        throw new GifError(err);\n      }\n      const frameCount = reader.numFrames();\n      const frames = [];\n      const spec = {\n        width: reader.width,\n        height: reader.height,\n        loops: reader.loopCount()\n      };\n      spec.usesTransparency = false;\n      for (let i = 0; i < frameCount; ++i) {\n        const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);\n        frames.push(frameInfo.frame);\n        if (frameInfo.usesTransparency) {\n          spec.usesTransparency = true;\n        }\n      }\n      return Promise.resolve(new Gif(buffer, frames, spec));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  /**\n   * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.\n   * \n   * @param {GifFrame[]} frames Array of frames to encode\n   * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.\n   * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.\n   * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.\n   */\n\n  encodeGif(frames) {\n    let spec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    try {\n      if (frames === null || frames.length === 0) {\n        throw new GifError(\"there are no frames\");\n      }\n      const dims = GifUtil.getMaxDimensions(frames);\n      spec = Object.assign({}, spec); // don't munge caller's spec\n      spec.width = dims.maxWidth;\n      spec.height = dims.maxHeight;\n      spec.loops = spec.loops || 0;\n      spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;\n      return Promise.resolve(this._encodeGif(frames, spec));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n  _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {\n    let info, buffer;\n    try {\n      info = reader.frameInfo(frameIndex);\n      buffer = new Buffer(reader.width * reader.height * 4);\n      reader.decodeAndBlitFrameRGBA(frameIndex, buffer);\n      if (info.width !== reader.width || info.height !== reader.height) {\n        if (info.y) {\n          // skip unused rows\n          buffer = buffer.slice(info.y * reader.width * 4);\n        }\n        if (reader.width > info.width) {\n          // skip scanstride\n          for (let ii = 0; ii < info.height; ++ii) {\n            buffer.copy(buffer, ii * info.width * 4, (info.x + ii * reader.width) * 4, (info.x + ii * reader.width) * 4 + info.width * 4);\n          }\n        }\n        // trim buffer to size\n        buffer = buffer.slice(0, info.width * info.height * 4);\n      }\n    } catch (err) {\n      throw new GifError(err);\n    }\n    let usesTransparency = false;\n    if (this._transparentRGBA === null) {\n      if (!alreadyUsedTransparency) {\n        for (let i = 3; i < buffer.length; i += 4) {\n          if (buffer[i] === 0) {\n            usesTransparency = true;\n            i = buffer.length;\n          }\n        }\n      }\n    } else {\n      for (let i = 3; i < buffer.length; i += 4) {\n        if (buffer[i] === 0) {\n          buffer.writeUInt32BE(this._transparentRGBA, i - 3);\n          usesTransparency = true; // GIF might encode unused index\n        }\n      }\n    }\n\n    const frame = new GifFrame(info.width, info.height, buffer, {\n      xOffset: info.x,\n      yOffset: info.y,\n      disposalMethod: info.disposal,\n      interlaced: info.interlaced,\n      delayCentisecs: info.delay\n    });\n    return {\n      frame,\n      usesTransparency\n    };\n  }\n  _encodeGif(frames, spec) {\n    let colorInfo;\n    if (spec.colorScope === Gif.LocalColorsOnly) {\n      colorInfo = GifUtil.getColorInfo(frames, 0);\n    } else {\n      colorInfo = GifUtil.getColorInfo(frames, 256);\n      if (!colorInfo.colors) {\n        // if global palette impossible\n        if (spec.colorScope === Gif.GlobalColorsOnly) {\n          throw new GifError(\"Too many color indexes for global color table\");\n        }\n        spec.colorScope = Gif.LocalColorsOnly;\n      }\n    }\n    spec.usesTransparency = colorInfo.usesTransparency;\n    const localPalettes = colorInfo.palettes;\n    if (spec.colorScope === Gif.LocalColorsOnly) {\n      const localSizeEst = 2000; //this._getSizeEstimateLocal(localPalettes, frames);\n      return _encodeLocal(frames, spec, localSizeEst, localPalettes);\n    }\n    const globalSizeEst = 2000; //this._getSizeEstimateGlobal(colorInfo, frames);\n    return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);\n  }\n  _getSizeEstimateGlobal(globalPalette, frames) {\n    if (this._testInitialBufferSize > 0) {\n      return this._testInitialBufferSize;\n    }\n    let sizeEst = PER_GIF_OVERHEAD + 3 * 256 /* max palette size*/;\n    const pixelBitWidth = _getPixelBitWidth(globalPalette);\n    frames.forEach(frame => {\n      sizeEst += _getFrameSizeEst(frame, pixelBitWidth);\n    });\n    return sizeEst; // should be the upper limit\n  }\n\n  _getSizeEstimateLocal(palettes, frames) {\n    if (this._testInitialBufferSize > 0) {\n      return this._testInitialBufferSize;\n    }\n    let sizeEst = PER_GIF_OVERHEAD;\n    for (let i = 0; i < frames.length; ++i) {\n      const palette = palettes[i];\n      const pixelBitWidth = _getPixelBitWidth(palette);\n      sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);\n    }\n    return sizeEst; // should be the upper limit\n  }\n}\n\nexports.GifCodec = GifCodec;\nfunction _colorLookupLinear(colors, color) {\n  const index = colors.indexOf(color);\n  return index === -1 ? null : index;\n}\nfunction _colorLookupBinary(colors, color) {\n  // adapted from https://stackoverflow.com/a/10264318/650894\n  var lo = 0,\n    hi = colors.length - 1,\n    mid;\n  while (lo <= hi) {\n    mid = Math.floor((lo + hi) / 2);\n    if (colors[mid] > color) hi = mid - 1;else if (colors[mid] < color) lo = mid + 1;else return mid;\n  }\n  return null;\n}\nfunction _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {\n  // would be inefficient for frames to lookup colors in extended palette \n  const extendedGlobalPalette = {\n    colors: globalPalette.colors.slice(),\n    usesTransparency: globalPalette.usesTransparency\n  };\n  _extendPaletteToPowerOf2(extendedGlobalPalette);\n  const options = {\n    palette: extendedGlobalPalette.colors,\n    loop: spec.loops\n  };\n  let buffer = new Buffer(bufferSizeEst);\n  let gifWriter;\n  try {\n    gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);\n  } catch (err) {\n    throw new GifError(err);\n  }\n  for (let i = 0; i < frames.length; ++i) {\n    buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);\n  }\n  return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);\n}\nfunction _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {\n  const options = {\n    loop: spec.loops\n  };\n  let buffer = new Buffer(bufferSizeEst);\n  let gifWriter;\n  try {\n    gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);\n  } catch (err) {\n    throw new GifError(err);\n  }\n  for (let i = 0; i < frames.length; ++i) {\n    buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);\n  }\n  return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);\n}\nfunction _extendPaletteToPowerOf2(palette) {\n  const colors = palette.colors;\n  if (palette.usesTransparency) {\n    colors.push(0);\n  }\n  const colorCount = colors.length;\n  let powerOf2 = 2;\n  while (colorCount > powerOf2) {\n    powerOf2 <<= 1;\n  }\n  colors.length = powerOf2;\n  colors.fill(0, colorCount);\n}\nfunction _getFrameSizeEst(frame, pixelBitWidth) {\n  let byteLength = frame.bitmap.width * frame.bitmap.height;\n  byteLength = Math.ceil(byteLength * pixelBitWidth / 8);\n  byteLength += Math.ceil(byteLength / 255); // add block size bytes\n  // assume maximum palete size because it might get extended for power of 2\n  return PER_FRAME_OVERHEAD + byteLength + 3 * 256 /* largest palette */;\n}\n\nfunction _getIndexedImage(frameIndex, frame, palette) {\n  const colors = palette.colors;\n  const colorToIndexFunc = colors.length <= 8 ?\n  // guess at the break-even\n  _colorLookupLinear : _colorLookupBinary;\n  const colorBuffer = frame.bitmap.data;\n  const indexBuffer = new Buffer(colorBuffer.length / 4);\n  let transparentIndex = colors.length;\n  let i = 0,\n    j = 0;\n  while (i < colorBuffer.length) {\n    if (colorBuffer[i + 3] !== 0) {\n      const color = colorBuffer.readUInt32BE(i, true) >> 8 & 0xFFFFFF;\n      // caller guarantees that the color will be in the palette\n      indexBuffer[j] = colorToIndexFunc(colors, color);\n    } else {\n      indexBuffer[j] = transparentIndex;\n    }\n    i += 4; // skip alpha\n    ++j;\n  }\n  if (palette.usesTransparency) {\n    if (transparentIndex === 256) {\n      throw new GifError(`Frame ${frameIndex} already has 256 colors` + `and so can't use transparency`);\n    }\n  } else {\n    transparentIndex = null;\n  }\n  return {\n    buffer: indexBuffer,\n    transparentIndex\n  };\n}\nfunction _getPixelBitWidth(palette) {\n  let indexCount = palette.indexCount;\n  let pixelBitWidth = 0;\n  --indexCount; // start at maximum index\n  while (indexCount) {\n    ++pixelBitWidth;\n    indexCount >>= 1;\n  }\n  return pixelBitWidth > 0 ? pixelBitWidth : 1;\n}\nfunction _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {\n  if (frame.interlaced) {\n    throw new GifError(\"writing interlaced GIFs is not supported\");\n  }\n  const frameInfo = _getIndexedImage(frameIndex, frame, palette);\n  const options = {\n    delay: frame.delayCentisecs,\n    disposal: frame.disposalMethod,\n    transparent: frameInfo.transparentIndex\n  };\n  if (isLocalPalette) {\n    _extendPaletteToPowerOf2(palette); // ok 'cause palette never used again\n    options.palette = palette.colors;\n  }\n  try {\n    let buffer = gifWriter.getOutputBuffer();\n    let startOfFrame = gifWriter.getOutputBufferPosition();\n    let endOfFrame;\n    let tryAgain = true;\n    while (tryAgain) {\n      endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);\n      tryAgain = false;\n      if (endOfFrame >= buffer.length - 1) {\n        const biggerBuffer = new Buffer(buffer.length * 1.5);\n        buffer.copy(biggerBuffer);\n        gifWriter.setOutputBuffer(biggerBuffer);\n        gifWriter.setOutputBufferPosition(startOfFrame);\n        buffer = biggerBuffer;\n        tryAgain = true;\n      }\n    }\n    return buffer;\n  } catch (err) {\n    throw new GifError(err);\n  }\n}","map":{"version":3,"names":["Omggif","require","Gif","GifError","GifUtil","process","nextTick","GifFrame","PER_GIF_OVERHEAD","PER_FRAME_OVERHEAD","GifCodec","constructor","options","_transparentRGB","transparentRGB","_transparentRGBA","_testInitialBufferSize","decodeGif","buffer","reader","GifReader","err","frameCount","numFrames","frames","spec","width","height","loops","loopCount","usesTransparency","i","frameInfo","_decodeFrame","push","frame","Promise","resolve","reject","encodeGif","length","dims","getMaxDimensions","Object","assign","maxWidth","maxHeight","colorScope","GlobalColorsPreferred","_encodeGif","frameIndex","alreadyUsedTransparency","info","Buffer","decodeAndBlitFrameRGBA","y","slice","ii","copy","x","writeUInt32BE","xOffset","yOffset","disposalMethod","disposal","interlaced","delayCentisecs","delay","colorInfo","LocalColorsOnly","getColorInfo","colors","GlobalColorsOnly","localPalettes","palettes","localSizeEst","_encodeLocal","globalSizeEst","_encodeGlobal","_getSizeEstimateGlobal","globalPalette","sizeEst","pixelBitWidth","_getPixelBitWidth","forEach","_getFrameSizeEst","_getSizeEstimateLocal","palette","exports","_colorLookupLinear","color","index","indexOf","_colorLookupBinary","lo","hi","mid","Math","floor","bufferSizeEst","extendedGlobalPalette","_extendPaletteToPowerOf2","loop","gifWriter","GifWriter","_writeFrame","end","colorCount","powerOf2","fill","byteLength","bitmap","ceil","_getIndexedImage","colorToIndexFunc","colorBuffer","data","indexBuffer","transparentIndex","j","readUInt32BE","indexCount","isLocalPalette","transparent","getOutputBuffer","startOfFrame","getOutputBufferPosition","endOfFrame","tryAgain","addFrame","biggerBuffer","setOutputBuffer","setOutputBufferPosition"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/gifwrap/src/gifcodec.js"],"sourcesContent":["'use strict';\n\nconst Omggif = require('omggif');\nconst { Gif, GifError } = require('./gif');\nlet GifUtil; // allow circular dependency with GifUtil\nprocess.nextTick(() => {\n    GifUtil = require('./gifutil');\n});\n\nconst { GifFrame } = require('./gifframe');\n\nconst PER_GIF_OVERHEAD = 200; // these are guesses at upper limits\nconst PER_FRAME_OVERHEAD = 100;\n\n// Note: I experimented with accepting a global color table when encoding and returning the global color table when decoding. Doing this properly greatly increased the complexity of the code and the amount of clock cycles required. The main issue is that each frame can specify any color of the global color table to be transparent within the frame, while this GIF library strives to hide GIF formatting details from its clients. E.g. it's possible to have 256 colors in the global color table and different transparencies in each frame, requiring clients to either provide per-frame transparency indexes, or for arcane reasons that won't be apparent to client developers, encode some GIFs with local color tables that previously decoded with global tables.\n\n/** @class GifCodec */\n\nclass GifCodec\n{\n    // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest\n\n    /**\n     * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.\n     * \n     * Instances of this class are stateless and can be shared across multiple encodings and decodings.\n     * \n     * Its constructor takes one option argument:\n     * \n     * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.\n     */\n\n    constructor(options = {}) {\n        this._transparentRGB = null; // 0x000000\n        if (typeof options.transparentRGB === 'number' &&\n                options.transparentRGB !== 0)\n        {\n            this._transparentRGBA = options.transparentRGB * 256;\n        }\n        this._testInitialBufferSize = 0; // assume no buffer scaling test\n    }\n\n    /**\n     * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.\n     * \n     * @param {Buffer} buffer Bytes of an encoded GIF to decode.\n     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.\n     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.\n     */\n\n    decodeGif(buffer) {\n        try {\n            let reader;\n            try {\n                reader = new Omggif.GifReader(buffer);\n            }\n            catch (err) {\n                throw new GifError(err);\n            }\n            const frameCount = reader.numFrames();\n            const frames = [];\n            const spec = {\n                width: reader.width,\n                height: reader.height,\n                loops: reader.loopCount()\n            };\n\n            spec.usesTransparency = false;\n            for (let i = 0; i < frameCount; ++i) {\n                const frameInfo =\n                        this._decodeFrame(reader, i, spec.usesTransparency);\n                frames.push(frameInfo.frame);\n                if (frameInfo.usesTransparency) {\n                    spec.usesTransparency = true;\n                }\n            }\n            return Promise.resolve(new Gif(buffer, frames, spec));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    /**\n     * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.\n     * \n     * @param {GifFrame[]} frames Array of frames to encode\n     * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.\n     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.\n     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.\n     */\n\n    encodeGif(frames, spec = {}) {\n        try {\n            if (frames === null || frames.length === 0) {\n                throw new GifError(\"there are no frames\");\n            }\n            const dims = GifUtil.getMaxDimensions(frames);\n\n            spec = Object.assign({}, spec); // don't munge caller's spec\n            spec.width = dims.maxWidth;\n            spec.height = dims.maxHeight;\n            spec.loops = spec.loops || 0;\n            spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;\n\n            return Promise.resolve(this._encodeGif(frames, spec));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {\n        let info, buffer;\n        try {\n            info = reader.frameInfo(frameIndex);\n            buffer = new Buffer(reader.width * reader.height * 4);\n            reader.decodeAndBlitFrameRGBA(frameIndex, buffer);\n            if (info.width !== reader.width || info.height !== reader.height) {\n                if (info.y) {\n                    // skip unused rows\n                    buffer = buffer.slice(info.y * reader.width * 4);\n                }\n                if (reader.width > info.width) {\n                    // skip scanstride\n                    for (let ii = 0; ii < info.height; ++ii) {\n                        buffer.copy(buffer, ii * info.width * 4,\n                            (info.x + ii * reader.width) * 4,\n                            (info.x + ii * reader.width) * 4 + info.width * 4);\n                    }\n                }\n                // trim buffer to size\n                buffer = buffer.slice(0, info.width * info.height * 4);\n            }\n        }\n        catch (err) {\n            throw new GifError(err);\n        }\n\n        let usesTransparency = false;\n        if (this._transparentRGBA === null) {\n            if (!alreadyUsedTransparency) {\n                for (let i = 3; i < buffer.length; i += 4) {\n                    if (buffer[i] === 0) {\n                        usesTransparency = true;\n                        i = buffer.length;\n                    }\n                }\n            }\n        }\n        else {\n            for (let i = 3; i < buffer.length; i += 4) {\n                if (buffer[i] === 0) {\n                    buffer.writeUInt32BE(this._transparentRGBA, i - 3);\n                    usesTransparency = true; // GIF might encode unused index\n                }\n            }\n        }\n\n        const frame = new GifFrame(info.width, info.height, buffer, {\n            xOffset: info.x,\n            yOffset: info.y,\n            disposalMethod: info.disposal,\n            interlaced: info.interlaced,\n            delayCentisecs: info.delay\n        });\n        return { frame, usesTransparency };\n    }\n\n    _encodeGif(frames, spec) {\n        let colorInfo;\n        if (spec.colorScope === Gif.LocalColorsOnly) {\n            colorInfo = GifUtil.getColorInfo(frames, 0);\n        }\n        else {\n            colorInfo = GifUtil.getColorInfo(frames, 256);\n            if (!colorInfo.colors) { // if global palette impossible\n                if (spec.colorScope === Gif.GlobalColorsOnly) {\n                    throw new GifError(\n                            \"Too many color indexes for global color table\");\n                }\n                spec.colorScope = Gif.LocalColorsOnly\n            }\n        }\n        spec.usesTransparency = colorInfo.usesTransparency;\n\n        const localPalettes = colorInfo.palettes;\n        if (spec.colorScope === Gif.LocalColorsOnly) {\n            const localSizeEst = 2000; //this._getSizeEstimateLocal(localPalettes, frames);\n            return _encodeLocal(frames, spec, localSizeEst, localPalettes);\n        }\n\n        const globalSizeEst = 2000; //this._getSizeEstimateGlobal(colorInfo, frames);\n        return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);\n    }\n\n    _getSizeEstimateGlobal(globalPalette, frames) {\n        if (this._testInitialBufferSize > 0) {\n            return this._testInitialBufferSize;\n        }\n        let sizeEst = PER_GIF_OVERHEAD + 3*256 /* max palette size*/;\n        const pixelBitWidth = _getPixelBitWidth(globalPalette);\n        frames.forEach(frame => {\n            sizeEst += _getFrameSizeEst(frame, pixelBitWidth);\n        });\n        return sizeEst; // should be the upper limit\n    }\n\n    _getSizeEstimateLocal(palettes, frames) {\n        if (this._testInitialBufferSize > 0) {\n            return this._testInitialBufferSize;\n        }\n        let sizeEst = PER_GIF_OVERHEAD;\n        for (let i = 0; i < frames.length; ++i ) {\n            const palette = palettes[i];\n            const pixelBitWidth = _getPixelBitWidth(palette);\n            sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);\n        }\n        return sizeEst; // should be the upper limit\n    }\n}\nexports.GifCodec = GifCodec;\n\nfunction _colorLookupLinear(colors, color) {\n    const index = colors.indexOf(color);\n    return (index === -1 ? null : index);\n}\n\nfunction _colorLookupBinary(colors, color) {\n    // adapted from https://stackoverflow.com/a/10264318/650894\n    var lo = 0, hi = colors.length - 1, mid;\n    while (lo <= hi) {\n        mid = Math.floor((lo + hi)/2);\n        if (colors[mid] > color)\n            hi = mid - 1;\n        else if (colors[mid] < color)\n            lo = mid + 1;\n        else\n            return mid;\n    }\n    return null;\n}\n\nfunction _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {\n    // would be inefficient for frames to lookup colors in extended palette \n    const extendedGlobalPalette = {\n        colors: globalPalette.colors.slice(),\n        usesTransparency: globalPalette.usesTransparency\n    };\n    _extendPaletteToPowerOf2(extendedGlobalPalette);\n    const options = {\n        palette: extendedGlobalPalette.colors,\n        loop: spec.loops\n    };\n    let buffer = new Buffer(bufferSizeEst);\n    let gifWriter;\n    try {\n        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,\n                            options);\n    }\n    catch (err) {\n        throw new GifError(err);\n    }\n    for (let i = 0; i < frames.length; ++i) {\n        buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);\n    }\n    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);\n}\n\nfunction _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {\n    const options = {\n        loop: spec.loops\n    };\n    let buffer = new Buffer(bufferSizeEst);\n    let gifWriter;\n    try {\n        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,\n                            options);\n    }                            \n    catch (err) {\n        throw new GifError(err);\n    }\n    for (let i = 0; i < frames.length; ++i) {\n        buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);\n    }\n    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);\n}\n\nfunction _extendPaletteToPowerOf2(palette) {\n    const colors = palette.colors;\n    if (palette.usesTransparency) {\n        colors.push(0);\n    }\n    const colorCount = colors.length;\n    let powerOf2 = 2;\n    while (colorCount > powerOf2) {\n        powerOf2 <<= 1;\n    }\n    colors.length = powerOf2;\n    colors.fill(0, colorCount);\n}\n\nfunction _getFrameSizeEst(frame, pixelBitWidth) {\n    let byteLength = frame.bitmap.width * frame.bitmap.height;\n    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);\n    byteLength += Math.ceil(byteLength / 255); // add block size bytes\n    // assume maximum palete size because it might get extended for power of 2\n    return (PER_FRAME_OVERHEAD + byteLength + 3 * 256 /* largest palette */);\n}\n\nfunction _getIndexedImage(frameIndex, frame, palette) {\n    const colors = palette.colors;\n    const colorToIndexFunc = (colors.length <= 8 ? // guess at the break-even\n            _colorLookupLinear : _colorLookupBinary);\n    const colorBuffer = frame.bitmap.data;\n    const indexBuffer = new Buffer(colorBuffer.length/4);\n    let transparentIndex = colors.length;\n    let i = 0, j = 0;\n\n    while (i < colorBuffer.length) {\n        if (colorBuffer[i + 3] !== 0) {\n            const color = (colorBuffer.readUInt32BE(i, true) >> 8) & 0xFFFFFF;\n            // caller guarantees that the color will be in the palette\n            indexBuffer[j] = colorToIndexFunc(colors, color);\n        }\n        else {\n            indexBuffer[j] = transparentIndex;\n        }\n        i += 4; // skip alpha\n        ++j;\n    }\n\n    if (palette.usesTransparency) {\n        if (transparentIndex === 256) {\n            throw new GifError(`Frame ${frameIndex} already has 256 colors` +\n                    `and so can't use transparency`);\n        }\n    }\n    else {\n        transparentIndex = null;\n    }\n\n    return { buffer: indexBuffer, transparentIndex };\n}\n\nfunction _getPixelBitWidth(palette) {\n    let indexCount = palette.indexCount;\n    let pixelBitWidth = 0;\n    --indexCount; // start at maximum index\n    while (indexCount) {\n        ++pixelBitWidth;\n        indexCount >>= 1;\n    }\n    return (pixelBitWidth > 0 ? pixelBitWidth : 1);\n}\n\nfunction _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {\n    if (frame.interlaced) {\n        throw new GifError(\"writing interlaced GIFs is not supported\");\n    }\n    const frameInfo = _getIndexedImage(frameIndex, frame, palette);\n    const options = {\n        delay: frame.delayCentisecs,\n        disposal: frame.disposalMethod,\n        transparent: frameInfo.transparentIndex\n    };\n    if (isLocalPalette) {\n        _extendPaletteToPowerOf2(palette); // ok 'cause palette never used again\n        options.palette = palette.colors;\n    }\n    try {\n        let buffer = gifWriter.getOutputBuffer();\n        let startOfFrame = gifWriter.getOutputBufferPosition();\n        let endOfFrame;\n        let tryAgain = true;\n\n        while (tryAgain) {\n            endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset,\n                    frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);\n            tryAgain = false;\n            if (endOfFrame >= buffer.length - 1) {\n                const biggerBuffer = new Buffer(buffer.length * 1.5);\n                buffer.copy(biggerBuffer);\n                gifWriter.setOutputBuffer(biggerBuffer);\n                gifWriter.setOutputBufferPosition(startOfFrame);\n                buffer = biggerBuffer;\n                tryAgain = true;\n            }\n        }\n        return buffer;\n    }\n    catch (err) {\n        throw new GifError(err);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}