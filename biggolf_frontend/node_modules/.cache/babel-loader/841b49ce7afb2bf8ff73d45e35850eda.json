{"ast":null,"code":"exports.quote = function (xs) {\n  return xs.map(function (s) {\n    if (s && typeof s === 'object') {\n      return s.op.replace(/(.)/g, '\\\\$1');\n    } else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n      return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n    } else if (/[\"'\\s]/.test(s)) {\n      return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n    } else {\n      return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n    }\n  }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + ['\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n  TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\nexports.parse = function (s, env, opts) {\n  var mapped = parse(s, env, opts);\n  if (typeof env !== 'function') return mapped;\n  return mapped.reduce(function (acc, s) {\n    if (typeof s === 'object') return acc.concat(s);\n    var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n    if (xs.length === 1) return acc.concat(xs[0]);\n    return acc.concat(xs.filter(Boolean).map(function (x) {\n      if (RegExp('^' + TOKEN).test(x)) {\n        return JSON.parse(x.split(TOKEN)[1]);\n      } else return x;\n    }));\n  }, []);\n};\nfunction parse(s, env, opts) {\n  var chunker = new RegExp(['(' + CONTROL + ')',\n  // control chars\n  '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'].join('|'), 'g');\n  var match = s.match(chunker).filter(Boolean);\n  var commented = false;\n  if (!match) return [];\n  if (!env) env = {};\n  if (!opts) opts = {};\n  return match.map(function (s, j) {\n    if (commented) {\n      return;\n    }\n    if (RegExp('^' + CONTROL + '$').test(s)) {\n      return {\n        op: s\n      };\n    }\n\n    // Hand-written scanner/parser for Bash quoting rules:\n    //\n    //  1. inside single quotes, all characters are printed literally.\n    //  2. inside double quotes, all characters are printed literally\n    //     except variables prefixed by '$' and backslashes followed by\n    //     either a double quote or another backslash.\n    //  3. outside of any quotes, backslashes are treated as escape\n    //     characters and not printed (unless they are themselves escaped)\n    //  4. quote context can switch mid-token if there is no whitespace\n    //     between the two quote contexts (e.g. all'one'\"token\" parses as\n    //     \"allonetoken\")\n    var SQ = \"'\";\n    var DQ = '\"';\n    var DS = '$';\n    var BS = opts.escape || '\\\\';\n    var quote = false;\n    var esc = false;\n    var out = '';\n    var isGlob = false;\n    for (var i = 0, len = s.length; i < len; i++) {\n      var c = s.charAt(i);\n      isGlob = isGlob || !quote && (c === '*' || c === '?');\n      if (esc) {\n        out += c;\n        esc = false;\n      } else if (quote) {\n        if (c === quote) {\n          quote = false;\n        } else if (quote == SQ) {\n          out += c;\n        } else {\n          // Double quote\n          if (c === BS) {\n            i += 1;\n            c = s.charAt(i);\n            if (c === DQ || c === BS || c === DS) {\n              out += c;\n            } else {\n              out += BS + c;\n            }\n          } else if (c === DS) {\n            out += parseEnvVar();\n          } else {\n            out += c;\n          }\n        }\n      } else if (c === DQ || c === SQ) {\n        quote = c;\n      } else if (RegExp('^' + CONTROL + '$').test(c)) {\n        return {\n          op: s\n        };\n      } else if (RegExp('^#$').test(c)) {\n        commented = true;\n        if (out.length) {\n          return [out, {\n            comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n          }];\n        }\n        return [{\n          comment: s.slice(i + 1) + match.slice(j + 1).join(' ')\n        }];\n      } else if (c === BS) {\n        esc = true;\n      } else if (c === DS) {\n        out += parseEnvVar();\n      } else out += c;\n    }\n    if (isGlob) return {\n      op: 'glob',\n      pattern: out\n    };\n    return out;\n    function parseEnvVar() {\n      i += 1;\n      var varend, varname;\n      //debugger\n      if (s.charAt(i) === '{') {\n        i += 1;\n        if (s.charAt(i) === '}') {\n          throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n        }\n        varend = s.indexOf('}', i);\n        if (varend < 0) {\n          throw new Error(\"Bad substitution: \" + s.substr(i));\n        }\n        varname = s.substr(i, varend - i);\n        i = varend;\n      } else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n        varname = s.charAt(i);\n        i += 1;\n      } else {\n        varend = s.substr(i).match(/[^\\w\\d_]/);\n        if (!varend) {\n          varname = s.substr(i);\n          i = s.length;\n        } else {\n          varname = s.substr(i, varend.index);\n          i += varend.index - 1;\n        }\n      }\n      return getVar(null, '', varname);\n    }\n  })\n  // finalize parsed aruments\n  .reduce(function (prev, arg) {\n    if (arg === undefined) {\n      return prev;\n    }\n    return prev.concat(arg);\n  }, []);\n  function getVar(_, pre, key) {\n    var r = typeof env === 'function' ? env(key) : env[key];\n    if (r === undefined && key != '') r = '';else if (r === undefined) r = '$';\n    if (typeof r === 'object') {\n      return pre + TOKEN + JSON.stringify(r) + TOKEN;\n    } else return pre + r;\n  }\n}","map":{"version":3,"names":["exports","quote","xs","map","s","op","replace","test","String","join","CONTROL","META","BAREWORD","SINGLE_QUOTE","DOUBLE_QUOTE","TOKEN","i","Math","pow","random","toString","parse","env","opts","mapped","reduce","acc","concat","split","RegExp","length","filter","Boolean","x","JSON","chunker","match","commented","j","SQ","DQ","DS","BS","escape","esc","out","isGlob","len","c","charAt","parseEnvVar","comment","slice","pattern","varend","varname","Error","substr","indexOf","index","getVar","prev","arg","undefined","_","pre","key","r","stringify"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/shell-quote/index.js"],"sourcesContent":["exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}