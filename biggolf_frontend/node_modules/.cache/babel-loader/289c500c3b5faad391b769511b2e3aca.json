{"ast":null,"code":"var stream = require(\"stream\"),\n  constants = require(\"./constants\"),\n  util = require(\"util\");\nvar ReadableStreamBuffer = module.exports = function (opts) {\n  var that = this;\n  stream.Stream.call(this);\n  opts = opts || {};\n  var frequency = opts.hasOwnProperty(\"frequency\") ? opts.frequency : constants.DEFAULT_FREQUENCY;\n  var chunkSize = opts.chunkSize || constants.DEFAULT_CHUNK_SIZE;\n  var initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;\n  var incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;\n  var size = 0;\n  var buffer = new Buffer(initialSize);\n  var encoding = null;\n  this.readable = true;\n  this.writable = false;\n  var sendData = function () {\n    var amount = Math.min(chunkSize, size);\n    if (amount > 0) {\n      var chunk = null;\n      if (encoding) {\n        chunk = buffer.toString(encoding, 0, amount);\n      } else {\n        chunk = new Buffer(amount);\n        buffer.copy(chunk, 0, 0, amount);\n      }\n      that.emit(\"data\", chunk);\n      if (amount < buffer.length) buffer.copy(buffer, 0, amount, size);\n      size -= amount;\n    }\n    if (size === 0 && !that.readable) {\n      that.emit(\"end\");\n      that.emit(\"close\");\n      if (sendData && sendData.interval) {\n        clearInterval(sendData.interval);\n        sendData.interval = null;\n      }\n    }\n  };\n  this.size = function () {\n    return size;\n  };\n  this.maxSize = function () {\n    return buffer.length;\n  };\n  var increaseBufferIfNecessary = function (incomingDataSize) {\n    if (buffer.length - size < incomingDataSize) {\n      var factor = Math.ceil((incomingDataSize - (buffer.length - size)) / incrementAmount);\n      var newBuffer = new Buffer(buffer.length + incrementAmount * factor);\n      buffer.copy(newBuffer, 0, 0, size);\n      buffer = newBuffer;\n    }\n  };\n  this.put = function (data, encoding) {\n    if (!that.readable) return;\n    var wasEmpty = size === 0;\n    if (Buffer.isBuffer(data)) {\n      increaseBufferIfNecessary(data.length);\n      data.copy(buffer, size, 0);\n      size += data.length;\n    } else {\n      data = data + \"\";\n      var dataSizeInBytes = Buffer.byteLength(data);\n      increaseBufferIfNecessary(dataSizeInBytes);\n      buffer.write(data, size, encoding || \"utf8\");\n      size += dataSizeInBytes;\n    }\n    if (wasEmpty && size > 0) {\n      this.emit('readable');\n    }\n    if (!this.isPaused && !frequency) {\n      while (size > 0) {\n        sendData();\n      }\n    }\n  };\n  this.pause = function () {\n    this.isPaused = true;\n    if (sendData && sendData.interval) {\n      clearInterval(sendData.interval);\n      delete sendData.interval;\n    }\n  };\n  this.resume = function () {\n    this.isPaused = false;\n    if (sendData && !sendData.interval && frequency > 0) {\n      sendData.interval = setInterval(sendData, frequency);\n    }\n  };\n  this.destroy = function () {\n    that.emit(\"end\");\n    if (sendData.interval) clearInterval(sendData.interval);\n    sendData = null;\n    that.readable = false;\n    that.emit(\"close\");\n  };\n  this.destroySoon = function () {\n    that.readable = false;\n    if (!sendData.interval) {\n      that.emit(\"end\");\n      that.emit(\"close\");\n    }\n  };\n  this.setEncoding = function (_encoding) {\n    encoding = _encoding;\n  };\n  this.resume();\n};\nutil.inherits(ReadableStreamBuffer, stream.Stream);","map":{"version":3,"names":["stream","require","constants","util","ReadableStreamBuffer","module","exports","opts","that","Stream","call","frequency","hasOwnProperty","DEFAULT_FREQUENCY","chunkSize","DEFAULT_CHUNK_SIZE","initialSize","DEFAULT_INITIAL_SIZE","incrementAmount","DEFAULT_INCREMENT_AMOUNT","size","buffer","Buffer","encoding","readable","writable","sendData","amount","Math","min","chunk","toString","copy","emit","length","interval","clearInterval","maxSize","increaseBufferIfNecessary","incomingDataSize","factor","ceil","newBuffer","put","data","wasEmpty","isBuffer","dataSizeInBytes","byteLength","write","isPaused","pause","resume","setInterval","destroy","destroySoon","setEncoding","_encoding","inherits"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/stream-buffers/lib/readable_streambuffer.js"],"sourcesContent":["var stream = require(\"stream\"),\r\n\tconstants = require(\"./constants\"),\r\n\tutil = require(\"util\");\r\n\r\nvar ReadableStreamBuffer = module.exports = function(opts) {\r\n\tvar that = this;\r\n\r\n\tstream.Stream.call(this);\r\n\r\n\topts = opts || {};\r\n\tvar frequency = opts.hasOwnProperty(\"frequency\") ? opts.frequency : constants.DEFAULT_FREQUENCY;\r\n\tvar chunkSize = opts.chunkSize || constants.DEFAULT_CHUNK_SIZE;\r\n\tvar initialSize = opts.initialSize || constants.DEFAULT_INITIAL_SIZE;\r\n\tvar incrementAmount = opts.incrementAmount || constants.DEFAULT_INCREMENT_AMOUNT;\r\n\r\n\tvar size = 0;\r\n\tvar buffer = new Buffer(initialSize);\r\n\tvar encoding = null;\r\n\r\n\tthis.readable = true;\r\n\tthis.writable = false;\r\n\r\n\tvar sendData = function() {\r\n\t\tvar amount = Math.min(chunkSize, size);\r\n\r\n\t\tif (amount > 0) {\r\n\t\t\tvar chunk = null;\r\n\t\t\tif(encoding) {\r\n\t\t\t\tchunk = buffer.toString(encoding, 0, amount);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tchunk = new Buffer(amount);\r\n\t\t\t\tbuffer.copy(chunk, 0, 0, amount);\r\n\t\t\t}\r\n\r\n\t\t\tthat.emit(\"data\", chunk);\r\n\r\n\t\t\tif(amount < buffer.length)\r\n\t\t\t\tbuffer.copy(buffer, 0, amount, size);\r\n\t\t\tsize -= amount;\r\n\t\t}\r\n\r\n\t\tif(size === 0 && !that.readable) {\r\n\t\t\tthat.emit(\"end\");\r\n\t\t\tthat.emit(\"close\");\r\n\t\t\tif (sendData && sendData.interval) {\r\n\t\t\t\tclearInterval(sendData.interval);\r\n\t\t\t\tsendData.interval = null;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.size = function() {\r\n\t\treturn size;\r\n\t};\r\n\r\n\tthis.maxSize = function() {\r\n\t\treturn buffer.length;\r\n\t};\r\n\r\n\tvar increaseBufferIfNecessary = function(incomingDataSize) {\r\n\t\tif((buffer.length - size) < incomingDataSize) {\r\n\t\t\tvar factor = Math.ceil((incomingDataSize - (buffer.length - size)) / incrementAmount);\r\n\r\n\t\t\tvar newBuffer = new Buffer(buffer.length + (incrementAmount * factor));\r\n\t\t\tbuffer.copy(newBuffer, 0, 0, size);\r\n\t\t\tbuffer = newBuffer;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.put = function(data, encoding) {\r\n\t\tif(!that.readable) return;\r\n\r\n\t\tvar wasEmpty = size === 0;\r\n\t\tif(Buffer.isBuffer(data)) {\r\n\t\t\tincreaseBufferIfNecessary(data.length);\r\n\t\t\tdata.copy(buffer, size, 0);\r\n\t\t\tsize += data.length;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdata = data + \"\";\r\n\t\t\tvar dataSizeInBytes = Buffer.byteLength(data);\r\n\t\t\tincreaseBufferIfNecessary(dataSizeInBytes);\r\n\t\t\tbuffer.write(data, size, encoding || \"utf8\");\r\n\t\t\tsize += dataSizeInBytes;\r\n\t\t}\r\n\r\n\t\tif (wasEmpty && size > 0) {\r\n\t\t\tthis.emit('readable')\r\n\t\t}\r\n\r\n\t\tif (!this.isPaused && !frequency) {\r\n\t\t\twhile (size > 0) {\r\n\t\t\t\tsendData();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.pause = function() {\r\n\t\tthis.isPaused = true;\r\n\t\tif(sendData && sendData.interval) {\r\n\t\t\tclearInterval(sendData.interval);\r\n\t\t\tdelete sendData.interval;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.resume = function() {\r\n\t\tthis.isPaused = false;\r\n\t\tif(sendData && !sendData.interval && frequency > 0) {\r\n\t\t\tsendData.interval = setInterval(sendData, frequency);\r\n\t\t}\r\n\t};\r\n\r\n\tthis.destroy = function() {\r\n\t\tthat.emit(\"end\");\r\n\t\tif(sendData.interval) clearInterval(sendData.interval);\r\n\t\tsendData = null;\r\n\t\tthat.readable = false;\r\n\t\tthat.emit(\"close\");\r\n\t};\r\n\r\n\tthis.destroySoon = function() {\r\n\t\tthat.readable = false;\r\n\t\tif (!sendData.interval) {\r\n\t\t\tthat.emit(\"end\");\r\n\t\t\tthat.emit(\"close\");\r\n\t\t}\r\n\t};\r\n\r\n\tthis.setEncoding = function(_encoding) {\r\n\t\tencoding = _encoding;\r\n\t};\r\n\r\n\tthis.resume();\r\n};\r\nutil.inherits(ReadableStreamBuffer, stream.Stream);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}