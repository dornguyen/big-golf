{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar DOMParser = require('xmldom').DOMParser;\n\n/**\n * Module exports.\n */\n\nexports.parse = parse;\nvar TEXT_NODE = 3;\nvar CDATA_NODE = 4;\nvar COMMENT_NODE = 8;\n\n/**\n * We ignore raw text (usually whitespace), <!-- xml comments -->,\n * and raw CDATA nodes.\n *\n * @param {Element} node\n * @returns {Boolean}\n * @api private\n */\n\nfunction shouldIgnoreNode(node) {\n  return node.nodeType === TEXT_NODE || node.nodeType === COMMENT_NODE || node.nodeType === CDATA_NODE;\n}\n\n/**\n * Check if the node is empty. Some plist file has such node:\n * <key />\n * this node shoud be ignored.\n *\n * @see https://github.com/TooTallNate/plist.js/issues/66\n * @param {Element} node\n * @returns {Boolean}\n * @api private\n */\nfunction isEmptyNode(node) {\n  if (!node.childNodes || node.childNodes.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction invariant(test, message) {\n  if (!test) {\n    throw new Error(message);\n  }\n}\n\n/**\n * Parses a Plist XML string. Returns an Object.\n *\n * @param {String} xml - the XML String to decode\n * @returns {Mixed} the decoded value from the Plist XML\n * @api public\n */\n\nfunction parse(xml) {\n  var doc = new DOMParser().parseFromString(xml);\n  invariant(doc.documentElement.nodeName === 'plist', 'malformed document. First element should be <plist>');\n  var plist = parsePlistXML(doc.documentElement);\n\n  // the root <plist> node gets interpreted as an Array,\n  // so pull out the inner data first\n  if (plist.length == 1) plist = plist[0];\n  return plist;\n}\n\n/**\n * Convert an XML based plist document into a JSON representation.\n *\n * @param {Object} xml_node - current XML node in the plist\n * @returns {Mixed} built up JSON object\n * @api private\n */\n\nfunction parsePlistXML(node) {\n  var i, new_obj, key, val, new_arr, res, counter, type;\n  if (!node) return null;\n  if (node.nodeName === 'plist') {\n    new_arr = [];\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        new_arr.push(parsePlistXML(node.childNodes[i]));\n      }\n    }\n    return new_arr;\n  } else if (node.nodeName === 'dict') {\n    new_obj = {};\n    key = null;\n    counter = 0;\n    if (isEmptyNode(node)) {\n      return new_obj;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (shouldIgnoreNode(node.childNodes[i])) continue;\n      if (counter % 2 === 0) {\n        invariant(node.childNodes[i].nodeName === 'key', 'Missing key while parsing <dict/>.');\n        key = parsePlistXML(node.childNodes[i]);\n      } else {\n        invariant(node.childNodes[i].nodeName !== 'key', 'Unexpected key \"' + parsePlistXML(node.childNodes[i]) + '\" while parsing <dict/>.');\n        new_obj[key] = parsePlistXML(node.childNodes[i]);\n      }\n      counter += 1;\n    }\n    if (counter % 2 === 1) {\n      throw new Error('Missing value for \"' + key + '\" while parsing <dict/>');\n    }\n    return new_obj;\n  } else if (node.nodeName === 'array') {\n    new_arr = [];\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        res = parsePlistXML(node.childNodes[i]);\n        if (null != res) new_arr.push(res);\n      }\n    }\n    return new_arr;\n  } else if (node.nodeName === '#text') {\n    // TODO: what should we do with text types? (CDATA sections)\n  } else if (node.nodeName === 'key') {\n    if (isEmptyNode(node)) {\n      return '';\n    }\n    return node.childNodes[0].nodeValue;\n  } else if (node.nodeName === 'string') {\n    res = '';\n    if (isEmptyNode(node)) {\n      return res;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      var type = node.childNodes[i].nodeType;\n      if (type === TEXT_NODE || type === CDATA_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n    return res;\n  } else if (node.nodeName === 'integer') {\n    invariant(!isEmptyNode(node), 'Cannot parse \"\" as integer.');\n    return parseInt(node.childNodes[0].nodeValue, 10);\n  } else if (node.nodeName === 'real') {\n    invariant(!isEmptyNode(node), 'Cannot parse \"\" as real.');\n    res = '';\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n    return parseFloat(res);\n  } else if (node.nodeName === 'data') {\n    res = '';\n    if (isEmptyNode(node)) {\n      return Buffer.from(res, 'base64');\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue.replace(/\\s+/g, '');\n      }\n    }\n    return Buffer.from(res, 'base64');\n  } else if (node.nodeName === 'date') {\n    invariant(!isEmptyNode(node), 'Cannot parse \"\" as Date.');\n    return new Date(node.childNodes[0].nodeValue);\n  } else if (node.nodeName === 'true') {\n    return true;\n  } else if (node.nodeName === 'false') {\n    return false;\n  }\n}","map":{"version":3,"names":["DOMParser","require","exports","parse","TEXT_NODE","CDATA_NODE","COMMENT_NODE","shouldIgnoreNode","node","nodeType","isEmptyNode","childNodes","length","invariant","test","message","Error","xml","doc","parseFromString","documentElement","nodeName","plist","parsePlistXML","i","new_obj","key","val","new_arr","res","counter","type","push","nodeValue","parseInt","parseFloat","Buffer","from","replace","Date"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/plist/lib/parse.js"],"sourcesContent":["/**\n * Module dependencies.\n */\n\nvar DOMParser = require('xmldom').DOMParser;\n\n/**\n * Module exports.\n */\n\nexports.parse = parse;\n\nvar TEXT_NODE = 3;\nvar CDATA_NODE = 4;\nvar COMMENT_NODE = 8;\n\n\n/**\n * We ignore raw text (usually whitespace), <!-- xml comments -->,\n * and raw CDATA nodes.\n *\n * @param {Element} node\n * @returns {Boolean}\n * @api private\n */\n\nfunction shouldIgnoreNode (node) {\n  return node.nodeType === TEXT_NODE\n    || node.nodeType === COMMENT_NODE\n    || node.nodeType === CDATA_NODE;\n}\n\n/**\n * Check if the node is empty. Some plist file has such node:\n * <key />\n * this node shoud be ignored.\n *\n * @see https://github.com/TooTallNate/plist.js/issues/66\n * @param {Element} node\n * @returns {Boolean}\n * @api private\n */\nfunction isEmptyNode(node){\n  if(!node.childNodes || node.childNodes.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction invariant(test, message) {\n  if (!test) {\n    throw new Error(message);\n  }\n}\n\n/**\n * Parses a Plist XML string. Returns an Object.\n *\n * @param {String} xml - the XML String to decode\n * @returns {Mixed} the decoded value from the Plist XML\n * @api public\n */\n\nfunction parse (xml) {\n  var doc = new DOMParser().parseFromString(xml);\n  invariant(\n    doc.documentElement.nodeName === 'plist',\n    'malformed document. First element should be <plist>'\n  );\n  var plist = parsePlistXML(doc.documentElement);\n\n  // the root <plist> node gets interpreted as an Array,\n  // so pull out the inner data first\n  if (plist.length == 1) plist = plist[0];\n\n  return plist;\n}\n\n/**\n * Convert an XML based plist document into a JSON representation.\n *\n * @param {Object} xml_node - current XML node in the plist\n * @returns {Mixed} built up JSON object\n * @api private\n */\n\nfunction parsePlistXML (node) {\n  var i, new_obj, key, val, new_arr, res, counter, type;\n\n  if (!node)\n    return null;\n\n  if (node.nodeName === 'plist') {\n    new_arr = [];\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n    for (i=0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        new_arr.push( parsePlistXML(node.childNodes[i]));\n      }\n    }\n    return new_arr;\n  } else if (node.nodeName === 'dict') {\n    new_obj = {};\n    key = null;\n    counter = 0;\n    if (isEmptyNode(node)) {\n      return new_obj;\n    }\n    for (i=0; i < node.childNodes.length; i++) {\n      if (shouldIgnoreNode(node.childNodes[i])) continue;\n      if (counter % 2 === 0) {\n        invariant(\n          node.childNodes[i].nodeName === 'key',\n          'Missing key while parsing <dict/>.'\n        );\n        key = parsePlistXML(node.childNodes[i]);\n      } else {\n        invariant(\n          node.childNodes[i].nodeName !== 'key',\n          'Unexpected key \"'\n            + parsePlistXML(node.childNodes[i])\n            + '\" while parsing <dict/>.'\n        );\n        new_obj[key] = parsePlistXML(node.childNodes[i]);\n      }\n      counter += 1;\n    }\n    if (counter % 2 === 1) {\n      throw new Error('Missing value for \"' + key + '\" while parsing <dict/>');\n    }\n    return new_obj;\n\n  } else if (node.nodeName === 'array') {\n    new_arr = [];\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n    for (i=0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        res = parsePlistXML(node.childNodes[i]);\n        if (null != res) new_arr.push(res);\n      }\n    }\n    return new_arr;\n\n  } else if (node.nodeName === '#text') {\n    // TODO: what should we do with text types? (CDATA sections)\n\n  } else if (node.nodeName === 'key') {\n    if (isEmptyNode(node)) {\n      return '';\n    }\n    return node.childNodes[0].nodeValue;\n  } else if (node.nodeName === 'string') {\n    res = '';\n    if (isEmptyNode(node)) {\n      return res;\n    }\n    for (i=0; i < node.childNodes.length; i++) {\n      var type = node.childNodes[i].nodeType;\n      if (type === TEXT_NODE || type === CDATA_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n    return res;\n\n  } else if (node.nodeName === 'integer') {\n    invariant(\n      !isEmptyNode(node),\n      'Cannot parse \"\" as integer.'\n    );\n    return parseInt(node.childNodes[0].nodeValue, 10);\n\n  } else if (node.nodeName === 'real') {\n    invariant(\n      !isEmptyNode(node),\n      'Cannot parse \"\" as real.'\n    );\n    res = '';\n    for (i=0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n    return parseFloat(res);\n\n  } else if (node.nodeName === 'data') {\n    res = '';\n    if (isEmptyNode(node)) {\n      return Buffer.from(res, 'base64');\n    }\n    for (i=0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue.replace(/\\s+/g, '');\n      }\n    }\n    return Buffer.from(res, 'base64');\n\n  } else if (node.nodeName === 'date') {\n    invariant(\n      !isEmptyNode(node),\n      'Cannot parse \"\" as Date.'\n    )\n    return new Date(node.childNodes[0].nodeValue);\n\n  } else if (node.nodeName === 'true') {\n    return true;\n\n  } else if (node.nodeName === 'false') {\n    return false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}