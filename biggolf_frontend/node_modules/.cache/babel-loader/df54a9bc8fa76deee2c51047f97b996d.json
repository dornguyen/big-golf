{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasContent = hasContent;\nexports.hasValue = hasValue;\nexports.escapeSpace = escapeSpace;\nexports.escapeSpecialChars = escapeSpecialChars;\nexports.localIp = localIp;\nexports.cancellableDelay = cancellableDelay;\nexports.multiResolve = multiResolve;\nexports.safeJsonParse = safeJsonParse;\nexports.wrapElement = wrapElement;\nexports.unwrapElement = unwrapElement;\nexports.filterObject = filterObject;\nexports.toReadableSizeString = toReadableSizeString;\nexports.isSubPath = isSubPath;\nexports.isSameDestination = isSameDestination;\nexports.compareVersions = compareVersions;\nexports.coerceVersion = coerceVersion;\nexports.quote = quote;\nexports.unleakString = unleakString;\nexports.jsonStringify = jsonStringify;\nexports.pluralize = pluralize;\nexports.toInMemoryBase64 = toInMemoryBase64;\nexports.getLockFileGuard = getLockFileGuard;\nObject.defineProperty(exports, \"shellParse\", {\n  enumerable: true,\n  get: function () {\n    return _shellQuote.parse;\n  }\n});\nObject.defineProperty(exports, \"uuidV1\", {\n  enumerable: true,\n  get: function () {\n    return _uuid.v1;\n  }\n});\nObject.defineProperty(exports, \"uuidV3\", {\n  enumerable: true,\n  get: function () {\n    return _uuid.v3;\n  }\n});\nObject.defineProperty(exports, \"uuidV4\", {\n  enumerable: true,\n  get: function () {\n    return _uuid.v4;\n  }\n});\nObject.defineProperty(exports, \"uuidV5\", {\n  enumerable: true,\n  get: function () {\n    return _uuid.v5;\n  }\n});\nexports.KiB = exports.MiB = exports.GiB = exports.W3C_WEB_ELEMENT_IDENTIFIER = void 0;\nrequire(\"source-map-support/register\");\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _os = _interopRequireDefault(require(\"os\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _fs = _interopRequireDefault(require(\"./fs\"));\nvar _semver = _interopRequireDefault(require(\"semver\"));\nvar _shellQuote = require(\"shell-quote\");\nvar _pluralize = _interopRequireDefault(require(\"pluralize\"));\nvar _stream = _interopRequireDefault(require(\"stream\"));\nvar _base64Stream = require(\"base64-stream\");\nvar _uuid = require(\"uuid\");\nvar _lockfile2 = _interopRequireDefault(require(\"lockfile\"));\nconst W3C_WEB_ELEMENT_IDENTIFIER = 'element-6066-11e4-a52e-4f735466cecf';\nexports.W3C_WEB_ELEMENT_IDENTIFIER = W3C_WEB_ELEMENT_IDENTIFIER;\nconst KiB = 1024;\nexports.KiB = KiB;\nconst MiB = KiB * 1024;\nexports.MiB = MiB;\nconst GiB = MiB * 1024;\nexports.GiB = GiB;\nfunction hasContent(val) {\n  return _lodash.default.isString(val) && val !== '';\n}\nfunction hasValue(val) {\n  let hasVal = false;\n  if (_lodash.default.isNumber(val)) {\n    hasVal = !_lodash.default.isNaN(val);\n  } else {\n    hasVal = !_lodash.default.isUndefined(val) && !_lodash.default.isNull(val);\n  }\n  return hasVal;\n}\nfunction escapeSpace(str) {\n  return str.split(/ /).join('\\\\ ');\n}\nfunction escapeSpecialChars(str, quoteEscape) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  if (typeof quoteEscape === 'undefined') {\n    quoteEscape = false;\n  }\n  str = str.replace(/[\\\\]/g, '\\\\\\\\').replace(/[\\/]/g, '\\\\/').replace(/[\\b]/g, '\\\\b').replace(/[\\f]/g, '\\\\f').replace(/[\\n]/g, '\\\\n').replace(/[\\r]/g, '\\\\r').replace(/[\\t]/g, '\\\\t').replace(/[\\\"]/g, '\\\\\"').replace(/\\\\'/g, \"\\\\'\");\n  if (quoteEscape) {\n    let re = new RegExp(quoteEscape, 'g');\n    str = str.replace(re, `\\\\${quoteEscape}`);\n  }\n  return str;\n}\nfunction localIp() {\n  let ip = _lodash.default.chain(_os.default.networkInterfaces()).values().flatten().filter(function (val) {\n    return val.family === 'IPv4' && val.internal === false;\n  }).map('address').first().value();\n  return ip;\n}\nfunction cancellableDelay(ms) {\n  let timer;\n  let resolve;\n  let reject;\n  const delay = new _bluebird.default.Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n    timer = setTimeout(function () {\n      resolve();\n    }, ms);\n  });\n  delay.cancel = function () {\n    clearTimeout(timer);\n    reject(new _bluebird.default.CancellationError());\n  };\n  return delay;\n}\nfunction multiResolve(roots) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return roots.map(root => _path.default.resolve(root, ...args));\n}\nfunction safeJsonParse(obj) {\n  try {\n    return JSON.parse(obj);\n  } catch (ign) {\n    return obj;\n  }\n}\nfunction jsonStringify(obj, replacer) {\n  let space = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  if (!_lodash.default.isFunction(replacer)) {\n    replacer = (k, v) => v;\n  }\n  const bufferToJSON = Buffer.prototype.toJSON;\n  delete Buffer.prototype.toJSON;\n  try {\n    return JSON.stringify(obj, (key, value) => {\n      const updatedValue = Buffer.isBuffer(value) ? value.toString('utf8') : value;\n      return replacer(key, updatedValue);\n    }, space);\n  } finally {\n    Buffer.prototype.toJSON = bufferToJSON;\n  }\n}\nfunction unwrapElement(el) {\n  for (const propName of [W3C_WEB_ELEMENT_IDENTIFIER, 'ELEMENT']) {\n    if (_lodash.default.has(el, propName)) {\n      return el[propName];\n    }\n  }\n  return el;\n}\nfunction wrapElement(elementId) {\n  return {\n    ELEMENT: elementId,\n    [W3C_WEB_ELEMENT_IDENTIFIER]: elementId\n  };\n}\nfunction filterObject(obj, predicate) {\n  let newObj = _lodash.default.clone(obj);\n  if (_lodash.default.isUndefined(predicate)) {\n    predicate = v => !_lodash.default.isUndefined(v);\n  } else if (!_lodash.default.isFunction(predicate)) {\n    const valuePredicate = predicate;\n    predicate = v => v === valuePredicate;\n  }\n  for (const key of Object.keys(obj)) {\n    if (!predicate(obj[key], obj)) {\n      delete newObj[key];\n    }\n  }\n  return newObj;\n}\nfunction toReadableSizeString(bytes) {\n  const intBytes = parseInt(bytes, 10);\n  if (isNaN(intBytes) || intBytes < 0) {\n    throw new Error(`Cannot convert '${bytes}' to a readable size format`);\n  }\n  if (intBytes >= GiB) {\n    return `${parseFloat(intBytes / (GiB * 1.0)).toFixed(2)} GB`;\n  } else if (intBytes >= MiB) {\n    return `${parseFloat(intBytes / (MiB * 1.0)).toFixed(2)} MB`;\n  } else if (intBytes >= KiB) {\n    return `${parseFloat(intBytes / (KiB * 1.0)).toFixed(2)} KB`;\n  }\n  return `${intBytes} B`;\n}\nfunction isSubPath(originalPath, root) {\n  let forcePosix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const pathObj = forcePosix ? _path.default.posix : _path.default;\n  for (const p of [originalPath, root]) {\n    if (!pathObj.isAbsolute(p)) {\n      throw new Error(`'${p}' is expected to be an absolute path`);\n    }\n  }\n  const normalizedRoot = pathObj.normalize(root);\n  const normalizedPath = pathObj.normalize(originalPath);\n  return normalizedPath.startsWith(normalizedRoot);\n}\nasync function isSameDestination(path1, path2) {\n  for (var _len2 = arguments.length, pathN = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    pathN[_key2 - 2] = arguments[_key2];\n  }\n  const allPaths = [path1, path2, ...pathN];\n  if (!(await _bluebird.default.reduce(allPaths, async (a, b) => a && (await _fs.default.exists(b)), true))) {\n    return false;\n  }\n  const areAllItemsEqual = arr => !!arr.reduce((a, b) => a === b ? a : NaN);\n  if (areAllItemsEqual(allPaths)) {\n    return true;\n  }\n  let mapCb = async x => await _fs.default.stat(x, {\n    bigint: true\n  }).ino;\n  if (_semver.default.lt(process.version, '10.5.0')) {\n    mapCb = async x => await _fs.default.stat(x).ino;\n  }\n  return areAllItemsEqual(await _bluebird.default.map(allPaths, mapCb));\n}\nfunction coerceVersion(ver) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const result = _semver.default.valid(_semver.default.coerce(`${ver}`));\n  if (strict && !result) {\n    throw new Error(`'${ver}' cannot be coerced to a valid version number`);\n  }\n  return result;\n}\nconst SUPPORTED_OPERATORS = ['==', '!=', '>', '<', '>=', '<=', '='];\nfunction compareVersions(ver1, operator, ver2) {\n  if (!SUPPORTED_OPERATORS.includes(operator)) {\n    throw new Error(`The '${operator}' comparison operator is not supported. ` + `Only '${JSON.stringify(SUPPORTED_OPERATORS)}' operators are supported`);\n  }\n  const semverOperator = ['==', '!='].includes(operator) ? '=' : operator;\n  const result = _semver.default.satisfies(coerceVersion(ver1), `${semverOperator}${coerceVersion(ver2)}`);\n  return operator === '!=' ? !result : result;\n}\nfunction quote(args) {\n  return (0, _shellQuote.quote)(args);\n}\nfunction unleakString(s) {\n  return ` ${s}`.substr(1);\n}\nfunction pluralize(word, count) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let inclusive = false;\n  if (_lodash.default.isBoolean(options)) {\n    inclusive = options;\n  } else if (_lodash.default.isBoolean(options === null || options === void 0 ? void 0 : options.inclusive)) {\n    inclusive = options.inclusive;\n  }\n  return (0, _pluralize.default)(word, count, inclusive);\n}\nasync function toInMemoryBase64(srcPath) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!(await _fs.default.exists(srcPath)) || (await _fs.default.stat(srcPath)).isDirectory()) {\n    throw new Error(`No such file: ${srcPath}`);\n  }\n  const {\n    maxSize = 1 * GiB\n  } = opts;\n  const resultBuffers = [];\n  let resultBuffersSize = 0;\n  const resultWriteStream = new _stream.default.Writable({\n    write: (buffer, encoding, next) => {\n      resultBuffers.push(buffer);\n      resultBuffersSize += buffer.length;\n      if (maxSize > 0 && resultBuffersSize > maxSize) {\n        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `buffer must not be greater than ${toReadableSizeString(maxSize)}`));\n      }\n      next();\n    }\n  });\n  const readerStream = _fs.default.createReadStream(srcPath);\n  const base64EncoderStream = new _base64Stream.Base64Encode();\n  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {\n    resultWriteStream.once('error', e => {\n      readerStream.unpipe(base64EncoderStream);\n      base64EncoderStream.unpipe(resultWriteStream);\n      readerStream.destroy();\n      reject(e);\n    });\n    resultWriteStream.once('finish', resolve);\n  });\n  const readStreamPromise = new _bluebird.default((resolve, reject) => {\n    readerStream.once('close', resolve);\n    readerStream.once('error', e => reject(new Error(`Failed to read '${srcPath}': ${e.message}`)));\n  });\n  readerStream.pipe(base64EncoderStream);\n  base64EncoderStream.pipe(resultWriteStream);\n  await _bluebird.default.all([readStreamPromise, resultWriteStreamPromise]);\n  return Buffer.concat(resultBuffers);\n}\nfunction getLockFileGuard(lockFile) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    timeout = 120,\n    tryRecovery = false\n  } = opts;\n  const lock = _bluebird.default.promisify(_lockfile2.default.lock);\n  const check = _bluebird.default.promisify(_lockfile2.default.check);\n  const unlock = _bluebird.default.promisify(_lockfile2.default.unlock);\n  const guard = async behavior => {\n    let triedRecovery = false;\n    do {\n      try {\n        if (_lockfile2.default.checkSync(lockFile)) {\n          await lock(lockFile, {\n            wait: timeout * 1000\n          });\n        } else {\n          _lockfile2.default.lockSync(lockFile);\n        }\n        break;\n      } catch (e) {\n        if (_lodash.default.includes(e.message, 'EEXIST') && tryRecovery && !triedRecovery) {\n          _lockfile2.default.unlockSync(lockFile);\n          triedRecovery = true;\n          continue;\n        }\n        throw new Error(`Could not acquire lock on '${lockFile}' after ${timeout}s. ` + `Original error: ${e.message}`);\n      }\n    } while (true);\n    try {\n      return await behavior();\n    } finally {\n      await unlock(lockFile);\n    }\n  };\n  guard.check = async () => await check(lockFile);\n  return guard;\n}\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["W3C_WEB_ELEMENT_IDENTIFIER","KiB","MiB","GiB","hasContent","val","_","isString","hasValue","hasVal","isNumber","isNaN","isUndefined","isNull","escapeSpace","str","split","join","escapeSpecialChars","quoteEscape","replace","re","RegExp","localIp","ip","chain","os","networkInterfaces","values","flatten","filter","family","internal","map","first","value","cancellableDelay","ms","timer","resolve","reject","delay","B","Promise","_resolve","_reject","setTimeout","cancel","clearTimeout","CancellationError","multiResolve","roots","args","root","path","safeJsonParse","obj","JSON","parse","ign","jsonStringify","replacer","space","isFunction","k","v","bufferToJSON","Buffer","prototype","toJSON","stringify","key","updatedValue","isBuffer","toString","unwrapElement","el","propName","has","wrapElement","elementId","ELEMENT","filterObject","predicate","newObj","clone","valuePredicate","Object","keys","toReadableSizeString","bytes","intBytes","parseInt","Error","parseFloat","toFixed","isSubPath","originalPath","forcePosix","pathObj","posix","p","isAbsolute","normalizedRoot","normalize","normalizedPath","startsWith","isSameDestination","path1","path2","pathN","allPaths","reduce","a","b","fs","exists","areAllItemsEqual","arr","NaN","mapCb","x","stat","bigint","ino","semver","lt","process","version","coerceVersion","ver","strict","result","valid","coerce","SUPPORTED_OPERATORS","compareVersions","ver1","operator","ver2","includes","semverOperator","satisfies","quote","unleakString","s","substr","pluralize","word","count","options","inclusive","isBoolean","toInMemoryBase64","srcPath","opts","isDirectory","maxSize","resultBuffers","resultBuffersSize","resultWriteStream","stream","Writable","write","buffer","encoding","next","push","length","emit","readerStream","createReadStream","base64EncoderStream","Base64Encode","resultWriteStreamPromise","once","e","unpipe","destroy","readStreamPromise","message","pipe","all","concat","getLockFileGuard","lockFile","timeout","tryRecovery","lock","promisify","_lockfile","check","unlock","guard","behavior","triedRecovery","checkSync","wait","lockSync","unlockSync","require"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\util.js"],"sourcesContent":["import B from 'bluebird';\nimport _ from 'lodash';\nimport os from 'os';\nimport path from 'path';\nimport fs from './fs';\nimport semver from 'semver';\nimport {\n  // https://www.npmjs.com/package/shell-quote\n  quote as shellQuote,\n  parse as shellParse,\n} from 'shell-quote';\nimport pluralizeLib from 'pluralize';\nimport stream from 'stream';\nimport { Base64Encode } from 'base64-stream';\nimport {\n  // https://www.npmjs.com/package/uuid\n  v1 as uuidV1, v3 as uuidV3,\n  v4 as uuidV4, v5 as uuidV5\n} from 'uuid';\nimport _lockfile from 'lockfile';\n\n\nconst W3C_WEB_ELEMENT_IDENTIFIER = 'element-6066-11e4-a52e-4f735466cecf';\nconst KiB = 1024;\nconst MiB = KiB * 1024;\nconst GiB = MiB * 1024;\n\nexport function hasContent (val) {\n  return _.isString(val) && val !== '';\n}\n\n// return true if the the value is not undefined, null, or NaN.\nfunction hasValue (val) {\n  let hasVal = false;\n  // avoid incorrectly evaluating `0` as false\n  if (_.isNumber(val)) {\n    hasVal = !_.isNaN(val);\n  } else {\n    hasVal = !_.isUndefined(val) && !_.isNull(val);\n  }\n\n  return hasVal;\n}\n\n// escape spaces in string, for commandline calls\nfunction escapeSpace (str) {\n  return str.split(/ /).join('\\\\ ');\n}\n\nfunction escapeSpecialChars (str, quoteEscape) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  if (typeof quoteEscape === 'undefined') {\n    quoteEscape = false;\n  }\n  str = str\n    .replace(/[\\\\]/g, '\\\\\\\\')\n    .replace(/[\\/]/g, '\\\\/') // eslint-disable-line no-useless-escape\n    .replace(/[\\b]/g, '\\\\b')\n    .replace(/[\\f]/g, '\\\\f')\n    .replace(/[\\n]/g, '\\\\n')\n    .replace(/[\\r]/g, '\\\\r')\n    .replace(/[\\t]/g, '\\\\t')\n    .replace(/[\\\"]/g, '\\\\\"') // eslint-disable-line no-useless-escape\n    .replace(/\\\\'/g, \"\\\\'\");\n  if (quoteEscape) {\n    let re = new RegExp(quoteEscape, 'g');\n    str = str.replace(re, `\\\\${quoteEscape}`);\n  }\n  return str;\n}\n\nfunction localIp () {\n  let ip = _.chain(os.networkInterfaces())\n    .values()\n    .flatten()\n    .filter(function (val) {\n      return (val.family === 'IPv4' && val.internal === false);\n    })\n    .map('address')\n    .first()\n    .value();\n  return ip;\n}\n\n/*\n * Creates a promise that is cancellable, and will timeout\n * after `ms` delay\n */\nfunction cancellableDelay (ms) {\n  let timer;\n  let resolve;\n  let reject;\n\n  const delay = new B.Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n    timer = setTimeout(function () {\n      resolve();\n    }, ms);\n  });\n\n  // override Bluebird's `cancel`, which does not work when using `await` on\n  // a promise, since `resolve`/`reject` are never called\n  delay.cancel = function () {\n    clearTimeout(timer);\n    reject(new B.CancellationError());\n  };\n  return delay;\n}\n\nfunction multiResolve (roots, ...args) {\n  return roots.map((root) => path.resolve(root, ...args));\n}\n\n/*\n * Parses an object if possible. Otherwise returns the object without parsing.\n */\nfunction safeJsonParse (obj) {\n  try {\n    return JSON.parse(obj);\n  } catch (ign) {\n    // ignore: this is not json parsable\n    return obj;\n  }\n}\n\n/*\n * Stringifies the object passed in, converting Buffers into Strings for better\n * display. This mimics JSON.stringify (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * except the `replacer` argument can only be a function.\n *\n * @param {object} obj - the object to be serialized\n * @param {?function} replacer - function to transform the properties added to the\n *                               serialized object\n * @param {?number|string} space - used to insert white space into the output JSON\n *                                 string for readability purposes. Defaults to 2\n * returns {string} - the JSON object serialized as a string\n */\nfunction jsonStringify (obj, replacer, space = 2) {\n  // if no replacer is passed, or it is not a function, just use a pass-through\n  if (!_.isFunction(replacer)) {\n    replacer = (k, v) => v;\n  }\n\n  // Buffers cannot be serialized in a readable way\n  const bufferToJSON = Buffer.prototype.toJSON;\n  delete Buffer.prototype.toJSON;\n  try {\n    return JSON.stringify(obj, (key, value) => {\n      const updatedValue = Buffer.isBuffer(value)\n        ? value.toString('utf8')\n        : value;\n      return replacer(key, updatedValue);\n    }, space);\n  } finally {\n    // restore the function, so as to not break further serialization\n    Buffer.prototype.toJSON = bufferToJSON;\n  }\n}\n\n/*\n * Removes the wrapper from element, if it exists.\n *   { ELEMENT: 4 } becomes 4\n *   { element-6066-11e4-a52e-4f735466cecf: 5 } becomes 5\n */\nfunction unwrapElement (el) {\n  for (const propName of [W3C_WEB_ELEMENT_IDENTIFIER, 'ELEMENT']) {\n    if (_.has(el, propName)) {\n      return el[propName];\n    }\n  }\n  return el;\n}\n\nfunction wrapElement (elementId) {\n  return {\n    ELEMENT: elementId,\n    [W3C_WEB_ELEMENT_IDENTIFIER]: elementId,\n  };\n}\n\n/*\n * Returns object consisting of all properties in the original element\n * which were truthy given the predicate.\n * If the predicate is\n *   * missing - it will remove all properties whose values are `undefined`\n *   * a scalar - it will test all properties' values against that value\n *   * a function - it will pass each value and the original object into the function\n */\nfunction filterObject (obj, predicate) {\n  let newObj = _.clone(obj);\n  if (_.isUndefined(predicate)) {\n    // remove any element from the object whose value is undefined\n    predicate = (v) => !_.isUndefined(v);\n  } else if (!_.isFunction(predicate)) {\n    // make predicate into a function\n    const valuePredicate = predicate;\n    predicate = (v) => v === valuePredicate;\n  }\n  for (const key of Object.keys(obj)) {\n    if (!predicate(obj[key], obj)) {\n      delete newObj[key];\n    }\n  }\n  return newObj;\n}\n\n/**\n * Converts number of bytes to a readable size string.\n *\n * @param {number|string} bytes - The actual number of bytes.\n * @returns {string} The actual string representation, for example\n *                   '1.00 KB' for '1024 B'\n * @throws {Error} If bytes count cannot be converted to an integer or\n *                 if it is less than zero.\n */\nfunction toReadableSizeString (bytes) {\n  const intBytes = parseInt(bytes, 10);\n  if (isNaN(intBytes) || intBytes < 0) {\n    throw new Error(`Cannot convert '${bytes}' to a readable size format`);\n  }\n  if (intBytes >= GiB) {\n    return `${parseFloat(intBytes / (GiB * 1.0)).toFixed(2)} GB`;\n  } else if (intBytes >= MiB) {\n    return `${parseFloat(intBytes / (MiB * 1.0)).toFixed(2)} MB`;\n  } else if (intBytes >= KiB) {\n    return `${parseFloat(intBytes / (KiB * 1.0)).toFixed(2)} KB`;\n  }\n  return `${intBytes} B`;\n}\n\n/**\n * Checks whether the given path is a subpath of the\n * particular root folder. Both paths can include .. and . specifiers\n *\n * @param {string} originalPath The absolute file/folder path\n * @param {string} root The absolute root folder path\n * @param {?boolean} forcePosix Set it to true if paths must be interpreted in POSIX format\n * @returns {boolean} true if the given original path is the subpath of the root folder\n * @throws {Error} if any of the given paths is not absolute\n */\nfunction isSubPath (originalPath, root, forcePosix = null) {\n  const pathObj = forcePosix ? path.posix : path;\n  for (const p of [originalPath, root]) {\n    if (!pathObj.isAbsolute(p)) {\n      throw new Error(`'${p}' is expected to be an absolute path`);\n    }\n  }\n  const normalizedRoot = pathObj.normalize(root);\n  const normalizedPath = pathObj.normalize(originalPath);\n  return normalizedPath.startsWith(normalizedRoot);\n}\n\n/**\n * Checks whether the given paths are pointing to the same file system\n * destination.\n *\n * @param {string} path1 - Absolute or relative path to a file/folder\n * @param {string} path2 - Absolute or relative path to a file/folder\n * @param {...string} pathN - Zero or more absolute or relative paths to files/folders\n * @returns {boolean} true if all paths are pointing to the same file system item\n */\nasync function isSameDestination (path1, path2, ...pathN) {\n  const allPaths = [path1, path2, ...pathN];\n  if (!await B.reduce(allPaths, async (a, b) => a && await fs.exists(b), true)) {\n    return false;\n  }\n\n  const areAllItemsEqual = (arr) => !!arr.reduce((a, b) => a === b ? a : NaN);\n  if (areAllItemsEqual(allPaths)) {\n    return true;\n  }\n\n  // Node 10.5.0 introduced bigint support in stat, which allows for more precision\n  // however below that the options get interpreted as the callback\n  // TODO: remove when Node 10 is no longer supported\n  let mapCb = async (x) => await fs.stat(x, {\n    bigint: true,\n  }).ino;\n  if (semver.lt(process.version, '10.5.0')) {\n    mapCb = async (x) => await fs.stat(x).ino;\n  }\n  return areAllItemsEqual(await B.map(allPaths, mapCb));\n}\n\n/**\n * Coerces the given number/string to a valid version string\n *\n * @param {string|number} ver - Version string to coerce\n * @param {boolean} strict [true] - If true then an exception will be thrown\n * if `ver` cannot be coerced\n * @returns {string} Coerced version number or null if the string cannot be\n * coerced and strict mode is disabled\n * @throws {Error} if strict mode is enabled and `ver` cannot be coerced\n */\nfunction coerceVersion (ver, strict = true) {\n  const result = semver.valid(semver.coerce(`${ver}`));\n  if (strict && !result) {\n    throw new Error(`'${ver}' cannot be coerced to a valid version number`);\n  }\n  return result;\n}\n\nconst SUPPORTED_OPERATORS = ['==', '!=', '>', '<', '>=', '<=', '='];\n\n/**\n * Compares two version strings\n *\n * @param {string|number} ver1 - The first version number to compare. Should be a valid\n * version number supported by semver parser.\n * @param {string|number} ver2 - The second version number to compare. Should be a valid\n * version number supported by semver parser.\n * @param {string} operator - One of supported version number operators:\n * ==, !=, >, <, <=, >=, =\n * @returns {boolean} true or false depending on the actual comparison result\n * @throws {Error} if an unsupported operator is supplied or any of the supplied\n * version strings cannot be coerced\n */\nfunction compareVersions (ver1, operator, ver2) {\n  if (!SUPPORTED_OPERATORS.includes(operator)) {\n    throw new Error(`The '${operator}' comparison operator is not supported. ` +\n      `Only '${JSON.stringify(SUPPORTED_OPERATORS)}' operators are supported`);\n  }\n\n  const semverOperator = ['==', '!='].includes(operator) ? '=' : operator;\n  const result = semver.satisfies(coerceVersion(ver1), `${semverOperator}${coerceVersion(ver2)}`);\n  return operator === '!=' ? !result : result;\n}\n\n/**\n * Add appropriate quotes to command arguments. See https://github.com/substack/node-shell-quote\n * for more details\n *\n * @param {string|Array<string>} - The arguments that will be parsed\n * @returns {string} - The arguments, quoted\n */\nfunction quote (args) {\n  return shellQuote(args);\n}\n\n/**\n * This function is necessary to workaround unexpected memory leaks\n * caused by NodeJS string interning\n * behavior described in https://bugs.chromium.org/p/v8/issues/detail?id=2869\n *\n * @param {*} s - The string to unleak\n * @return {string} Either the unleaked string or the original object converted to string\n */\nfunction unleakString (s) {\n  return ` ${s}`.substr(1);\n}\n\n\n/**\n * @typedef {Object} PluralizeOptions\n * @property {?boolean} inclusive [false] - Whether to prefix with the number (e.g., 3 ducks)\n */\n\n/**\n * Get the form of a word appropriate to the count\n *\n * @param {string} word - The word to pluralize\n * @param {number} count - How many of the word exist\n * @param {?PluralizeOptions|boolean} options|inclusive - options for word pluralization,\n *   or a boolean indicating the options.inclusive property\n * @returns {string} The word pluralized according to the number\n */\nfunction pluralize (word, count, options = {}) {\n  let inclusive = false;\n  if (_.isBoolean(options)) {\n    // if passed in as a boolean\n    inclusive = options;\n  } else if (_.isBoolean(options?.inclusive)) {\n    // if passed in as an options hash\n    inclusive = options.inclusive;\n  }\n  return pluralizeLib(word, count, inclusive);\n}\n\n/**\n * @typedef {Object} EncodingOptions\n * @property {number} maxSize [1073741824] The maximum size of\n * the resulting buffer in bytes. This is set to 1GB by default, because\n * Appium limits the maximum HTTP body size to 1GB. Also, the NodeJS heap\n * size must be enough to keep the resulting object (usually this size is\n * limited to 1.4 GB)\n */\n\n/**\n * Converts contents of a local file to an in-memory base-64 encoded buffer.\n * The operation is memory-usage friendly and should be used while encoding\n * large files to base64\n *\n * @param {string} srcPath The full path to the file being encoded\n * @param {EncodingOptions} opts\n * @returns {Buffer} base64-encoded content of the source file as memory buffer\n * @throws {Error} if there was an error while reading the source file\n * or the source file is too\n */\nasync function toInMemoryBase64 (srcPath, opts = {}) {\n  if (!(await fs.exists(srcPath)) || (await fs.stat(srcPath)).isDirectory()) {\n    throw new Error(`No such file: ${srcPath}`);\n  }\n\n  const {\n    maxSize = 1 * GiB,\n  } = opts;\n  const resultBuffers = [];\n  let resultBuffersSize = 0;\n  const resultWriteStream = new stream.Writable({\n    write: (buffer, encoding, next) => {\n      resultBuffers.push(buffer);\n      resultBuffersSize += buffer.length;\n      if (maxSize > 0 && resultBuffersSize > maxSize) {\n        resultWriteStream.emit('error', new Error(`The size of the resulting ` +\n          `buffer must not be greater than ${toReadableSizeString(maxSize)}`));\n      }\n      next();\n    },\n  });\n\n  const readerStream = fs.createReadStream(srcPath);\n  const base64EncoderStream = new Base64Encode();\n  const resultWriteStreamPromise = new B((resolve, reject) => {\n    resultWriteStream.once('error', (e) => {\n      readerStream.unpipe(base64EncoderStream);\n      base64EncoderStream.unpipe(resultWriteStream);\n      readerStream.destroy();\n      reject(e);\n    });\n    resultWriteStream.once('finish', resolve);\n  });\n  const readStreamPromise = new B((resolve, reject) => {\n    readerStream.once('close', resolve);\n    readerStream.once('error', (e) => reject(\n      new Error(`Failed to read '${srcPath}': ${e.message}`)));\n  });\n  readerStream.pipe(base64EncoderStream);\n  base64EncoderStream.pipe(resultWriteStream);\n\n  await B.all([readStreamPromise, resultWriteStreamPromise]);\n  return Buffer.concat(resultBuffers);\n}\n\n/**\n * @typedef {Object} LockFileOptions\n * @property {number} timeout [120] The max time in seconds to wait for the lock\n * @property {boolean} tryRecovery [false] Whether to try lock recovery if\n * the first attempt to acquire it timed out.\n */\n\n/**\n * Create an async function which, when called, will not proceed until a certain file is no\n * longer present on the system. This allows for preventing concurrent behavior across processes\n * using a known lockfile path.\n *\n * @param {string} lockFile The full path to the file used for the lock\n * @param {LockFileOptions} opts\n * @returns {AsyncFunction} async function that takes another async function defining the locked\n * behavior\n */\nfunction getLockFileGuard (lockFile, opts = {}) {\n  const {\n    timeout = 120,\n    tryRecovery = false,\n  } = opts;\n\n  const lock = B.promisify(_lockfile.lock);\n  const check = B.promisify(_lockfile.check);\n  const unlock = B.promisify(_lockfile.unlock);\n\n  const guard = async (behavior) => {\n    let triedRecovery = false;\n    do {\n      try {\n        // if the lockfile doesn't exist, lock it synchronously to make sure no other call\n        // on the same spin of the event loop can also initiate a lock. If the lockfile does exist\n        // then just use the regular async 'lock' method which will wait on the lock.\n        if (_lockfile.checkSync(lockFile)) {\n          await lock(lockFile, {wait: timeout * 1000});\n        } else {\n          _lockfile.lockSync(lockFile);\n        }\n        break;\n      } catch (e) {\n        if (_.includes(e.message, 'EEXIST') && tryRecovery && !triedRecovery) {\n          // There could be cases where a process has been forcefully terminated\n          // without a chance to clean up pending locks: https://github.com/npm/lockfile/issues/26\n          _lockfile.unlockSync(lockFile);\n          triedRecovery = true;\n          continue;\n        }\n        throw new Error(`Could not acquire lock on '${lockFile}' after ${timeout}s. ` +\n          `Original error: ${e.message}`);\n      }\n    // eslint-disable-next-line no-constant-condition\n    } while (true);\n    try {\n      return await behavior();\n    } finally {\n      // whether the behavior succeeded or not, get rid of the lock\n      await unlock(lockFile);\n    }\n  };\n\n  guard.check = async () => await check(lockFile);\n\n  return guard;\n}\n\nexport {\n  hasValue, escapeSpace, escapeSpecialChars, localIp, cancellableDelay,\n  multiResolve, safeJsonParse, wrapElement, unwrapElement, filterObject,\n  toReadableSizeString, isSubPath, W3C_WEB_ELEMENT_IDENTIFIER,\n  isSameDestination, compareVersions, coerceVersion, quote, unleakString,\n  jsonStringify, pluralize, GiB, MiB, KiB, toInMemoryBase64,\n  uuidV1, uuidV3, uuidV4, uuidV5, shellParse, getLockFileGuard\n};\n"]},"metadata":{},"sourceType":"script"}