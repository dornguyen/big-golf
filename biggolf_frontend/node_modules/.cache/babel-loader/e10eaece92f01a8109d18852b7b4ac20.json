{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uploadFile = uploadFile;\nexports.downloadFile = downloadFile;\nrequire(\"source-map-support/register\");\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _fs = _interopRequireDefault(require(\"./fs\"));\nvar _url = _interopRequireDefault(require(\"url\"));\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _util = require(\"./util\");\nvar _logger = _interopRequireDefault(require(\"./logger\"));\nvar _jsftp = _interopRequireDefault(require(\"jsftp\"));\nvar _timing = _interopRequireDefault(require(\"./timing\"));\nvar _axios = _interopRequireDefault(require(\"axios\"));\nvar _formData = _interopRequireDefault(require(\"form-data\"));\nfunction toAxiosAuth(auth) {\n  if (!_lodash.default.isPlainObject(auth)) {\n    return null;\n  }\n  const axiosAuth = {\n    username: auth.username || auth.user,\n    password: auth.password || auth.pass\n  };\n  return axiosAuth.username && axiosAuth.password ? axiosAuth : null;\n}\nasync function uploadFileToHttp(localFileStream, parsedUri) {\n  let uploadOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    method = 'POST',\n    timeout = 5000,\n    headers,\n    auth,\n    fileFieldName = 'file',\n    formFields\n  } = uploadOptions;\n  const {\n    href\n  } = parsedUri;\n  const requestOpts = {\n    url: href,\n    method,\n    timeout,\n    maxContentLength: Infinity,\n    maxBodyLength: Infinity\n  };\n  const axiosAuth = toAxiosAuth(auth);\n  if (axiosAuth) {\n    requestOpts.auth = axiosAuth;\n  }\n  if (fileFieldName) {\n    const form = new _formData.default();\n    form.append(fileFieldName, localFileStream);\n    if (formFields) {\n      let pairs = [];\n      if (_lodash.default.isArray(formFields)) {\n        pairs = formFields;\n      } else if (_lodash.default.isPlainObject(formFields)) {\n        pairs = _lodash.default.toPairs(formFields);\n      }\n      for (const [key, value] of pairs) {\n        if (_lodash.default.toLower(key) !== _lodash.default.toLower(fileFieldName)) {\n          form.append(key, value);\n        }\n      }\n    }\n    requestOpts.headers = Object.assign({}, _lodash.default.isPlainObject(headers) ? headers : {}, form.getHeaders());\n    requestOpts.data = form;\n  } else {\n    if (_lodash.default.isPlainObject(headers)) {\n      requestOpts.headers = headers;\n    }\n    requestOpts.data = localFileStream;\n  }\n  _logger.default.debug(`Performing ${method} to ${href} with options (excluding data): ` + JSON.stringify(_lodash.default.omit(requestOpts, ['data'])));\n  const {\n    status,\n    statusText\n  } = await (0, _axios.default)(requestOpts);\n  _logger.default.info(`Server response: ${status} ${statusText}`);\n}\nasync function uploadFileToFtp(localFileStream, parsedUri) {\n  let uploadOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    auth,\n    user,\n    pass\n  } = uploadOptions;\n  const {\n    hostname,\n    port,\n    protocol,\n    pathname\n  } = parsedUri;\n  const ftpOpts = {\n    host: hostname,\n    port: port || 21\n  };\n  if (auth !== null && auth !== void 0 && auth.user && auth !== null && auth !== void 0 && auth.pass || user && pass) {\n    ftpOpts.user = (auth === null || auth === void 0 ? void 0 : auth.user) || user;\n    ftpOpts.pass = (auth === null || auth === void 0 ? void 0 : auth.pass) || pass;\n  }\n  _logger.default.debug(`${protocol} upload options: ${JSON.stringify(ftpOpts)}`);\n  return await new _bluebird.default((resolve, reject) => {\n    new _jsftp.default(ftpOpts).put(localFileStream, pathname, err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nasync function uploadFile(localPath, remoteUri) {\n  let uploadOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!(await _fs.default.exists(localPath))) {\n    throw new Error(`'${localPath}' does not exists or is not accessible`);\n  }\n  const {\n    isMetered = true\n  } = uploadOptions;\n  const parsedUri = _url.default.parse(remoteUri);\n  const {\n    size\n  } = await _fs.default.stat(localPath);\n  if (isMetered) {\n    _logger.default.info(`Uploading '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size to '${remoteUri}'`);\n  }\n  const timer = new _timing.default().start();\n  if (['http:', 'https:'].includes(parsedUri.protocol)) {\n    if (!uploadOptions.fileFieldName) {\n      uploadOptions.headers = Object.assign({}, _lodash.default.isPlainObject(uploadOptions.headers) ? uploadOptions.headers : {}, {\n        'Content-Length': size\n      });\n    }\n    await uploadFileToHttp(_fs.default.createReadStream(localPath), parsedUri, uploadOptions);\n  } else if (parsedUri.protocol === 'ftp:') {\n    await uploadFileToFtp(_fs.default.createReadStream(localPath), parsedUri, uploadOptions);\n  } else {\n    throw new Error(`Cannot upload the file at '${localPath}' to '${remoteUri}'. ` + `Unsupported remote protocol '${parsedUri.protocol}'. ` + `Only http/https and ftp/ftps protocols are supported.`);\n  }\n  if (isMetered) {\n    _logger.default.info(`Uploaded '${localPath}' of ${(0, _util.toReadableSizeString)(size)} size in ` + `${timer.getDuration().asSeconds.toFixed(3)}s`);\n  }\n}\nasync function downloadFile(remoteUrl, dstPath) {\n  let downloadOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    isMetered = true,\n    auth,\n    timeout = 5000,\n    headers\n  } = downloadOptions;\n  const requestOpts = {\n    url: remoteUrl,\n    responseType: 'stream',\n    timeout\n  };\n  const axiosAuth = toAxiosAuth(auth);\n  if (axiosAuth) {\n    requestOpts.auth = axiosAuth;\n  }\n  if (_lodash.default.isPlainObject(headers)) {\n    requestOpts.headers = headers;\n  }\n  const timer = new _timing.default().start();\n  let responseLength;\n  try {\n    const writer = _fs.default.createWriteStream(dstPath);\n    const {\n      data: responseStream,\n      headers: responseHeaders\n    } = await (0, _axios.default)(requestOpts);\n    responseLength = parseInt(responseHeaders['content-length'], 10);\n    responseStream.pipe(writer);\n    await new _bluebird.default((resolve, reject) => {\n      responseStream.once('error', reject);\n      writer.once('finish', resolve);\n      writer.once('error', e => {\n        responseStream.unpipe(writer);\n        reject(e);\n      });\n    });\n  } catch (err) {\n    throw new Error(`Cannot download the file from ${remoteUrl}: ${err.message}`);\n  }\n  const {\n    size\n  } = await _fs.default.stat(dstPath);\n  if (responseLength && size !== responseLength) {\n    await _fs.default.rimraf(dstPath);\n    throw new Error(`The size of the file downloaded from ${remoteUrl} (${size} bytes) ` + `differs from the one in Content-Length response header (${responseLength} bytes)`);\n  }\n  if (isMetered) {\n    const secondsElapsed = timer.getDuration().asSeconds;\n    _logger.default.debug(`${remoteUrl} (${(0, _util.toReadableSizeString)(size)}) ` + `has been downloaded to '${dstPath}' in ${secondsElapsed.toFixed(3)}s`);\n    if (secondsElapsed >= 2) {\n      const bytesPerSec = Math.floor(size / secondsElapsed);\n      _logger.default.debug(`Approximate download speed: ${(0, _util.toReadableSizeString)(bytesPerSec)}/s`);\n    }\n  }\n}\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["toAxiosAuth","auth","_","isPlainObject","axiosAuth","username","user","password","pass","uploadFileToHttp","localFileStream","parsedUri","uploadOptions","method","timeout","headers","fileFieldName","formFields","href","requestOpts","url","maxContentLength","Infinity","maxBodyLength","form","FormData","append","pairs","isArray","toPairs","key","value","toLower","Object","assign","getHeaders","data","log","debug","JSON","stringify","omit","status","statusText","info","uploadFileToFtp","hostname","port","protocol","pathname","ftpOpts","host","B","resolve","reject","Ftp","put","err","uploadFile","localPath","remoteUri","fs","exists","Error","isMetered","parse","size","stat","timer","Timer","start","includes","createReadStream","getDuration","asSeconds","toFixed","downloadFile","remoteUrl","dstPath","downloadOptions","responseType","responseLength","writer","createWriteStream","responseStream","responseHeaders","parseInt","pipe","once","e","unpipe","message","rimraf","secondsElapsed","bytesPerSec","Math","floor","require"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\net.js"],"sourcesContent":["import _ from 'lodash';\nimport fs from './fs';\nimport url from 'url';\nimport B from 'bluebird';\nimport { toReadableSizeString } from './util';\nimport log from './logger';\nimport Ftp from 'jsftp';\nimport Timer from './timing';\nimport axios from 'axios';\nimport FormData from 'form-data';\n\n\nfunction toAxiosAuth (auth) {\n  if (!_.isPlainObject(auth)) {\n    return null;\n  }\n\n  const axiosAuth = {\n    username: auth.username || auth.user,\n    password: auth.password || auth.pass,\n  };\n  return (axiosAuth.username && axiosAuth.password) ? axiosAuth : null;\n}\n\nasync function uploadFileToHttp (localFileStream, parsedUri, uploadOptions = {}) {\n  const {\n    method = 'POST',\n    timeout = 5000,\n    headers,\n    auth,\n    fileFieldName = 'file',\n    formFields,\n  } = uploadOptions;\n  const { href } = parsedUri;\n\n  const requestOpts = {\n    url: href,\n    method,\n    timeout,\n    maxContentLength: Infinity,\n    maxBodyLength: Infinity,\n  };\n  const axiosAuth = toAxiosAuth(auth);\n  if (axiosAuth) {\n    requestOpts.auth = axiosAuth;\n  }\n  if (fileFieldName) {\n    const form = new FormData();\n    form.append(fileFieldName, localFileStream);\n    if (formFields) {\n      let pairs = [];\n      if (_.isArray(formFields)) {\n        pairs = formFields;\n      } else if (_.isPlainObject(formFields)) {\n        pairs = _.toPairs(formFields);\n      }\n      for (const [key, value] of pairs) {\n        if (_.toLower(key) !== _.toLower(fileFieldName)) {\n          form.append(key, value);\n        }\n      }\n    }\n    requestOpts.headers = Object.assign({}, _.isPlainObject(headers) ? headers : {},\n      form.getHeaders());\n    requestOpts.data = form;\n  } else {\n    if (_.isPlainObject(headers)) {\n      requestOpts.headers = headers;\n    }\n    requestOpts.data = localFileStream;\n  }\n  log.debug(`Performing ${method} to ${href} with options (excluding data): ` +\n    JSON.stringify(_.omit(requestOpts, ['data'])));\n\n  const {status, statusText} = await axios(requestOpts);\n  log.info(`Server response: ${status} ${statusText}`);\n}\n\nasync function uploadFileToFtp (localFileStream, parsedUri, uploadOptions = {}) {\n  const {\n    auth,\n    user,\n    pass,\n  } = uploadOptions;\n  const {\n    hostname,\n    port,\n    protocol,\n    pathname,\n  } = parsedUri;\n\n  const ftpOpts = {\n    host: hostname,\n    port: port || 21,\n  };\n  if ((auth?.user && auth?.pass) || (user && pass)) {\n    ftpOpts.user = auth?.user || user;\n    ftpOpts.pass = auth?.pass || pass;\n  }\n  log.debug(`${protocol} upload options: ${JSON.stringify(ftpOpts)}`);\n  return await new B((resolve, reject) => {\n    new Ftp(ftpOpts).put(localFileStream, pathname, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\n/**\n * @typedef {Object} AuthCredentials\n * @property {string} user - Non-empty user name\n * @property {string} pass - Non-empty password\n */\n\n/**\n * @typedef {Object} FtpUploadOptions\n * @property {boolean} isMetered [true] - Whether to log the actual upload performance\n * (e.g. timings and speed)\n * @property {AuthCredentials} auth\n */\n\n/**\n * @typedef {Object} HttpUploadOptions\n * @property {boolean} isMetered [true] - Whether to log the actual upload performance\n * (e.g. timings and speed)\n * @property {string} method [POST] - The HTTP method used for file upload\n * @property {AuthCredentials} auth\n * @property {number} timeout [5000] - The actual request timeout in milliseconds\n * @property {Object} headers - Additional request headers mapping\n * @property {?string} fileFieldName [file] - The name of the form field containing the file\n * content to be uploaded. Any falsy value make the request to use non-multipart upload\n * @property {Array<Pair>|Object} formFields - The additional form fields\n * to be included into the upload request. This property is only considered if\n * `fileFieldName` is set\n */\n\n/**\n * Uploads the given file to a remote location. HTTP(S) and FTP\n * protocols are supported.\n *\n * @param {string} localPath - The path to a file on the local storage.\n * @param {string} remoteUri - The remote URI to upload the file to.\n * @param {?FtpUploadOptions|HttpUploadOptions} uploadOptions\n */\nasync function uploadFile (localPath, remoteUri, uploadOptions = {}) {\n  if (!await fs.exists(localPath)) {\n    throw new Error (`'${localPath}' does not exists or is not accessible`);\n  }\n\n  const {\n    isMetered = true,\n  } = uploadOptions;\n\n  const parsedUri = url.parse(remoteUri);\n  const {size} = await fs.stat(localPath);\n  if (isMetered) {\n    log.info(`Uploading '${localPath}' of ${toReadableSizeString(size)} size to '${remoteUri}'`);\n  }\n  const timer = new Timer().start();\n  if (['http:', 'https:'].includes(parsedUri.protocol)) {\n    if (!uploadOptions.fileFieldName) {\n      uploadOptions.headers = Object.assign({},\n        _.isPlainObject(uploadOptions.headers) ? uploadOptions.headers : {},\n        {'Content-Length': size}\n      );\n    }\n    await uploadFileToHttp(fs.createReadStream(localPath), parsedUri, uploadOptions);\n  } else if (parsedUri.protocol === 'ftp:') {\n    await uploadFileToFtp(fs.createReadStream(localPath), parsedUri, uploadOptions);\n  } else {\n    throw new Error(`Cannot upload the file at '${localPath}' to '${remoteUri}'. ` +\n      `Unsupported remote protocol '${parsedUri.protocol}'. ` +\n      `Only http/https and ftp/ftps protocols are supported.`);\n  }\n  if (isMetered) {\n    log.info(`Uploaded '${localPath}' of ${toReadableSizeString(size)} size in ` +\n      `${timer.getDuration().asSeconds.toFixed(3)}s`);\n  }\n}\n\n/**\n * @typedef {Object} DownloadOptions\n * @property {boolean} isMetered [true] - Whether to log the actual download performance\n * (e.g. timings and speed)\n * @property {AuthCredentials} auth\n * @property {number} timeout [5000] - The actual request timeout in milliseconds\n * @property {Object} headers - Request headers mapping\n */\n\n/**\n * Downloads the given file via HTTP(S)\n *\n * @param {string} remoteUrl - The remote url\n * @param {string} dstPath - The local path to download the file to\n * @param {?DownloadOptions} downloadOptions\n * @throws {Error} If download operation fails\n */\nasync function downloadFile (remoteUrl, dstPath, downloadOptions = {}) {\n  const {\n    isMetered = true,\n    auth,\n    timeout = 5000,\n    headers,\n  } = downloadOptions;\n\n  const requestOpts = {\n    url: remoteUrl,\n    responseType: 'stream',\n    timeout,\n  };\n  const axiosAuth = toAxiosAuth(auth);\n  if (axiosAuth) {\n    requestOpts.auth = axiosAuth;\n  }\n  if (_.isPlainObject(headers)) {\n    requestOpts.headers = headers;\n  }\n\n  const timer = new Timer().start();\n  let responseLength;\n  try {\n    const writer = fs.createWriteStream(dstPath);\n    const {\n      data: responseStream,\n      headers: responseHeaders,\n    } = await axios(requestOpts);\n    responseLength = parseInt(responseHeaders['content-length'], 10);\n    responseStream.pipe(writer);\n\n    await new B((resolve, reject) => {\n      responseStream.once('error', reject);\n      writer.once('finish', resolve);\n      writer.once('error', (e) => {\n        responseStream.unpipe(writer);\n        reject(e);\n      });\n    });\n  } catch (err) {\n    throw new Error(`Cannot download the file from ${remoteUrl}: ${err.message}`);\n  }\n\n  const {size} = await fs.stat(dstPath);\n  if (responseLength && size !== responseLength) {\n    await fs.rimraf(dstPath);\n    throw new Error(`The size of the file downloaded from ${remoteUrl} (${size} bytes) ` +\n      `differs from the one in Content-Length response header (${responseLength} bytes)`);\n  }\n  if (isMetered) {\n    const secondsElapsed = timer.getDuration().asSeconds;\n    log.debug(`${remoteUrl} (${toReadableSizeString(size)}) ` +\n      `has been downloaded to '${dstPath}' in ${secondsElapsed.toFixed(3)}s`);\n    if (secondsElapsed >= 2) {\n      const bytesPerSec = Math.floor(size / secondsElapsed);\n      log.debug(`Approximate download speed: ${toReadableSizeString(bytesPerSec)}/s`);\n    }\n  }\n}\n\nexport { uploadFile, downloadFile };\n"]},"metadata":{},"sourceType":"script"}