{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MJpegStream = void 0;\nrequire(\"source-map-support/register\");\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _logger = _interopRequireDefault(require(\"./logger\"));\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _imageUtil = require(\"./image-util\");\nvar _stream = require(\"stream\");\nvar _node = require(\"./node\");\nvar _axios = _interopRequireDefault(require(\"axios\"));\nlet MJpegConsumer = null;\nasync function initMJpegConsumer() {\n  if (!MJpegConsumer) {\n    try {\n      MJpegConsumer = await (0, _node.requirePackage)('mjpeg-consumer');\n    } catch (ign) {}\n  }\n  if (!MJpegConsumer) {\n    throw new Error('mjpeg-consumer module is required to use MJPEG-over-HTTP features. ' + 'Please install it first (npm i -g mjpeg-consumer) and restart Appium.');\n  }\n}\nconst MJPEG_SERVER_TIMEOUT_MS = 10000;\nclass MJpegStream extends _stream.Writable {\n  constructor(mJpegUrl) {\n    let errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash.default.noop;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(options);\n    this.errorHandler = errorHandler;\n    this.url = mJpegUrl;\n    this.clear();\n  }\n  get lastChunkBase64() {\n    return !_lodash.default.isEmpty(this.lastChunk) && _lodash.default.isBuffer(this.lastChunk) ? this.lastChunk.toString('base64') : null;\n  }\n  async lastChunkPNG() {\n    if (_lodash.default.isEmpty(this.lastChunk) || !_lodash.default.isBuffer(this.lastChunk)) {\n      return null;\n    }\n    try {\n      const jpg = await (0, _imageUtil.getJimpImage)(this.lastChunk);\n      return await jpg.getBuffer(_imageUtil.MIME_PNG);\n    } catch (e) {\n      return null;\n    }\n  }\n  async lastChunkPNGBase64() {\n    const png = await this.lastChunkPNG();\n    return png ? png.toString('base64') : null;\n  }\n  clear() {\n    this.registerStartSuccess = null;\n    this.registerStartFailure = null;\n    this.responseStream = null;\n    this.consumer = null;\n    this.lastChunk = null;\n    this.updateCount = 0;\n  }\n  async start() {\n    let serverTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MJPEG_SERVER_TIMEOUT_MS;\n    this.stop();\n    await initMJpegConsumer();\n    this.consumer = new MJpegConsumer();\n    const startPromise = new _bluebird.default((res, rej) => {\n      this.registerStartSuccess = res;\n      this.registerStartFailure = rej;\n    }).timeout(serverTimeout, `Waited ${serverTimeout}ms but the MJPEG server never sent any images`);\n    const url = this.url;\n    const onErr = err => {\n      this.lastChunk = null;\n      _logger.default.error(`Error getting MJpeg screenshot chunk: ${err.message}`);\n      this.errorHandler(err);\n      if (this.registerStartFailure) {\n        this.registerStartFailure(err);\n      }\n    };\n    const onClose = () => {\n      _logger.default.debug(`The connection to MJPEG server at ${url} has been closed`);\n      this.lastChunk = null;\n    };\n    try {\n      this.responseStream = (await (0, _axios.default)({\n        url,\n        responseType: 'stream',\n        timeout: serverTimeout\n      })).data;\n    } catch (e) {\n      return onErr(e);\n    }\n    this.responseStream.once('close', onClose).on('error', onErr).pipe(this.consumer).pipe(this);\n    await startPromise;\n  }\n  stop() {\n    if (!this.consumer) {\n      return;\n    }\n    this.responseStream.unpipe(this.consumer);\n    this.consumer.unpipe(this);\n    this.responseStream.destroy();\n    this.clear();\n  }\n  write(data) {\n    this.lastChunk = data;\n    this.updateCount++;\n    if (this.registerStartSuccess) {\n      this.registerStartSuccess();\n      this.registerStartSuccess = null;\n    }\n  }\n}\nexports.MJpegStream = MJpegStream;\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["MJpegConsumer","initMJpegConsumer","ign","Error","MJPEG_SERVER_TIMEOUT_MS","MJpegStream","Writable","constructor","mJpegUrl","errorHandler","_","noop","options","url","clear","lastChunkBase64","isEmpty","lastChunk","isBuffer","toString","lastChunkPNG","jpg","getBuffer","MIME_PNG","e","lastChunkPNGBase64","png","registerStartSuccess","registerStartFailure","responseStream","consumer","updateCount","start","serverTimeout","stop","startPromise","B","res","rej","timeout","onErr","err","log","error","message","onClose","debug","responseType","data","once","on","pipe","unpipe","destroy","write"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\mjpeg.js"],"sourcesContent":["import _ from 'lodash';\nimport log from './logger';\nimport B from 'bluebird';\nimport { getJimpImage, MIME_PNG } from './image-util';\nimport { Writable } from 'stream';\nimport { requirePackage } from './node';\nimport axios from 'axios';\n\n// lazy load this, as it might not be available\nlet MJpegConsumer = null;\n\n/**\n * @throws {Error} If `mjpeg-consumer` module is not installed or cannot be loaded\n */\nasync function initMJpegConsumer () {\n  if (!MJpegConsumer) {\n    try {\n      MJpegConsumer = await requirePackage('mjpeg-consumer');\n    } catch (ign) {}\n  }\n  if (!MJpegConsumer) {\n    throw new Error('mjpeg-consumer module is required to use MJPEG-over-HTTP features. ' +\n                    'Please install it first (npm i -g mjpeg-consumer) and restart Appium.');\n  }\n}\n\n// amount of time to wait for the first image in the stream\nconst MJPEG_SERVER_TIMEOUT_MS = 10000;\n\n/** Class which stores the last bit of data streamed into it */\nclass MJpegStream extends Writable {\n\n  /**\n   * Create an MJpegStream\n   * @param {string} mJpegUrl - URL of MJPEG-over-HTTP stream\n   * @param {function} [errorHandler=noop] - additional function that will be\n   * called in the case of any errors.\n   * @param {object} [options={}] - Options to pass to the Writable constructor\n   */\n  constructor (mJpegUrl, errorHandler = _.noop, options = {}) {\n    super(options);\n\n    this.errorHandler = errorHandler;\n    this.url = mJpegUrl;\n    this.clear();\n  }\n\n  /**\n   * Get the base64-encoded version of the JPEG\n   *\n   * @returns {?string} base64-encoded JPEG image data\n   * or `null` if no image can be parsed\n   */\n  get lastChunkBase64 () {\n    return !_.isEmpty(this.lastChunk) && _.isBuffer(this.lastChunk)\n      ? this.lastChunk.toString('base64')\n      : null;\n  }\n\n  /**\n   * Get the PNG version of the JPEG buffer\n   *\n   * @returns {?Buffer} PNG image data or `null` if no PNG\n   * image can be parsed\n   */\n  async lastChunkPNG () {\n    if (_.isEmpty(this.lastChunk) || !_.isBuffer(this.lastChunk)) {\n      return null;\n    }\n\n    try {\n      const jpg = await getJimpImage(this.lastChunk);\n      return await jpg.getBuffer(MIME_PNG);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Get the base64-encoded version of the PNG\n   *\n   * @returns {?string} base64-encoded PNG image data\n   * or `null` if no image can be parsed\n   */\n  async lastChunkPNGBase64 () {\n    const png = await this.lastChunkPNG();\n    return png ? png.toString('base64') : null;\n  }\n\n  /**\n   * Reset internal state\n   */\n  clear () {\n    this.registerStartSuccess = null;\n    this.registerStartFailure = null;\n    this.responseStream = null;\n    this.consumer = null;\n    this.lastChunk = null;\n    this.updateCount = 0;\n  }\n\n  /**\n   * Start reading the MJpeg stream and storing the last image\n   */\n  async start (serverTimeout = MJPEG_SERVER_TIMEOUT_MS) {\n    // ensure we're not started already\n    this.stop();\n\n    await initMJpegConsumer();\n\n    this.consumer = new MJpegConsumer();\n\n    // use the deferred pattern so we can wait for the start of the stream\n    // based on what comes in from an external pipe\n    const startPromise = new B((res, rej) => {\n      this.registerStartSuccess = res;\n      this.registerStartFailure = rej;\n    })\n    // start a timeout so that if the server does not return data, we don't\n    // block forever.\n      .timeout(serverTimeout,\n        `Waited ${serverTimeout}ms but the MJPEG server never sent any images`);\n\n    const url = this.url;\n    const onErr = (err) => {\n      // Make sure we don't get an outdated screenshot if there was an error\n      this.lastChunk = null;\n\n      log.error(`Error getting MJpeg screenshot chunk: ${err.message}`);\n      this.errorHandler(err);\n      if (this.registerStartFailure) {\n        this.registerStartFailure(err);\n      }\n    };\n    const onClose = () => {\n      log.debug(`The connection to MJPEG server at ${url} has been closed`);\n      this.lastChunk = null;\n    };\n\n    try {\n      this.responseStream = (await axios({\n        url,\n        responseType: 'stream',\n        timeout: serverTimeout,\n      })).data;\n    } catch (e) {\n      return onErr(e);\n    }\n\n    this.responseStream\n      .once('close', onClose)\n      .on('error', onErr) // ensure we do something with errors\n      .pipe(this.consumer) // allow chunking and transforming of jpeg data\n      .pipe(this); // send the actual jpegs to ourself\n\n    await startPromise;\n  }\n\n  /**\n   * Stop reading the MJpeg stream. Ensure we disconnect all the pipes and stop\n   * the HTTP request itself. Then reset the state.\n   */\n  stop () {\n    if (!this.consumer) {\n      return;\n    }\n\n    this.responseStream.unpipe(this.consumer);\n    this.consumer.unpipe(this);\n    this.responseStream.destroy();\n    this.clear();\n  }\n\n  /**\n   * Override the Writable write() method in order to save the last image and\n   * log the number of images we have received\n   * @override\n   * @param {Buffer} data - binary data streamed from the MJpeg consumer\n   */\n  write (data) {\n    this.lastChunk = data;\n    this.updateCount++;\n\n    if (this.registerStartSuccess) {\n      this.registerStartSuccess();\n      this.registerStartSuccess = null;\n    }\n  }\n}\n\nexport { MJpegStream };\n"]},"metadata":{},"sourceType":"script"}