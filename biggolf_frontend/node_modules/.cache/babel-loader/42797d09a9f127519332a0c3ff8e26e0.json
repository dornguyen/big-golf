{"ast":null,"code":"/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*global require: true module: true */\n/*\n * @package jsftp\n * @copyright Copyright(c) 2012 Ajax.org B.V. <info@c9.io>\n * @author Sergi Mansilla <sergi.mansilla@gmail.com>\n * @license https://github.com/sergi/jsFTP/blob/master/LICENSE MIT License\n */\n\n\"use strict\";\n\nconst createConnection = require(\"net\").createConnection;\nconst EventEmitter = require(\"events\").EventEmitter;\nconst inherits = require(\"util\").inherits;\nconst stream = require(\"stream\");\nconst fs = require(\"fs\");\nconst combine = require(\"stream-combiner\");\nconst ResponseParser = require(\"ftp-response-parser\");\nconst ListingParser = require(\"parse-listing\");\nconst once = require(\"once\");\nconst nfc = require(\"unorm\").nfc;\nconst debug = require(\"debug\")(\"jsftp:general\");\nconst dbgCommand = require(\"debug\")(\"jsftp:command\");\nconst dbgResponse = require(\"debug\")(\"jsftp:response\");\nconst FTP_HOST = \"localhost\";\nconst FTP_PORT = 21;\nconst TIMEOUT = 10 * 60 * 1000;\nconst IDLE_TIME = 30000;\nconst NOOP = function () {};\nconst expectedMarks = {\n  marks: [125, 150],\n  ignore: 226\n};\nconst RE_PASV = /([-\\d]+,[-\\d]+,[-\\d]+,[-\\d]+),([-\\d]+),([-\\d]+)/;\nconst FTP_NEWLINE = /\\r\\n|\\n/;\nfunction runCmd(name) {\n  let callback = NOOP;\n  let completeCmd = name + \" \";\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  if (typeof params[params.length - 1] === \"function\") {\n    callback = params.pop();\n  }\n  completeCmd += params.join(\" \");\n  this.execute(completeCmd.trim(), callback);\n}\nfunction Ftp(cfg) {\n  this.host = cfg.host || FTP_HOST;\n  this.port = cfg.port || FTP_PORT;\n  this.user = cfg.user || \"anonymous\";\n  this.pass = cfg.pass || \"@anonymous\";\n  this.createSocket = cfg.createSocket;\n  // True if the server doesn't support the `stat` command. Since listing a\n  // directory or retrieving file properties is quite a common operation, it is\n  // more efficient to avoid the round-trip to the server.\n  this.useList = cfg.useList || false;\n  this.commandQueue = [];\n  EventEmitter.call(this);\n  this.on(\"data\", dbgResponse);\n  this._createSocket(this.port, this.host);\n}\ninherits(Ftp, EventEmitter);\n\n// Generate generic methods from parameter names. they can easily be\n// overriden if we need special behavior. they accept any parameters given,\n// it is the responsibility of the user to validate the parameters.\nFtp.prototype.raw = function () {\n  runCmd.apply(this, arguments);\n};\nFtp.prototype.reemit = function (event) {\n  return data => {\n    this.emit(event, data);\n    debug(`event:${event}`, data || {});\n  };\n};\nFtp.prototype._createSocket = function (port, host) {\n  let firstAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOOP;\n  if (this.socket && this.socket.destroy) {\n    this.socket.destroy();\n  }\n  if (this.resParser) {\n    this.resParser.end();\n  }\n  this.resParser = new ResponseParser();\n  this.authenticated = false;\n  this.socket = this.createSocket ? this.createSocket({\n    port,\n    host\n  }, firstAction) : createConnection(port, host, firstAction);\n  this.socket.on(\"connect\", this.reemit(\"connect\"));\n  this.socket.on(\"timeout\", this.reemit(\"timeout\"));\n  this.pipeline = combine(this.socket, this.resParser);\n  this.pipeline.on(\"data\", data => {\n    this.emit(\"data\", data);\n    dbgResponse(data.text);\n    this.parseResponse(data);\n  });\n  this.pipeline.on(\"error\", this.reemit(\"error\"));\n};\nFtp.prototype.parseResponse = function (response) {\n  if (this.commandQueue.length === 0) {\n    return;\n  }\n  if ([220].indexOf(response.code) > -1) {\n    return;\n  }\n  const next = this.commandQueue[0].callback;\n  if (response.isMark) {\n    // If we receive a Mark and it is not expected, we ignore that command\n    if (!next.expectsMark || next.expectsMark.marks.indexOf(response.code) === -1) {\n      return;\n    }\n\n    // We might have to ignore the command that comes after the mark.\n    if (next.expectsMark.ignore) {\n      this.ignoreCmdCode = next.expectsMark.ignore;\n    }\n  }\n  if (this.ignoreCmdCode === response.code) {\n    this.ignoreCmdCode = null;\n    return;\n  }\n  this.parse(response, this.commandQueue.shift());\n};\n\n/**\n * Sends a new command to the server.\n *\n * @param {String} command Command to write in the FTP socket\n */\nFtp.prototype.send = function (command) {\n  if (!command) {\n    return;\n  }\n  dbgCommand(command);\n  this.pipeline.write(command + \"\\r\\n\");\n  dbgCommand(command);\n};\nFtp.prototype.nextCmd = function () {\n  const cmd = this.commandQueue[0];\n  if (!this.inProgress && cmd) {\n    this.send(cmd.action);\n    this.inProgress = true;\n  }\n};\n\n/**\n * Check whether the ftp user is authenticated at the moment of the\n * enqueing. ideally this should happen in the `push` method, just\n * before writing to the socket, but that would be complicated,\n * since we would have to 'unshift' the auth chain into the queue\n * or play the raw auth commands (that is, without enqueuing in\n * order to not mess up the queue order. ideally, that would be\n * built into the queue object. all this explanation to justify a\n * slight slopiness in the code flow.\n *\n * @param {string} action\n * @param {function} callback\n */\nFtp.prototype.execute = function (action) {\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NOOP;\n  if (this.socket && this.socket.writable) {\n    return this.runCommand({\n      action,\n      callback\n    });\n  }\n  this.authenticated = false;\n  this._createSocket(this.port, this.host, () => {\n    this.runCommand({\n      action,\n      callback\n    });\n  });\n};\nFtp.prototype.runCommand = function (cmd) {\n  if (this.authenticated || /^(feat|syst|user|pass)/.test(cmd.action)) {\n    this.commandQueue.push(cmd);\n    this.nextCmd();\n    return;\n  }\n  this.getFeatures(() => {\n    this.auth(this.user, this.pass, () => {\n      this.commandQueue.push(cmd);\n      this.nextCmd();\n    });\n  });\n};\n\n/**\n * Parse is called each time that a comand and a request are paired\n * together. That is, each time that there is a round trip of actions\n * between the client and the server.\n *\n * @param {Object} response Response from the server (contains text and code)\n * @param {Array} command Contains the command executed and a callback (if any)\n */\nFtp.prototype.parse = function (response, command) {\n  let err = null;\n  if (response.isError) {\n    err = new Error(response.text || \"Unknown FTP error.\");\n    err.code = response.code;\n  }\n  this.inProgress = false;\n  command.callback(err, response);\n  this.nextCmd();\n};\nFtp.prototype.getPasvPort = function (text) {\n  const match = RE_PASV.exec(text);\n  if (!match) {\n    return null;\n  }\n  let host = match[1].replace(/,/g, \".\");\n  if (host === \"127.0.0.1\") {\n    host = this.host;\n  }\n  return {\n    host,\n    port: (parseInt(match[2], 10) & 255) * 256 + (parseInt(match[3], 10) & 255)\n  };\n};\n\n/**\n * Returns true if the current server has the requested feature.\n *\n * @param {String} feature Feature to look for\n * @return {Boolean} Whether the current server has the feature\n */\nFtp.prototype.hasFeat = function (feature) {\n  return !!feature && this.features.indexOf(feature.toLowerCase()) > -1;\n};\n\n/**\n * Returns an array of features supported by the current FTP server\n *\n * @param {String} features Server response for the 'FEAT' command\n * @return {String[]} Array of feature names\n */\nFtp.prototype._parseFeats = function (features) {\n  // Split and ignore header and footer\n  const featureLines = features.split(FTP_NEWLINE).slice(1, -1);\n  return featureLines.map(feat => feat.trim().toLowerCase()).filter(feat => !!feat);\n};\n\n// Below this point all the methods are action helpers for FTP that compose\n// several actions in one command\nFtp.prototype.getFeatures = function (callback) {\n  if (this.features) {\n    return callback(null, this.features);\n  }\n  this.raw(\"feat\", (err, response) => {\n    this.features = err ? [] : this._parseFeats(response.text);\n    this.raw(\"syst\", (err, res) => {\n      if (!err && res.code === 215) {\n        this.system = res.text.toLowerCase();\n      }\n      callback(null, this.features);\n    });\n  });\n};\n\n/**\n * Authenticates the user.\n *\n * @param {String} user Username\n * @param {String} pass Password\n * @param {Function} callback Follow-up function.\n */\nFtp.prototype.auth = function (user, pass, callback) {\n  if (this.authenticating === true) {\n    return callback(new Error(\"This client is already authenticating\"));\n  }\n  if (!user) {\n    user = \"anonymous\";\n  }\n  if (!pass) {\n    pass = \"@anonymous\";\n  }\n  this.authenticating = true;\n  this.raw(\"user\", user, (err, res) => {\n    if (err || [230, 331, 332].indexOf(res.code) === -1) {\n      this.authenticating = false;\n      callback(err);\n      return;\n    }\n    this.raw(\"pass\", pass, (err, res) => {\n      this.authenticating = false;\n      if (err) {\n        callback(err);\n      } else if ([230, 202].indexOf(res.code) > -1) {\n        this.authenticated = true;\n        this.user = user;\n        this.pass = pass;\n        this.raw(\"type\", \"I\", () => {\n          callback(undefined, res);\n        });\n      } else if (res.code === 332) {\n        this.raw(\"acct\", \"\"); // ACCT not really supported\n      }\n    });\n  });\n};\n\nFtp.prototype.setType = function (type, callback) {\n  type = type.toUpperCase();\n  if (this.type === type) {\n    return callback();\n  }\n  this.raw(\"type\", type, (err, data) => {\n    if (!err) {\n      this.type = type;\n    }\n    callback(err, data);\n  });\n};\n\n/**\n * Lists a folder's contents using a passive connection.\n *\n * @param {String} path Remote path for the file/folder to retrieve\n * @param {Function} callback Function to call with errors or results\n */\nFtp.prototype.list = function (path, callback) {\n  if (arguments.length === 1) {\n    callback = arguments[0];\n    path = \"\";\n  }\n  let listing = \"\";\n  callback = once(callback);\n  this.getPasvSocket((err, socket) => {\n    if (err) {\n      return callback(err);\n    }\n    socket.setEncoding(\"utf8\");\n    socket.on(\"data\", data => {\n      listing += data;\n    });\n    this.pasvTimeout(socket, callback);\n    socket.once(\"close\", err => {\n      if (err) {\n        return callback(err);\n      } else if (!listing) {\n        // Some servers return empty string\n        return callback({\n          code: 451,\n          text: `Could not retrieve a file listing for ${path}.`,\n          isMark: false,\n          isError: true\n        });\n      }\n      callback(null, listing);\n    });\n    socket.once(\"error\", callback);\n    function cmdCallback(err, res) {\n      if (err) {\n        return callback(err);\n      }\n      const isExpectedMark = expectedMarks.marks.some(mark => mark === res.code);\n      if (!isExpectedMark) {\n        callback(new Error(`Expected marks ${expectedMarks.toString()} instead of: ${res.text}`));\n      }\n    }\n    cmdCallback.expectsMark = expectedMarks;\n    this.execute(`list ${path || \"\"}`, cmdCallback);\n  });\n};\nFtp.prototype.emitProgress = function (data) {\n  this.emit(\"progress\", {\n    filename: data.filename,\n    action: data.action,\n    total: data.totalSize || 0,\n    transferred: data.socket[data.action === \"get\" ? \"bytesRead\" : \"bytesWritten\"]\n  });\n};\n\n/**\n * Depending on the number of parameters, returns the content of the specified\n * file or directly saves a file into the specified destination. In the latter\n * case, an optional callback can be provided, which will receive the error in\n * case the operation was not successful.\n *\n * @param {String} remotePath File to be retrieved from the FTP server\n * @param {Function|String} localPath Local path where we create the new file\n * @param {Function} [callback] Gets called on either success or failure\n */\nFtp.prototype.get = function (remotePath, localPath) {\n  let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOOP;\n  let finalCallback;\n  const typeofLocalPath = typeof localPath;\n  if (typeofLocalPath === \"function\") {\n    finalCallback = localPath;\n  } else if (typeofLocalPath === \"string\") {\n    callback = once(callback);\n    finalCallback = (err, socket) => {\n      if (err) {\n        return callback(err);\n      }\n      const writeStream = fs.createWriteStream(localPath);\n      writeStream.on(\"error\", callback);\n      socket.on(\"readable\", () => {\n        this.emitProgress({\n          filename: remotePath,\n          action: \"get\",\n          socket: socket\n        });\n      });\n\n      // This ensures that any expected outcome is handled. There is no\n      // danger of the callback being executed several times, because it is\n      // wrapped in `once`.\n      socket.on(\"error\", callback);\n      socket.on(\"end\", callback);\n      socket.on(\"close\", callback);\n      socket.pipe(writeStream);\n    };\n  }\n  this.getGetSocket(remotePath, once(finalCallback));\n};\n\n/**\n * Returns a socket for a get (RETR) on a path. The socket is ready to be\n * streamed, but it is returned in a paused state. It is left to the user to\n * resume it.\n *\n * @param {String} path Path to the file to be retrieved\n * @param {Function} callback Function to call when finalized, with the socket\n * as a parameter\n */\nFtp.prototype.getGetSocket = function (path, callback) {\n  callback = once(callback);\n  this.getPasvSocket((err, socket) => {\n    if (err) {\n      return cmdCallback(err);\n    }\n    socket.on(\"error\", err => {\n      if (err.code === \"ECONNREFUSED\") {\n        err.msg = \"Probably trying a PASV operation while one is in progress\";\n      }\n      cmdCallback(err);\n    });\n    this.pasvTimeout(socket, cmdCallback);\n    socket.pause();\n    function cmdCallback(err, res) {\n      if (err) {\n        if (socket) {\n          // close the socket since it won't be used\n          socket.destroy();\n        }\n        return callback(err);\n      }\n      if (!socket) {\n        return callback(new Error(\"Error when retrieving PASV socket\"));\n      }\n      if (res.code === 125 || res.code === 150) {\n        return callback(null, socket);\n      }\n\n      // close the socket since it won't be used\n      socket.destroy();\n      return callback(new Error(\"Unexpected command \" + res.text));\n    }\n    cmdCallback.expectsMark = expectedMarks;\n    this.execute(\"retr \" + path, cmdCallback);\n  });\n};\n\n/**\n * Uploads contents on a FTP server. The `from` parameter can be a Buffer or the\n * path for a local file to be uploaded.\n *\n * @param {String|Buffer} from Contents to be uploaded.\n * @param {String} to path for the remote destination.\n * @param {Function} callback Function to execute on error or success.\n */\nFtp.prototype.put = function (from, destination, callback) {\n  const putReadable = (from, to, totalSize) => {\n    from.on(\"readable\", () => {\n      this.emitProgress({\n        filename: to,\n        action: \"put\",\n        socket: from,\n        totalSize\n      });\n    });\n    this.getPutSocket(from, to, callback);\n  };\n  if (from instanceof Buffer) {\n    this.getPutSocket(from, destination, callback);\n  } else if (typeof from === \"string\") {\n    fs.stat(from, (err, stats) => {\n      if (err && err.code === \"ENOENT\") {\n        return callback(new Error(\"Local file doesn't exist.\"));\n      }\n      if (stats.isDirectory()) {\n        return callback(new Error(\"Local path cannot be a directory\"));\n      }\n      const totalSize = err ? 0 : stats.size;\n      putReadable(fs.createReadStream(from), destination, totalSize);\n    });\n  } else if (from instanceof stream.Readable) {\n    putReadable(from, destination, 0);\n  } else {\n    callback(new Error(\"Expected `from` parameter to be a Buffer, Stream, or a String\"));\n  }\n};\nFtp.prototype.getPutSocket = function (from, path, next) {\n  next = once(next || NOOP);\n  this.getPasvSocket((err, socket) => {\n    if (err) {\n      if (socket) {\n        // close the socket since it won't be used\n        socket.destroy();\n      }\n      return next(err);\n    }\n    socket.on(\"close\", next);\n    socket.on(\"error\", next);\n    const callback = once((err, res) => {\n      if (err) {\n        if (socket) {\n          // close the socket since it won't be used\n          socket.destroy();\n        }\n        return next(err);\n      }\n\n      // Mark 150 indicates that the 'STOR' socket is ready to receive data.\n      // Anything else is not relevant.\n      if (res.code === 125 || res.code === 150) {\n        this.pasvTimeout(socket, next);\n        if (from instanceof Buffer) {\n          socket.end(from);\n        } else if (from instanceof stream.Readable) {\n          from.pipe(socket);\n        }\n      } else {\n        if (socket) {\n          // close the socket since it won't be used\n          socket.destroy();\n        }\n        return next(new Error(\"Unexpected command \" + res.text));\n      }\n    });\n    callback.expectsMark = expectedMarks;\n    this.execute(`stor ${path}`, callback);\n  });\n};\nFtp.prototype.pasvTimeout = function (socket, callback) {\n  socket.once(\"timeout\", () => {\n    debug(\"PASV socket timeout\");\n    this.emit(\"timeout\");\n    socket.end();\n    callback(new Error(\"Passive socket timeout\"));\n  });\n};\nFtp.prototype.getPasvSocket = function () {\n  let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NOOP;\n  callback = once(callback);\n  this.execute(\"pasv\", (err, res) => {\n    if (err) {\n      return callback(err);\n    }\n    const options = this.getPasvPort(res.text);\n    if (!options) {\n      return callback(new Error(\"Bad passive host/port combination\"));\n    }\n    const socket = this._pasvSocket = this.createSocket ? this.createSocket(options) : createConnection(options);\n    socket.setTimeout(this.timeout || TIMEOUT);\n    socket.once(\"close\", () => {\n      this._pasvSocket = undefined;\n    });\n    callback(null, socket);\n  });\n};\n\n/**\n * Provides information about files. It lists a directory contents or\n * a single file and yields an array of file objects. The file objects\n * contain several properties. The main difference between this method and\n * 'list' or 'stat' is that it returns objects with the file properties\n * already parsed.\n *\n * Example of file object:\n *\n *  {\n *      name: 'README.txt',\n *      type: 0,\n *      time: 996052680000,\n *      size: '2582',\n *      owner: 'sergi',\n *      group: 'staff',\n *      userPermissions: { read: true, write: true, exec: false },\n *      groupPermissions: { read: true, write: false, exec: false },\n *      otherPermissions: { read: true, write: false, exec: false }\n *  }\n *\n * The constants used in the object are defined in ftpParser.js\n *\n * @param {String} filePath Path to the file or directory to list\n * @param {Function} callback Function to call with the proper data when\n * the listing is finished.\n */\nFtp.prototype.ls = function (filePath, callback) {\n  function entriesToList(err, entries) {\n    if (err) {\n      return callback(err);\n    }\n    ListingParser.parseFtpEntries(entries.text || entries, (err, files) => {\n      if (err) {\n        return callback(err);\n      }\n      files.forEach(file => {\n        // Normalize UTF8 doing canonical decomposition, followed by\n        // canonical Composition\n        file.name = nfc(file.name);\n      });\n      callback(null, files);\n    });\n  }\n  if (this.useList) {\n    this.list(filePath, entriesToList);\n  } else {\n    this.raw(\"stat\", filePath, (err, data) => {\n      // We might be connected to a server that doesn't support the\n      // 'STAT' command, which is set as default. We use 'LIST' instead,\n      // and we set the variable `useList` to true, to avoid extra round\n      // trips to the server to check.\n      const errored = err && (err.code === 502 || err.code === 500);\n      const isHummingbird = this.system && this.system.indexOf(\"hummingbird\") > -1;\n      if (errored || isHummingbird) {\n        // Not sure if the 'hummingbird' system check ^^^ is still\n        // necessary. If they support any standards, the 500 error\n        // should have us covered. Let's leave it for now.\n        this.useList = true;\n        this.list(filePath, entriesToList);\n      } else {\n        entriesToList(err, data);\n      }\n    });\n  }\n};\nFtp.prototype.rename = function (from, to, callback) {\n  this.raw(\"rnfr\", from, err => {\n    if (err) {\n      return callback(err);\n    }\n    this.raw(\"rnto\", to, callback);\n  });\n};\nFtp.prototype.keepAlive = function (wait) {\n  if (this._keepAliveInterval) {\n    clearInterval(this._keepAliveInterval);\n  }\n  this._keepAliveInterval = setInterval(this.raw.bind(this, \"noop\"), wait || IDLE_TIME);\n};\nFtp.prototype.destroy = function () {\n  if (this._keepAliveInterval) {\n    clearInterval(this._keepAliveInterval);\n  }\n  if (this.socket && this.socket.writable) {\n    this.socket.end();\n  }\n  if (this._pasvSocket && this._pasvSocket.writable) {\n    this._pasvSocket.end();\n  }\n  this.resParser.end();\n  this.socket = undefined;\n  this._pasvSocket = undefined;\n  this.features = null;\n  this.authenticated = false;\n};\nmodule.exports = Ftp;","map":{"version":3,"names":["createConnection","require","EventEmitter","inherits","stream","fs","combine","ResponseParser","ListingParser","once","nfc","debug","dbgCommand","dbgResponse","FTP_HOST","FTP_PORT","TIMEOUT","IDLE_TIME","NOOP","expectedMarks","marks","ignore","RE_PASV","FTP_NEWLINE","runCmd","name","callback","completeCmd","params","length","pop","join","execute","trim","Ftp","cfg","host","port","user","pass","createSocket","useList","commandQueue","call","on","_createSocket","prototype","raw","apply","arguments","reemit","event","data","emit","firstAction","socket","destroy","resParser","end","authenticated","pipeline","text","parseResponse","response","indexOf","code","next","isMark","expectsMark","ignoreCmdCode","parse","shift","send","command","write","nextCmd","cmd","inProgress","action","writable","runCommand","test","push","getFeatures","auth","err","isError","Error","getPasvPort","match","exec","replace","parseInt","hasFeat","feature","features","toLowerCase","_parseFeats","featureLines","split","slice","map","feat","filter","res","system","authenticating","undefined","setType","type","toUpperCase","list","path","listing","getPasvSocket","setEncoding","pasvTimeout","cmdCallback","isExpectedMark","some","mark","toString","emitProgress","filename","total","totalSize","transferred","get","remotePath","localPath","finalCallback","typeofLocalPath","writeStream","createWriteStream","pipe","getGetSocket","msg","pause","put","from","destination","putReadable","to","getPutSocket","Buffer","stat","stats","isDirectory","size","createReadStream","Readable","options","_pasvSocket","setTimeout","timeout","ls","filePath","entriesToList","entries","parseFtpEntries","files","forEach","file","errored","isHummingbird","rename","keepAlive","wait","_keepAliveInterval","clearInterval","setInterval","bind","module","exports"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/jsftp/lib/jsftp.js"],"sourcesContent":["/* vim:set ts=2 sw=2 sts=2 expandtab */\n/*global require: true module: true */\n/*\n * @package jsftp\n * @copyright Copyright(c) 2012 Ajax.org B.V. <info@c9.io>\n * @author Sergi Mansilla <sergi.mansilla@gmail.com>\n * @license https://github.com/sergi/jsFTP/blob/master/LICENSE MIT License\n */\n\n\"use strict\";\n\nconst  createConnection = require(\"net\").createConnection;\nconst EventEmitter = require(\"events\").EventEmitter;\nconst inherits = require(\"util\").inherits;\nconst stream = require(\"stream\");\nconst fs = require(\"fs\");\nconst combine = require(\"stream-combiner\");\n\nconst ResponseParser = require(\"ftp-response-parser\");\nconst ListingParser = require(\"parse-listing\");\nconst once = require(\"once\");\nconst nfc = require(\"unorm\").nfc;\n\nconst debug = require(\"debug\")(\"jsftp:general\");\nconst dbgCommand = require(\"debug\")(\"jsftp:command\");\nconst dbgResponse = require(\"debug\")(\"jsftp:response\");\n\nconst FTP_HOST = \"localhost\";\nconst FTP_PORT = 21;\nconst TIMEOUT = 10 * 60 * 1000;\nconst IDLE_TIME = 30000;\nconst NOOP = function() {};\n\nconst expectedMarks = {\n  marks: [125, 150],\n  ignore: 226\n};\n\nconst RE_PASV = /([-\\d]+,[-\\d]+,[-\\d]+,[-\\d]+),([-\\d]+),([-\\d]+)/;\nconst FTP_NEWLINE = /\\r\\n|\\n/;\n\nfunction runCmd(name, ...params) {\n  let callback = NOOP;\n  let completeCmd = name + \" \";\n\n  if (typeof params[params.length - 1] === \"function\") {\n    callback = params.pop();\n  }\n\n  completeCmd += params.join(\" \");\n  this.execute(completeCmd.trim(), callback);\n}\n\nfunction Ftp(cfg) {\n  this.host = cfg.host || FTP_HOST;\n  this.port = cfg.port || FTP_PORT;\n  this.user = cfg.user || \"anonymous\";\n  this.pass = cfg.pass || \"@anonymous\";\n  this.createSocket = cfg.createSocket;\n  // True if the server doesn't support the `stat` command. Since listing a\n  // directory or retrieving file properties is quite a common operation, it is\n  // more efficient to avoid the round-trip to the server.\n  this.useList = cfg.useList || false;\n\n  this.commandQueue = [];\n\n  EventEmitter.call(this);\n\n  this.on(\"data\", dbgResponse);\n\n  this._createSocket(this.port, this.host);\n}\n\ninherits(Ftp, EventEmitter);\n\n// Generate generic methods from parameter names. they can easily be\n// overriden if we need special behavior. they accept any parameters given,\n// it is the responsibility of the user to validate the parameters.\nFtp.prototype.raw = function() {\n  runCmd.apply(this, arguments);\n};\n\nFtp.prototype.reemit = function(event) {\n  return data => {\n    this.emit(event, data);\n    debug(`event:${event}`, data || {});\n  };\n};\n\nFtp.prototype._createSocket = function(port, host, firstAction = NOOP) {\n  if (this.socket && this.socket.destroy) {\n    this.socket.destroy();\n  }\n\n  if (this.resParser) {\n    this.resParser.end();\n  }\n  this.resParser = new ResponseParser();\n\n  this.authenticated = false;\n  this.socket = this.createSocket\n    ? this.createSocket({ port, host }, firstAction)\n    : createConnection(port, host, firstAction);\n  this.socket.on(\"connect\", this.reemit(\"connect\"));\n  this.socket.on(\"timeout\", this.reemit(\"timeout\"));\n\n  this.pipeline = combine(this.socket, this.resParser);\n\n  this.pipeline.on(\"data\", data => {\n    this.emit(\"data\", data);\n    dbgResponse(data.text);\n    this.parseResponse(data);\n  });\n  this.pipeline.on(\"error\", this.reemit(\"error\"));\n};\n\nFtp.prototype.parseResponse = function(response) {\n  if (this.commandQueue.length === 0) {\n    return;\n  }\n  if ([220].indexOf(response.code) > -1) {\n    return;\n  }\n\n  const next = this.commandQueue[0].callback;\n  if (response.isMark) {\n    // If we receive a Mark and it is not expected, we ignore that command\n    if (\n      !next.expectsMark ||\n      next.expectsMark.marks.indexOf(response.code) === -1\n    ) {\n      return;\n    }\n\n    // We might have to ignore the command that comes after the mark.\n    if (next.expectsMark.ignore) {\n      this.ignoreCmdCode = next.expectsMark.ignore;\n    }\n  }\n\n  if (this.ignoreCmdCode === response.code) {\n    this.ignoreCmdCode = null;\n    return;\n  }\n\n  this.parse(response, this.commandQueue.shift());\n};\n\n/**\n * Sends a new command to the server.\n *\n * @param {String} command Command to write in the FTP socket\n */\nFtp.prototype.send = function(command) {\n  if (!command) {\n    return;\n  }\n\n  dbgCommand(command);\n  this.pipeline.write(command + \"\\r\\n\");\n\n  dbgCommand(command);\n};\n\nFtp.prototype.nextCmd = function() {\n  const cmd = this.commandQueue[0];\n  if (!this.inProgress && cmd) {\n    this.send(cmd.action);\n    this.inProgress = true;\n  }\n};\n\n/**\n * Check whether the ftp user is authenticated at the moment of the\n * enqueing. ideally this should happen in the `push` method, just\n * before writing to the socket, but that would be complicated,\n * since we would have to 'unshift' the auth chain into the queue\n * or play the raw auth commands (that is, without enqueuing in\n * order to not mess up the queue order. ideally, that would be\n * built into the queue object. all this explanation to justify a\n * slight slopiness in the code flow.\n *\n * @param {string} action\n * @param {function} callback\n */\nFtp.prototype.execute = function(action, callback = NOOP) {\n  if (this.socket && this.socket.writable) {\n    return this.runCommand({ action, callback });\n  }\n\n  this.authenticated = false;\n  this._createSocket(this.port, this.host, () => {\n    this.runCommand({ action, callback });\n  });\n};\n\nFtp.prototype.runCommand = function(cmd) {\n  if (this.authenticated || /^(feat|syst|user|pass)/.test(cmd.action)) {\n    this.commandQueue.push(cmd);\n    this.nextCmd();\n    return;\n  }\n\n  this.getFeatures(() => {\n    this.auth(this.user, this.pass, () => {\n      this.commandQueue.push(cmd);\n      this.nextCmd();\n    });\n  });\n};\n\n/**\n * Parse is called each time that a comand and a request are paired\n * together. That is, each time that there is a round trip of actions\n * between the client and the server.\n *\n * @param {Object} response Response from the server (contains text and code)\n * @param {Array} command Contains the command executed and a callback (if any)\n */\nFtp.prototype.parse = function(response, command) {\n  let err = null;\n  if (response.isError) {\n    err = new Error(response.text || \"Unknown FTP error.\");\n    err.code = response.code;\n  }\n\n  this.inProgress = false;\n  command.callback(err, response);\n  this.nextCmd();\n};\n\nFtp.prototype.getPasvPort = function(text) {\n  const match = RE_PASV.exec(text);\n  if (!match) {\n    return null;\n  }\n\n  let host = match[1].replace(/,/g, \".\");\n  if (host === \"127.0.0.1\") {\n    host = this.host;\n  }\n\n  return {\n    host,\n    port: (parseInt(match[2], 10) & 255) * 256 + (parseInt(match[3], 10) & 255)\n  };\n};\n\n/**\n * Returns true if the current server has the requested feature.\n *\n * @param {String} feature Feature to look for\n * @return {Boolean} Whether the current server has the feature\n */\nFtp.prototype.hasFeat = function(feature) {\n  return !!feature && this.features.indexOf(feature.toLowerCase()) > -1;\n};\n\n/**\n * Returns an array of features supported by the current FTP server\n *\n * @param {String} features Server response for the 'FEAT' command\n * @return {String[]} Array of feature names\n */\nFtp.prototype._parseFeats = function(features) {\n  // Split and ignore header and footer\n  const featureLines = features.split(FTP_NEWLINE).slice(1, -1);\n  return featureLines\n    .map(feat => feat.trim().toLowerCase())\n    .filter(feat => !!feat);\n};\n\n// Below this point all the methods are action helpers for FTP that compose\n// several actions in one command\nFtp.prototype.getFeatures = function(callback) {\n  if (this.features) {\n    return callback(null, this.features);\n  }\n\n  this.raw(\"feat\", (err, response) => {\n    this.features = err ? [] : this._parseFeats(response.text);\n    this.raw(\"syst\", (err, res) => {\n      if (!err && res.code === 215) {\n        this.system = res.text.toLowerCase();\n      }\n\n      callback(null, this.features);\n    });\n  });\n};\n\n/**\n * Authenticates the user.\n *\n * @param {String} user Username\n * @param {String} pass Password\n * @param {Function} callback Follow-up function.\n */\nFtp.prototype.auth = function(user, pass, callback) {\n  if (this.authenticating === true) {\n    return callback(new Error(\"This client is already authenticating\"));\n  }\n\n  if (!user) {\n    user = \"anonymous\";\n  }\n  if (!pass) {\n    pass = \"@anonymous\";\n  }\n\n  this.authenticating = true;\n  this.raw(\"user\", user, (err, res) => {\n    if (err || [230, 331, 332].indexOf(res.code) === -1) {\n      this.authenticating = false;\n      callback(err);\n      return;\n    }\n    this.raw(\"pass\", pass, (err, res) => {\n      this.authenticating = false;\n\n      if (err) {\n        callback(err);\n      } else if ([230, 202].indexOf(res.code) > -1) {\n        this.authenticated = true;\n        this.user = user;\n        this.pass = pass;\n        this.raw(\"type\", \"I\", () => {\n          callback(undefined, res);\n        });\n      } else if (res.code === 332) {\n        this.raw(\"acct\", \"\"); // ACCT not really supported\n      }\n    });\n  });\n};\n\nFtp.prototype.setType = function(type, callback) {\n  type = type.toUpperCase();\n  if (this.type === type) {\n    return callback();\n  }\n\n  this.raw(\"type\", type, (err, data) => {\n    if (!err) {\n      this.type = type;\n    }\n\n    callback(err, data);\n  });\n};\n\n/**\n * Lists a folder's contents using a passive connection.\n *\n * @param {String} path Remote path for the file/folder to retrieve\n * @param {Function} callback Function to call with errors or results\n */\nFtp.prototype.list = function(path, callback) {\n  if (arguments.length === 1) {\n    callback = arguments[0];\n    path = \"\";\n  }\n\n  let listing = \"\";\n  callback = once(callback);\n\n  this.getPasvSocket((err, socket) => {\n    if (err) {\n      return callback(err);\n    }\n\n    socket.setEncoding(\"utf8\");\n    socket.on(\"data\", data => {\n      listing += data;\n    });\n\n    this.pasvTimeout(socket, callback);\n\n    socket.once(\"close\", err => {\n      if (err) {\n        return callback(err);\n      } else if (!listing) {\n        // Some servers return empty string\n        return callback({\n          code: 451,\n          text: `Could not retrieve a file listing for ${path}.`,\n          isMark: false,\n          isError: true\n        });\n      }\n      callback(null, listing);\n    });\n    socket.once(\"error\", callback);\n\n    function cmdCallback(err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      const isExpectedMark = expectedMarks.marks.some(\n        mark => mark === res.code\n      );\n\n      if (!isExpectedMark) {\n        callback(\n          new Error(\n            `Expected marks ${expectedMarks.toString()} instead of: ${res.text}`\n          )\n        );\n      }\n    }\n\n    cmdCallback.expectsMark = expectedMarks;\n\n    this.execute(`list ${path || \"\"}`, cmdCallback);\n  });\n};\n\nFtp.prototype.emitProgress = function(data) {\n  this.emit(\"progress\", {\n    filename: data.filename,\n    action: data.action,\n    total: data.totalSize || 0,\n    transferred:\n      data.socket[data.action === \"get\" ? \"bytesRead\" : \"bytesWritten\"]\n  });\n};\n\n/**\n * Depending on the number of parameters, returns the content of the specified\n * file or directly saves a file into the specified destination. In the latter\n * case, an optional callback can be provided, which will receive the error in\n * case the operation was not successful.\n *\n * @param {String} remotePath File to be retrieved from the FTP server\n * @param {Function|String} localPath Local path where we create the new file\n * @param {Function} [callback] Gets called on either success or failure\n */\nFtp.prototype.get = function(remotePath, localPath, callback = NOOP) {\n  let finalCallback;\n  const typeofLocalPath = typeof localPath;\n\n  if (typeofLocalPath === \"function\") {\n    finalCallback = localPath;\n  } else if (typeofLocalPath === \"string\") {\n    callback = once(callback);\n    finalCallback = (err, socket) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const writeStream = fs.createWriteStream(localPath);\n      writeStream.on(\"error\", callback);\n\n      socket.on(\"readable\", () => {\n        this.emitProgress({\n          filename: remotePath,\n          action: \"get\",\n          socket: socket\n        });\n      });\n\n      // This ensures that any expected outcome is handled. There is no\n      // danger of the callback being executed several times, because it is\n      // wrapped in `once`.\n      socket.on(\"error\", callback);\n      socket.on(\"end\", callback);\n      socket.on(\"close\", callback);\n\n      socket.pipe(writeStream);\n    };\n  }\n\n  this.getGetSocket(remotePath, once(finalCallback));\n};\n\n/**\n * Returns a socket for a get (RETR) on a path. The socket is ready to be\n * streamed, but it is returned in a paused state. It is left to the user to\n * resume it.\n *\n * @param {String} path Path to the file to be retrieved\n * @param {Function} callback Function to call when finalized, with the socket\n * as a parameter\n */\nFtp.prototype.getGetSocket = function(path, callback) {\n  callback = once(callback);\n  this.getPasvSocket((err, socket) => {\n    if (err) {\n      return cmdCallback(err);\n    }\n\n    socket.on(\"error\", err => {\n      if (err.code === \"ECONNREFUSED\") {\n        err.msg = \"Probably trying a PASV operation while one is in progress\";\n      }\n      cmdCallback(err);\n    });\n\n    this.pasvTimeout(socket, cmdCallback);\n    socket.pause();\n\n    function cmdCallback(err, res) {\n      if (err) {\n        if (socket) {\n          // close the socket since it won't be used\n          socket.destroy();\n        }\n        return callback(err);\n      }\n\n      if (!socket) {\n        return callback(new Error(\"Error when retrieving PASV socket\"));\n      }\n\n      if (res.code === 125 || res.code === 150) {\n        return callback(null, socket);\n      }\n\n      // close the socket since it won't be used\n      socket.destroy();\n\n      return callback(new Error(\"Unexpected command \" + res.text));\n    }\n\n    cmdCallback.expectsMark = expectedMarks;\n    this.execute(\"retr \" + path, cmdCallback);\n  });\n};\n\n/**\n * Uploads contents on a FTP server. The `from` parameter can be a Buffer or the\n * path for a local file to be uploaded.\n *\n * @param {String|Buffer} from Contents to be uploaded.\n * @param {String} to path for the remote destination.\n * @param {Function} callback Function to execute on error or success.\n */\nFtp.prototype.put = function(from, destination, callback) {\n  const putReadable = (from, to, totalSize) => {\n    from.on(\"readable\", () => {\n      this.emitProgress({\n        filename: to,\n        action: \"put\",\n        socket: from,\n        totalSize\n      });\n    });\n\n    this.getPutSocket(from, to, callback);\n  };\n\n  if (from instanceof Buffer) {\n    this.getPutSocket(from, destination, callback);\n  } else if (typeof from === \"string\") {\n    fs.stat(from, (err, stats) => {\n      if (err && err.code === \"ENOENT\") {\n        return callback(new Error(\"Local file doesn't exist.\"));\n      }\n\n      if (stats.isDirectory()) {\n        return callback(new Error(\"Local path cannot be a directory\"));\n      }\n\n      const totalSize = err ? 0 : stats.size;\n      putReadable(fs.createReadStream(from), destination, totalSize);\n    });\n  } else if (from instanceof stream.Readable) {\n    putReadable(from, destination, 0);\n  } else {\n    callback(\n      new Error(\"Expected `from` parameter to be a Buffer, Stream, or a String\")\n    );\n  }\n};\n\nFtp.prototype.getPutSocket = function(from, path, next) {\n  next = once(next || NOOP);\n\n  this.getPasvSocket((err, socket) => {\n    if (err) {\n      if (socket) {\n        // close the socket since it won't be used\n        socket.destroy();\n      }\n      return next(err);\n    }\n\n    socket.on(\"close\", next);\n    socket.on(\"error\", next);\n\n    const callback = once((err, res) => {\n      if (err) {\n        if (socket) {\n          // close the socket since it won't be used\n          socket.destroy();\n        }\n        return next(err);\n      }\n\n      // Mark 150 indicates that the 'STOR' socket is ready to receive data.\n      // Anything else is not relevant.\n      if (res.code === 125 || res.code === 150) {\n        this.pasvTimeout(socket, next);\n        if (from instanceof Buffer) {\n          socket.end(from);\n        } else if (from instanceof stream.Readable) {\n          from.pipe(socket);\n        }\n      } else {\n        if (socket) {\n          // close the socket since it won't be used\n          socket.destroy();\n        }\n        return next(new Error(\"Unexpected command \" + res.text));\n      }\n    });\n\n    callback.expectsMark = expectedMarks;\n\n    this.execute(`stor ${path}`, callback);\n  });\n};\n\nFtp.prototype.pasvTimeout = function(socket, callback) {\n  socket.once(\"timeout\", () => {\n    debug(\"PASV socket timeout\");\n    this.emit(\"timeout\");\n    socket.end();\n    callback(new Error(\"Passive socket timeout\"));\n  });\n};\n\nFtp.prototype.getPasvSocket = function(callback = NOOP) {\n  callback = once(callback);\n\n  this.execute(\"pasv\", (err, res) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const options = this.getPasvPort(res.text);\n    if (!options) {\n      return callback(new Error(\"Bad passive host/port combination\"));\n    }\n\n    const socket = (this._pasvSocket = this.createSocket\n      ? this.createSocket(options)\n      : createConnection(options));\n    socket.setTimeout(this.timeout || TIMEOUT);\n    socket.once(\"close\", () => {\n      this._pasvSocket = undefined;\n    });\n\n    callback(null, socket);\n  });\n};\n\n/**\n * Provides information about files. It lists a directory contents or\n * a single file and yields an array of file objects. The file objects\n * contain several properties. The main difference between this method and\n * 'list' or 'stat' is that it returns objects with the file properties\n * already parsed.\n *\n * Example of file object:\n *\n *  {\n *      name: 'README.txt',\n *      type: 0,\n *      time: 996052680000,\n *      size: '2582',\n *      owner: 'sergi',\n *      group: 'staff',\n *      userPermissions: { read: true, write: true, exec: false },\n *      groupPermissions: { read: true, write: false, exec: false },\n *      otherPermissions: { read: true, write: false, exec: false }\n *  }\n *\n * The constants used in the object are defined in ftpParser.js\n *\n * @param {String} filePath Path to the file or directory to list\n * @param {Function} callback Function to call with the proper data when\n * the listing is finished.\n */\nFtp.prototype.ls = function(filePath, callback) {\n  function entriesToList(err, entries) {\n    if (err) {\n      return callback(err);\n    }\n\n    ListingParser.parseFtpEntries(entries.text || entries, (err, files) => {\n      if (err) {\n        return callback(err);\n      }\n\n      files.forEach(file => {\n        // Normalize UTF8 doing canonical decomposition, followed by\n        // canonical Composition\n        file.name = nfc(file.name);\n      });\n      callback(null, files);\n    });\n  }\n\n  if (this.useList) {\n    this.list(filePath, entriesToList);\n  } else {\n    this.raw(\"stat\", filePath, (err, data) => {\n      // We might be connected to a server that doesn't support the\n      // 'STAT' command, which is set as default. We use 'LIST' instead,\n      // and we set the variable `useList` to true, to avoid extra round\n      // trips to the server to check.\n      const errored = err && (err.code === 502 || err.code === 500);\n      const isHummingbird =\n        this.system && this.system.indexOf(\"hummingbird\") > -1;\n      if (errored || isHummingbird) {\n        // Not sure if the 'hummingbird' system check ^^^ is still\n        // necessary. If they support any standards, the 500 error\n        // should have us covered. Let's leave it for now.\n        this.useList = true;\n        this.list(filePath, entriesToList);\n      } else {\n        entriesToList(err, data);\n      }\n    });\n  }\n};\n\nFtp.prototype.rename = function(from, to, callback) {\n  this.raw(\"rnfr\", from, err => {\n    if (err) {\n      return callback(err);\n    }\n    this.raw(\"rnto\", to, callback);\n  });\n};\n\nFtp.prototype.keepAlive = function(wait) {\n  if (this._keepAliveInterval) {\n    clearInterval(this._keepAliveInterval);\n  }\n\n  this._keepAliveInterval = setInterval(\n    this.raw.bind(this, \"noop\"),\n    wait || IDLE_TIME\n  );\n};\n\nFtp.prototype.destroy = function() {\n  if (this._keepAliveInterval) {\n    clearInterval(this._keepAliveInterval);\n  }\n\n  if (this.socket && this.socket.writable) {\n    this.socket.end();\n  }\n\n  if (this._pasvSocket && this._pasvSocket.writable) {\n    this._pasvSocket.end();\n  }\n\n  this.resParser.end();\n\n  this.socket = undefined;\n  this._pasvSocket = undefined;\n\n  this.features = null;\n  this.authenticated = false;\n};\n\nmodule.exports = Ftp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}