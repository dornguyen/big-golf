{"ast":null,"code":"/**\n * node-crc32-stream\n *\n * Copyright (c) 2014 Chris Talkington, contributors.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/node-crc32-stream/blob/master/LICENSE-MIT\n */\n\n'use strict';\n\nconst {\n  Transform\n} = require('readable-stream');\nconst crc32 = require('crc-32');\nclass CRC32Stream extends Transform {\n  constructor(options) {\n    super(options);\n    this.checksum = Buffer.allocUnsafe(4);\n    this.checksum.writeInt32BE(0, 0);\n    this.rawSize = 0;\n  }\n  _transform(chunk, encoding, callback) {\n    if (chunk) {\n      this.checksum = crc32.buf(chunk, this.checksum) >>> 0;\n      this.rawSize += chunk.length;\n    }\n    callback(null, chunk);\n  }\n  digest(encoding) {\n    const checksum = Buffer.allocUnsafe(4);\n    checksum.writeUInt32BE(this.checksum >>> 0, 0);\n    return encoding ? checksum.toString(encoding) : checksum;\n  }\n  hex() {\n    return this.digest('hex').toUpperCase();\n  }\n  size() {\n    return this.rawSize;\n  }\n}\nmodule.exports = CRC32Stream;","map":{"version":3,"names":["Transform","require","crc32","CRC32Stream","constructor","options","checksum","Buffer","allocUnsafe","writeInt32BE","rawSize","_transform","chunk","encoding","callback","buf","length","digest","writeUInt32BE","toString","hex","toUpperCase","size","module","exports"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/crc32-stream/lib/crc32-stream.js"],"sourcesContent":["/**\n * node-crc32-stream\n *\n * Copyright (c) 2014 Chris Talkington, contributors.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/node-crc32-stream/blob/master/LICENSE-MIT\n */\n\n 'use strict';\n\nconst {Transform} = require('readable-stream');\n\nconst crc32 = require('crc-32');\n\nclass CRC32Stream extends Transform {\n  constructor(options) {\n    super(options);\n    this.checksum = Buffer.allocUnsafe(4);\n    this.checksum.writeInt32BE(0, 0);\n\n    this.rawSize = 0;\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (chunk) {\n      this.checksum = crc32.buf(chunk, this.checksum) >>> 0;\n      this.rawSize += chunk.length;\n    }\n\n    callback(null, chunk);\n  }\n\n  digest(encoding) {\n    const checksum = Buffer.allocUnsafe(4);\n    checksum.writeUInt32BE(this.checksum >>> 0, 0);\n    return encoding ? checksum.toString(encoding) : checksum;\n  }\n\n  hex() {\n    return this.digest('hex').toUpperCase();\n  }\n\n  size() {\n    return this.rawSize;\n  }\n}\n\nmodule.exports = CRC32Stream;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC,YAAY;;AAEb,MAAM;EAACA;AAAS,CAAC,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAE9C,MAAMC,KAAK,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAE/B,MAAME,WAAW,SAASH,SAAS,CAAC;EAClCI,WAAW,CAACC,OAAO,EAAE;IACnB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACC,QAAQ,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;IACrC,IAAI,CAACF,QAAQ,CAACG,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC;IAEhC,IAAI,CAACC,OAAO,GAAG,CAAC;EAClB;EAEAC,UAAU,CAACC,KAAK,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;IACpC,IAAIF,KAAK,EAAE;MACT,IAAI,CAACN,QAAQ,GAAGJ,KAAK,CAACa,GAAG,CAACH,KAAK,EAAE,IAAI,CAACN,QAAQ,CAAC,KAAK,CAAC;MACrD,IAAI,CAACI,OAAO,IAAIE,KAAK,CAACI,MAAM;IAC9B;IAEAF,QAAQ,CAAC,IAAI,EAAEF,KAAK,CAAC;EACvB;EAEAK,MAAM,CAACJ,QAAQ,EAAE;IACf,MAAMP,QAAQ,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;IACtCF,QAAQ,CAACY,aAAa,CAAC,IAAI,CAACZ,QAAQ,KAAK,CAAC,EAAE,CAAC,CAAC;IAC9C,OAAOO,QAAQ,GAAGP,QAAQ,CAACa,QAAQ,CAACN,QAAQ,CAAC,GAAGP,QAAQ;EAC1D;EAEAc,GAAG,GAAG;IACJ,OAAO,IAAI,CAACH,MAAM,CAAC,KAAK,CAAC,CAACI,WAAW,EAAE;EACzC;EAEAC,IAAI,GAAG;IACL,OAAO,IAAI,CAACZ,OAAO;EACrB;AACF;AAEAa,MAAM,CAACC,OAAO,GAAGrB,WAAW"},"metadata":{},"sourceType":"script"}