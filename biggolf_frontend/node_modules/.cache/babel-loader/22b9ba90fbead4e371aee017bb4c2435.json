{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"iq\", [], factory);else if (typeof exports === 'object') exports[\"iq\"] = factory();else root[\"iq\"] = factory();\n})(this, function () {\n  return (/******/function (modules) {\n      // webpackBootstrap\n      /******/ // The module cache\n      /******/\n      var installedModules = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __webpack_require__(moduleId) {\n        /******/\n        /******/ // Check if module is in cache\n        /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;\n        /******/\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n          /******/exports: {},\n          /******/id: moduleId,\n          /******/loaded: false\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.loaded = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /******/\n      /******/ // expose the modules object (__webpack_modules__)\n      /******/\n      __webpack_require__.m = modules;\n      /******/\n      /******/ // expose the module cache\n      /******/\n      __webpack_require__.c = installedModules;\n      /******/\n      /******/ // __webpack_public_path__\n      /******/\n      __webpack_require__.p = \"\";\n      /******/\n      /******/ // Load entry module and return exports\n      /******/\n      return __webpack_require__(0);\n      /******/\n    }\n    /************************************************************************/\n    /******/([/* 0 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * iq.ts - Image Quantization Library\r\n       */\n      var constants = __webpack_require__(1);\n      exports.constants = constants;\n      var conversion = __webpack_require__(3);\n      exports.conversion = conversion;\n      var distance = __webpack_require__(12);\n      exports.distance = distance;\n      var palette = __webpack_require__(20);\n      exports.palette = palette;\n      var image = __webpack_require__(30);\n      exports.image = image;\n      var quality = __webpack_require__(35);\n      exports.quality = quality;\n      var utils = __webpack_require__(37);\n      exports.utils = utils;\n\n      /***/\n    }, /* 1 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * constants.ts - part of Image Quantization Library\r\n       */\n      var bt709 = __webpack_require__(2);\n      exports.bt709 = bt709;\n\n      /***/\n    }, /* 2 */\n    /***/function (module, exports) {\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * constants.ts - part of Image Quantization Library\r\n       */\n      \"use strict\";\n\n      /**\r\n       * sRGB (based on ITU-R Recommendation BT.709)\r\n       * http://en.wikipedia.org/wiki/SRGB\r\n       */\n      var Y;\n      (function (Y) {\n        Y[Y[\"RED\"] = 0.2126] = \"RED\";\n        Y[Y[\"GREEN\"] = 0.7152] = \"GREEN\";\n        Y[Y[\"BLUE\"] = 0.0722] = \"BLUE\";\n        Y[Y[\"WHITE\"] = 1] = \"WHITE\";\n      })(Y || (Y = {}));\n      exports.Y = Y;\n      var x;\n      (function (x) {\n        x[x[\"RED\"] = 0.64] = \"RED\";\n        x[x[\"GREEN\"] = 0.3] = \"GREEN\";\n        x[x[\"BLUE\"] = 0.15] = \"BLUE\";\n        x[x[\"WHITE\"] = 0.3127] = \"WHITE\";\n      })(x || (x = {}));\n      exports.x = x;\n      var y;\n      (function (y) {\n        y[y[\"RED\"] = 0.33] = \"RED\";\n        y[y[\"GREEN\"] = 0.6] = \"GREEN\";\n        y[y[\"BLUE\"] = 0.06] = \"BLUE\";\n        y[y[\"WHITE\"] = 0.329] = \"WHITE\";\n      })(y || (y = {}));\n      exports.y = y;\n\n      /***/\n    }, /* 3 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * iq.ts - Image Quantization Library\r\n       */\n      var rgb2xyz_1 = __webpack_require__(4);\n      exports.rgb2xyz = rgb2xyz_1.rgb2xyz;\n      var rgb2hsl_1 = __webpack_require__(5);\n      exports.rgb2hsl = rgb2hsl_1.rgb2hsl;\n      var rgb2lab_1 = __webpack_require__(7);\n      exports.rgb2lab = rgb2lab_1.rgb2lab;\n      var lab2xyz_1 = __webpack_require__(9);\n      exports.lab2xyz = lab2xyz_1.lab2xyz;\n      var lab2rgb_1 = __webpack_require__(10);\n      exports.lab2rgb = lab2rgb_1.lab2rgb;\n      var xyz2lab_1 = __webpack_require__(8);\n      exports.xyz2lab = xyz2lab_1.xyz2lab;\n      var xyz2rgb_1 = __webpack_require__(11);\n      exports.xyz2rgb = xyz2rgb_1.xyz2rgb;\n\n      /***/\n    }, /* 4 */\n    /***/function (module, exports) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * rgb2xyz.ts - part of Image Quantization Library\r\n       */\n      function correctGamma(n) {\n        return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;\n      }\n      function rgb2xyz(r, g, b) {\n        // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\n        r = correctGamma(r / 255);\n        g = correctGamma(g / 255);\n        b = correctGamma(b / 255);\n        // Observer. = 2째, Illuminant = D65\n        return {\n          x: r * 0.4124 + g * 0.3576 + b * 0.1805,\n          y: r * 0.2126 + g * 0.7152 + b * 0.0722,\n          z: r * 0.0193 + g * 0.1192 + b * 0.9505\n        };\n      }\n      exports.rgb2xyz = rgb2xyz;\n\n      /***/\n    }, /* 5 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * rgb2hsl.ts - part of Image Quantization Library\r\n       */\n      var arithmetic_1 = __webpack_require__(6);\n      /**\r\n       * Calculate HSL from RGB\r\n       * Hue is in degrees [0..360]\r\n       * Lightness: [0..1]\r\n       * Saturation: [0..1]\r\n       * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\r\n       */\n      function rgb2hsl(r, g, b) {\n        var min = arithmetic_1.min3(r, g, b),\n          max = arithmetic_1.max3(r, g, b),\n          delta = max - min,\n          l = (min + max) / 510;\n        var s = 0;\n        if (l > 0 && l < 1) s = delta / (l < 0.5 ? max + min : 510 - max - min);\n        var h = 0;\n        if (delta > 0) {\n          if (max === r) {\n            h = (g - b) / delta;\n          } else if (max === g) {\n            h = 2 + (b - r) / delta;\n          } else {\n            h = 4 + (r - g) / delta;\n          }\n          h *= 60;\n          if (h < 0) h += 360;\n        }\n        return {\n          h: h,\n          s: s,\n          l: l\n        };\n      }\n      exports.rgb2hsl = rgb2hsl;\n\n      /***/\n    }, /* 6 */\n    /***/function (module, exports) {\n      \"use strict\";\n\n      function degrees2radians(n) {\n        return n * (Math.PI / 180);\n      }\n      exports.degrees2radians = degrees2radians;\n      function max3(a, b, c) {\n        var m = a;\n        m < b && (m = b);\n        m < c && (m = c);\n        return m;\n      }\n      exports.max3 = max3;\n      function min3(a, b, c) {\n        var m = a;\n        m > b && (m = b);\n        m > c && (m = c);\n        return m;\n      }\n      exports.min3 = min3;\n      function intInRange(value, low, high) {\n        if (value > high) value = high;\n        if (value < low) value = low;\n        return value | 0;\n      }\n      exports.intInRange = intInRange;\n      function inRange0to255Rounded(n) {\n        n = Math.round(n);\n        if (n > 255) n = 255;else if (n < 0) n = 0;\n        return n;\n      }\n      exports.inRange0to255Rounded = inRange0to255Rounded;\n      function inRange0to255(n) {\n        if (n > 255) n = 255;else if (n < 0) n = 0;\n        return n;\n      }\n      exports.inRange0to255 = inRange0to255;\n      function stableSort(arrayToSort, callback) {\n        var type = typeof arrayToSort[0];\n        var sorted;\n        if (type === \"number\" || type === \"string\") {\n          var ord_1 = Object.create(null);\n          for (var i = 0, l = arrayToSort.length; i < l; i++) {\n            var val = arrayToSort[i];\n            if (ord_1[val] || ord_1[val] === 0) continue;\n            ord_1[val] = i;\n          }\n          sorted = arrayToSort.sort(function (a, b) {\n            return callback(a, b) || ord_1[a] - ord_1[b];\n          });\n        } else {\n          var ord2_1 = arrayToSort.slice(0);\n          sorted = arrayToSort.sort(function (a, b) {\n            return callback(a, b) || ord2_1.indexOf(a) - ord2_1.indexOf(b);\n          });\n        }\n        return sorted;\n      }\n      exports.stableSort = stableSort;\n\n      /***/\n    }, /* 7 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * rgb2lab.ts - part of Image Quantization Library\r\n       */\n      var rgb2xyz_1 = __webpack_require__(4);\n      var xyz2lab_1 = __webpack_require__(8);\n      function rgb2lab(r, g, b) {\n        var xyz = rgb2xyz_1.rgb2xyz(r, g, b);\n        return xyz2lab_1.xyz2lab(xyz.x, xyz.y, xyz.z);\n      }\n      exports.rgb2lab = rgb2lab;\n\n      /***/\n    }, /* 8 */\n    /***/function (module, exports) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * xyz2lab.ts - part of Image Quantization Library\r\n       */\n      var refX = 0.95047,\n        //ref_X =  95.047   Observer= 2째, Illuminant= D65\n        refY = 1.00000,\n        //ref_Y = 100.000\n        refZ = 1.08883; //ref_Z = 108.883\n      function pivot(n) {\n        return n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;\n      }\n      function xyz2lab(x, y, z) {\n        x = pivot(x / refX);\n        y = pivot(y / refY);\n        z = pivot(z / refZ);\n        if (116 * y - 16 < 0) throw new Error(\"xxx\");\n        return {\n          L: Math.max(0, 116 * y - 16),\n          a: 500 * (x - y),\n          b: 200 * (y - z)\n        };\n      }\n      exports.xyz2lab = xyz2lab;\n\n      /***/\n    }, /* 9 */\n    /***/function (module, exports) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * lab2xyz.ts - part of Image Quantization Library\r\n       */\n      var refX = 0.95047,\n        //ref_X =  95.047   Observer= 2째, Illuminant = D65\n        refY = 1.00000,\n        //ref_Y = 100.000\n        refZ = 1.08883; //ref_Z = 108.883\n      function pivot(n) {\n        return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;\n      }\n      function lab2xyz(L, a, b) {\n        var y = (L + 16) / 116,\n          x = a / 500 + y,\n          z = y - b / 200;\n        return {\n          x: refX * pivot(x),\n          y: refY * pivot(y),\n          z: refZ * pivot(z)\n        };\n      }\n      exports.lab2xyz = lab2xyz;\n\n      /***/\n    }, /* 10 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * lab2rgb.ts - part of Image Quantization Library\r\n       */\n      var lab2xyz_1 = __webpack_require__(9);\n      var xyz2rgb_1 = __webpack_require__(11);\n      function lab2rgb(L, a, b) {\n        var xyz = lab2xyz_1.lab2xyz(L, a, b);\n        return xyz2rgb_1.xyz2rgb(xyz.x, xyz.y, xyz.z);\n      }\n      exports.lab2rgb = lab2rgb;\n\n      /***/\n    }, /* 11 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * xyz2rgb.ts - part of Image Quantization Library\r\n       */\n      var arithmetic_1 = __webpack_require__(6);\n      // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\n      function correctGamma(n) {\n        return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;\n      }\n      function xyz2rgb(x, y, z) {\n        // Observer. = 2째, Illuminant = D65\n        var r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986),\n          g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415),\n          b = correctGamma(x * 0.0557 + y * -0.2040 + z * 1.0570);\n        return {\n          r: arithmetic_1.inRange0to255Rounded(r * 255),\n          g: arithmetic_1.inRange0to255Rounded(g * 255),\n          b: arithmetic_1.inRange0to255Rounded(b * 255)\n        };\n      }\n      exports.xyz2rgb = xyz2rgb;\n\n      /***/\n    }, /* 12 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * iq.ts - Image Quantization Library\r\n       */\n      var abstractDistanceCalculator_1 = __webpack_require__(13);\n      exports.AbstractDistanceCalculator = abstractDistanceCalculator_1.AbstractDistanceCalculator;\n      var cie94_1 = __webpack_require__(14);\n      exports.CIE94Textiles = cie94_1.CIE94Textiles;\n      exports.CIE94GraphicArts = cie94_1.CIE94GraphicArts;\n      var ciede2000_1 = __webpack_require__(15);\n      exports.CIEDE2000 = ciede2000_1.CIEDE2000;\n      var cmetric_1 = __webpack_require__(16);\n      exports.CMETRIC = cmetric_1.CMETRIC;\n      var euclidean_1 = __webpack_require__(17);\n      exports.AbstractEuclidean = euclidean_1.AbstractEuclidean;\n      exports.Euclidean = euclidean_1.Euclidean;\n      exports.EuclideanRgbQuantWOAlpha = euclidean_1.EuclideanRgbQuantWOAlpha;\n      exports.EuclideanRgbQuantWithAlpha = euclidean_1.EuclideanRgbQuantWithAlpha;\n      var manhattan_1 = __webpack_require__(18);\n      exports.AbstractManhattan = manhattan_1.AbstractManhattan;\n      exports.Manhattan = manhattan_1.Manhattan;\n      exports.ManhattanSRGB = manhattan_1.ManhattanSRGB;\n      exports.ManhattanNommyde = manhattan_1.ManhattanNommyde;\n      var pngQuant_1 = __webpack_require__(19);\n      exports.PNGQUANT = pngQuant_1.PNGQUANT;\n\n      /***/\n    }, /* 13 */\n    /***/function (module, exports) {\n      \"use strict\";\n\n      var AbstractDistanceCalculator = function () {\n        function AbstractDistanceCalculator() {\n          this._setDefaults();\n          // set default maximal color component deltas (255 - 0 = 255)\n          this.setWhitePoint(255, 255, 255, 255);\n        }\n        AbstractDistanceCalculator.prototype.setWhitePoint = function (r, g, b, a) {\n          this._whitePoint = {\n            r: r > 0 ? 255 / r : 0,\n            g: g > 0 ? 255 / g : 0,\n            b: b > 0 ? 255 / b : 0,\n            a: a > 0 ? 255 / a : 0\n          };\n          this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\n        };\n        AbstractDistanceCalculator.prototype.calculateNormalized = function (colorA, colorB) {\n          return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\n        };\n        AbstractDistanceCalculator.prototype._setDefaults = function () {};\n        return AbstractDistanceCalculator;\n      }();\n      exports.AbstractDistanceCalculator = AbstractDistanceCalculator;\n\n      /***/\n    }, /* 14 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * cie94.ts - part of Image Quantization Library\r\n       */\n      var abstractDistanceCalculator_1 = __webpack_require__(13);\n      var rgb2lab_1 = __webpack_require__(7);\n      var arithmetic_1 = __webpack_require__(6);\n      /**\r\n       * CIE94 method of delta-e\r\n       * http://en.wikipedia.org/wiki/Color_difference#CIE94\r\n       */\n      var AbstractCIE94 = function (_super) {\n        __extends(AbstractCIE94, _super);\n        function AbstractCIE94() {\n          _super.apply(this, arguments);\n        }\n        AbstractCIE94.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\n          var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)),\n            lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b));\n          var dL = lab1.L - lab2.L,\n            dA = lab1.a - lab2.a,\n            dB = lab1.b - lab2.b,\n            c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b),\n            c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b),\n            dC = c1 - c2;\n          var deltaH = dA * dA + dB * dB - dC * dC;\n          deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n          var dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\n          // TODO: add alpha channel support\n          return Math.sqrt(Math.pow(dL / this._Kl, 2) + Math.pow(dC / (1.0 + this._K1 * c1), 2) + Math.pow(deltaH / (1.0 + this._K2 * c1), 2) + Math.pow(dAlpha, 2));\n        };\n        return AbstractCIE94;\n      }(abstractDistanceCalculator_1.AbstractDistanceCalculator);\n      exports.AbstractCIE94 = AbstractCIE94;\n      var CIE94Textiles = function (_super) {\n        __extends(CIE94Textiles, _super);\n        function CIE94Textiles() {\n          _super.apply(this, arguments);\n        }\n        CIE94Textiles.prototype._setDefaults = function () {\n          this._Kl = 2.0;\n          this._K1 = 0.048;\n          this._K2 = 0.014;\n          this._kA = 0.25 * 50 / 255;\n        };\n        return CIE94Textiles;\n      }(AbstractCIE94);\n      exports.CIE94Textiles = CIE94Textiles;\n      var CIE94GraphicArts = function (_super) {\n        __extends(CIE94GraphicArts, _super);\n        function CIE94GraphicArts() {\n          _super.apply(this, arguments);\n        }\n        CIE94GraphicArts.prototype._setDefaults = function () {\n          this._Kl = 1.0;\n          this._K1 = 0.045;\n          this._K2 = 0.015;\n          this._kA = 0.25 * 100 / 255;\n        };\n        return CIE94GraphicArts;\n      }(AbstractCIE94);\n      exports.CIE94GraphicArts = CIE94GraphicArts;\n\n      /***/\n    }, /* 15 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * ciede2000.ts - part of Image Quantization Library\r\n       */\n      var abstractDistanceCalculator_1 = __webpack_require__(13);\n      var rgb2lab_1 = __webpack_require__(7);\n      var arithmetic_1 = __webpack_require__(6);\n      /**\r\n       * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at\r\n       * http://www.ece.rochester.edu/~gsharma/ciede2000/\r\n       */\n      var CIEDE2000 = function (_super) {\n        __extends(CIEDE2000, _super);\n        function CIEDE2000() {\n          _super.apply(this, arguments);\n        }\n        CIEDE2000.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\n          var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)),\n            lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b)),\n            dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA,\n            dE2 = this.calculateRawInLab(lab1, lab2);\n          return Math.sqrt(dE2 + dA * dA);\n        };\n        CIEDE2000.prototype.calculateRawInLab = function (Lab1, Lab2) {\n          // Get L,a,b values for color 1\n          var L1 = Lab1.L,\n            a1 = Lab1.a,\n            b1 = Lab1.b;\n          // Get L,a,b values for color 2\n          var L2 = Lab2.L,\n            a2 = Lab2.a,\n            b2 = Lab2.b;\n          // Calculate Cprime1, Cprime2, Cabbar\n          var C1 = Math.sqrt(a1 * a1 + b1 * b1),\n            C2 = Math.sqrt(a2 * a2 + b2 * b2),\n            pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2.0, 7.0),\n            G = 0.5 * (1.0 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))),\n            //25^7\n            a1p = (1.0 + G) * a1,\n            a2p = (1.0 + G) * a2,\n            C1p = Math.sqrt(a1p * a1p + b1 * b1),\n            C2p = Math.sqrt(a2p * a2p + b2 * b2),\n            C1pC2p = C1p * C2p,\n            // Angles in Degree.\n            h1p = CIEDE2000._calculatehp(b1, a1p),\n            h2p = CIEDE2000._calculatehp(b2, a2p),\n            h_bar = Math.abs(h1p - h2p),\n            dLp = L2 - L1,\n            dCp = C2p - C1p,\n            dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p),\n            ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p),\n            T = CIEDE2000._calculateT(ahp),\n            aCp = (C1p + C2p) / 2.0,\n            aLp_minus_50_square = Math.pow((L1 + L2) / 2.0 - 50.0, 2.0),\n            S_L = 1.0 + .015 * aLp_minus_50_square / Math.sqrt(20.0 + aLp_minus_50_square),\n            S_C = 1.0 + .045 * aCp,\n            S_H = 1.0 + .015 * T * aCp,\n            R_T = CIEDE2000._calculateRT(ahp, aCp),\n            dLpSL = dLp / S_L,\n            // S_L * kL, where kL is 1.0\n            dCpSC = dCp / S_C,\n            // S_C * kC, where kC is 1.0\n            dHpSH = dHp / S_H; // S_H * kH, where kH is 1.0\n          return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;\n        };\n        CIEDE2000._calculatehp = function (b, ap) {\n          var hp = Math.atan2(b, ap);\n          if (hp >= 0) return hp;\n          return hp + CIEDE2000._deg360InRad;\n        };\n        CIEDE2000._calculateRT = function (ahp, aCp) {\n          var aCp_to_7 = Math.pow(aCp, 7.0),\n            R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)),\n            // 25^7\n            delta_theta = CIEDE2000._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad, 2.0));\n          return -Math.sin(2.0 * delta_theta) * R_C;\n        };\n        CIEDE2000._calculateT = function (ahp) {\n          return 1.0 - .17 * Math.cos(ahp - CIEDE2000._deg30InRad) + .24 * Math.cos(ahp * 2.0) + .32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) - .2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad);\n        };\n        CIEDE2000._calculate_ahp = function (C1pC2p, h_bar, h1p, h2p) {\n          var hpSum = h1p + h2p;\n          if (C1pC2p == 0) return hpSum;\n          if (h_bar <= CIEDE2000._deg180InRad) return hpSum / 2.0;\n          if (hpSum < CIEDE2000._deg360InRad) return (hpSum + CIEDE2000._deg360InRad) / 2.0;\n          return (hpSum - CIEDE2000._deg360InRad) / 2.0;\n        };\n        CIEDE2000._calculate_dHp = function (C1pC2p, h_bar, h2p, h1p) {\n          var dhp;\n          if (C1pC2p == 0) {\n            dhp = 0;\n          } else if (h_bar <= CIEDE2000._deg180InRad) {\n            dhp = h2p - h1p;\n          } else if (h2p <= h1p) {\n            dhp = h2p - h1p + CIEDE2000._deg360InRad;\n          } else {\n            dhp = h2p - h1p - CIEDE2000._deg360InRad;\n          }\n          return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\n        };\n        /**\r\n         * Weight in distance: 0.25\r\n         * Max DeltaE: 100\r\n         * Max DeltaA: 255\r\n         */\n        CIEDE2000._kA = 0.25 * 100 / 255;\n        CIEDE2000._pow25to7 = Math.pow(25, 7);\n        CIEDE2000._deg360InRad = arithmetic_1.degrees2radians(360);\n        CIEDE2000._deg180InRad = arithmetic_1.degrees2radians(180);\n        CIEDE2000._deg30InRad = arithmetic_1.degrees2radians(30);\n        CIEDE2000._deg6InRad = arithmetic_1.degrees2radians(6);\n        CIEDE2000._deg63InRad = arithmetic_1.degrees2radians(63);\n        CIEDE2000._deg275InRad = arithmetic_1.degrees2radians(275);\n        CIEDE2000._deg25InRad = arithmetic_1.degrees2radians(25);\n        return CIEDE2000;\n      }(abstractDistanceCalculator_1.AbstractDistanceCalculator);\n      exports.CIEDE2000 = CIEDE2000;\n\n      /***/\n    }, /* 16 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * cmetric.ts - part of Image Quantization Library\r\n       */\n      var abstractDistanceCalculator_1 = __webpack_require__(13);\n      /**\r\n       * TODO: Name it: http://www.compuphase.com/cmetric.htm\r\n       */\n      var CMETRIC = function (_super) {\n        __extends(CMETRIC, _super);\n        function CMETRIC() {\n          _super.apply(this, arguments);\n        }\n        CMETRIC.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\n          var rmean = (r1 + r2) / 2 * this._whitePoint.r,\n            r = (r1 - r2) * this._whitePoint.r,\n            g = (g1 - g2) * this._whitePoint.g,\n            b = (b1 - b2) * this._whitePoint.b,\n            dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8),\n            dA = (a2 - a1) * this._whitePoint.a;\n          return Math.sqrt(dE + dA * dA);\n        };\n        return CMETRIC;\n      }(abstractDistanceCalculator_1.AbstractDistanceCalculator);\n      exports.CMETRIC = CMETRIC;\n\n      /***/\n    }, /* 17 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * euclidean.ts - part of Image Quantization Library\r\n       */\n      var abstractDistanceCalculator_1 = __webpack_require__(13);\n      var bt709_1 = __webpack_require__(2);\n      /**\r\n       * Euclidean color distance\r\n       */\n      var AbstractEuclidean = function (_super) {\n        __extends(AbstractEuclidean, _super);\n        function AbstractEuclidean() {\n          _super.apply(this, arguments);\n        }\n        AbstractEuclidean.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\n          var dR = r2 - r1,\n            dG = g2 - g1,\n            dB = b2 - b1,\n            dA = a2 - a1;\n          return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\n        };\n        return AbstractEuclidean;\n      }(abstractDistanceCalculator_1.AbstractDistanceCalculator);\n      exports.AbstractEuclidean = AbstractEuclidean;\n      var Euclidean = function (_super) {\n        __extends(Euclidean, _super);\n        function Euclidean() {\n          _super.apply(this, arguments);\n        }\n        Euclidean.prototype._setDefaults = function () {\n          this._kR = 1;\n          this._kG = 1;\n          this._kB = 1;\n          this._kA = 1;\n        };\n        return Euclidean;\n      }(AbstractEuclidean);\n      exports.Euclidean = Euclidean;\n      /**\r\n       * Euclidean color distance (RgbQuant modification w Alpha)\r\n       */\n      var EuclideanRgbQuantWithAlpha = function (_super) {\n        __extends(EuclideanRgbQuantWithAlpha, _super);\n        function EuclideanRgbQuantWithAlpha() {\n          _super.apply(this, arguments);\n        }\n        EuclideanRgbQuantWithAlpha.prototype._setDefaults = function () {\n          this._kR = bt709_1.Y.RED;\n          this._kG = bt709_1.Y.GREEN;\n          this._kB = bt709_1.Y.BLUE;\n          // TODO: what is the best coefficient below?\n          this._kA = 1;\n        };\n        return EuclideanRgbQuantWithAlpha;\n      }(AbstractEuclidean);\n      exports.EuclideanRgbQuantWithAlpha = EuclideanRgbQuantWithAlpha;\n      /**\r\n       * Euclidean color distance (RgbQuant modification w/o Alpha)\r\n       */\n      var EuclideanRgbQuantWOAlpha = function (_super) {\n        __extends(EuclideanRgbQuantWOAlpha, _super);\n        function EuclideanRgbQuantWOAlpha() {\n          _super.apply(this, arguments);\n        }\n        EuclideanRgbQuantWOAlpha.prototype._setDefaults = function () {\n          this._kR = bt709_1.Y.RED;\n          this._kG = bt709_1.Y.GREEN;\n          this._kB = bt709_1.Y.BLUE;\n          this._kA = 0;\n        };\n        return EuclideanRgbQuantWOAlpha;\n      }(AbstractEuclidean);\n      exports.EuclideanRgbQuantWOAlpha = EuclideanRgbQuantWOAlpha;\n\n      /***/\n    }, /* 18 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * manhattanNeuQuant.ts - part of Image Quantization Library\r\n       */\n      var abstractDistanceCalculator_1 = __webpack_require__(13);\n      var bt709_1 = __webpack_require__(2);\n      /**\r\n       * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\r\n       */\n      var AbstractManhattan = function (_super) {\n        __extends(AbstractManhattan, _super);\n        function AbstractManhattan() {\n          _super.apply(this, arguments);\n        }\n        AbstractManhattan.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\n          var dR = r2 - r1,\n            dG = g2 - g1,\n            dB = b2 - b1,\n            dA = a2 - a1;\n          if (dR < 0) dR = 0 - dR;\n          if (dG < 0) dG = 0 - dG;\n          if (dB < 0) dB = 0 - dB;\n          if (dA < 0) dA = 0 - dA;\n          return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\n        };\n        return AbstractManhattan;\n      }(abstractDistanceCalculator_1.AbstractDistanceCalculator);\n      exports.AbstractManhattan = AbstractManhattan;\n      var Manhattan = function (_super) {\n        __extends(Manhattan, _super);\n        function Manhattan() {\n          _super.apply(this, arguments);\n        }\n        Manhattan.prototype._setDefaults = function () {\n          this._kR = 1;\n          this._kG = 1;\n          this._kB = 1;\n          this._kA = 1;\n        };\n        return Manhattan;\n      }(AbstractManhattan);\n      exports.Manhattan = Manhattan;\n      /**\r\n       * Manhattan distance (Nommyde modification)\r\n       * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\r\n       */\n      var ManhattanNommyde = function (_super) {\n        __extends(ManhattanNommyde, _super);\n        function ManhattanNommyde() {\n          _super.apply(this, arguments);\n        }\n        ManhattanNommyde.prototype._setDefaults = function () {\n          this._kR = 0.4984;\n          this._kG = 0.8625;\n          this._kB = 0.2979;\n          // TODO: what is the best coefficient below?\n          this._kA = 1;\n        };\n        return ManhattanNommyde;\n      }(AbstractManhattan);\n      exports.ManhattanNommyde = ManhattanNommyde;\n      /**\r\n       * Manhattan distance (sRGB coefficients)\r\n       */\n      var ManhattanSRGB = function (_super) {\n        __extends(ManhattanSRGB, _super);\n        function ManhattanSRGB() {\n          _super.apply(this, arguments);\n        }\n        ManhattanSRGB.prototype._setDefaults = function () {\n          this._kR = bt709_1.Y.RED;\n          this._kG = bt709_1.Y.GREEN;\n          this._kB = bt709_1.Y.BLUE;\n          // TODO: what is the best coefficient below?\n          this._kA = 1;\n        };\n        return ManhattanSRGB;\n      }(AbstractManhattan);\n      exports.ManhattanSRGB = ManhattanSRGB;\n\n      /***/\n    }, /* 19 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * pngQuant.ts - part of Image Quantization Library\r\n       */\n      var abstractDistanceCalculator_1 = __webpack_require__(13);\n      /**\r\n       * TODO: check quality of this distance equation\r\n       * TODO: ask author for usage rights\r\n       * taken from:\r\n       * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\r\n       * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\r\n       */\n      var PNGQUANT = function (_super) {\n        __extends(PNGQUANT, _super);\n        function PNGQUANT() {\n          _super.apply(this, arguments);\n        }\n        /**\r\n         * Author's comments\r\n         * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\r\n         * px_b.a   = px.a   + 1*(1-px.a)\r\n         * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\r\n         * px_w.a   = px.a   + 1*(1-px.a)\r\n            * px_b.rgb = px.rgb              // difference same as in opaque RGB\r\n         * px_b.a   = 1\r\n         * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\r\n         * px_w.a   = 1\r\n            * (px.rgb - px.a) - (py.rgb - py.a)\r\n         * (px.rgb - py.rgb) + (py.a - px.a)\r\n         *\r\n         */\n        PNGQUANT.prototype.calculateRaw = function (r1, g1, b1, a1, r2, g2, b2, a2) {\n          var alphas = (a2 - a1) * this._whitePoint.a;\n          return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\n        };\n        PNGQUANT.prototype._colordifference_ch = function (x, y, alphas) {\n          // maximum of channel blended on white, and blended on black\n          // premultiplied alpha and backgrounds 0/1 shorten the formula\n          var black = x - y,\n            white = black + alphas;\n          return black * black + white * white;\n        };\n        return PNGQUANT;\n      }(abstractDistanceCalculator_1.AbstractDistanceCalculator);\n      exports.PNGQUANT = PNGQUANT;\n\n      /***/\n    }, /* 20 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var neuquant_1 = __webpack_require__(21);\n      exports.NeuQuant = neuquant_1.NeuQuant;\n      var neuquantFloat_1 = __webpack_require__(25);\n      exports.NeuQuantFloat = neuquantFloat_1.NeuQuantFloat;\n      var rgbquant_1 = __webpack_require__(26);\n      exports.RGBQuant = rgbquant_1.RGBQuant;\n      var colorHistogram_1 = __webpack_require__(27);\n      exports.ColorHistogram = colorHistogram_1.ColorHistogram;\n      var wuQuant_1 = __webpack_require__(29);\n      exports.WuQuant = wuQuant_1.WuQuant;\n      exports.WuColorCube = wuQuant_1.WuColorCube;\n\n      /***/\n    }, /* 21 */\n    /***/function (module, exports, __webpack_require__) {\n      /*\r\n       * NeuQuant Neural-Net Quantization Algorithm\r\n       * ------------------------------------------\r\n       *\r\n       * Copyright (c) 1994 Anthony Dekker\r\n       *\r\n       * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n       * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n       * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n       * the algorithm.\r\n       *\r\n       * Any party obtaining a copy of these files from the author, directly or\r\n       * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n       * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n       * this software and documentation files (the \"Software\"), including without\r\n       * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n       * sublicense, and/or sell copies of the Software, and to permit persons who\r\n       * receive copies from any such party to do so, with the only requirement being\r\n       * that this copyright notice remain intact.\r\n       */\n      \"use strict\";\n\n      /**\r\n       * @preserve TypeScript port:\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * neuquant.ts - part of Image Quantization Library\r\n       */\n      var palette_1 = __webpack_require__(22);\n      var point_1 = __webpack_require__(24);\n      // bias for colour values\n      var networkBiasShift = 3;\n      var Neuron = function () {\n        function Neuron(defaultValue) {\n          this.r = this.g = this.b = this.a = defaultValue;\n        }\n        /**\r\n         * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n         * @example\r\n         * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n         */\n        Neuron.prototype.toPoint = function () {\n          return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\n        };\n        Neuron.prototype.subtract = function (r, g, b, a) {\n          this.r -= r | 0;\n          this.g -= g | 0;\n          this.b -= b | 0;\n          this.a -= a | 0;\n        };\n        return Neuron;\n      }();\n      var NeuQuant = function () {\n        function NeuQuant(colorDistanceCalculator, colors) {\n          if (colors === void 0) {\n            colors = 256;\n          }\n          this._distance = colorDistanceCalculator;\n          this._pointArray = [];\n          this._sampleFactor = 1;\n          this._networkSize = colors;\n          this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\n        }\n        NeuQuant.prototype.sample = function (pointBuffer) {\n          this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());\n        };\n        NeuQuant.prototype.quantize = function () {\n          this._init();\n          this._learn();\n          return this._buildPalette();\n        };\n        NeuQuant.prototype._init = function () {\n          this._freq = [];\n          this._bias = [];\n          this._radPower = [];\n          this._network = [];\n          for (var i = 0; i < this._networkSize; i++) {\n            this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);\n            // 1/this._networkSize\n            this._freq[i] = NeuQuant._initialBias / this._networkSize | 0;\n            this._bias[i] = 0;\n          }\n        };\n        /**\r\n         * Main Learning Loop\r\n         */\n        NeuQuant.prototype._learn = function () {\n          var sampleFactor = this._sampleFactor;\n          var pointsNumber = this._pointArray.length;\n          if (pointsNumber < NeuQuant._minpicturebytes) sampleFactor = 1;\n          var alphadec = 30 + (sampleFactor - 1) / 3 | 0,\n            pointsToSample = pointsNumber / sampleFactor | 0;\n          var delta = pointsToSample / NeuQuant._nCycles | 0,\n            alpha = NeuQuant._initAlpha,\n            radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\n          var rad = radius >> NeuQuant._radiusBiasShift;\n          if (rad <= 1) rad = 0;\n          for (var i = 0; i < rad; i++) {\n            this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuant._radBias / (rad * rad)) >>> 0;\n          }\n          var step;\n          if (pointsNumber < NeuQuant._minpicturebytes) {\n            step = 1;\n          } else if (pointsNumber % NeuQuant._prime1 != 0) {\n            step = NeuQuant._prime1;\n          } else if (pointsNumber % NeuQuant._prime2 != 0) {\n            step = NeuQuant._prime2;\n          } else if (pointsNumber % NeuQuant._prime3 != 0) {\n            step = NeuQuant._prime3;\n          } else {\n            step = NeuQuant._prime4;\n          }\n          for (var i = 0, pointIndex = 0; i < pointsToSample;) {\n            var point = this._pointArray[pointIndex],\n              b = point.b << networkBiasShift,\n              g = point.g << networkBiasShift,\n              r = point.r << networkBiasShift,\n              a = point.a << networkBiasShift,\n              neuronIndex = this._contest(b, g, r, a);\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\n            if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n            /* alter neighbours */\n            pointIndex += step;\n            if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n            i++;\n            if (delta === 0) delta = 1;\n            if (i % delta === 0) {\n              alpha -= alpha / alphadec | 0;\n              radius -= radius / NeuQuant._radiusDecrease | 0;\n              rad = radius >> NeuQuant._radiusBiasShift;\n              if (rad <= 1) rad = 0;\n              for (var j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuant._radBias / (rad * rad)) >>> 0;\n            }\n          }\n        };\n        NeuQuant.prototype._buildPalette = function () {\n          var palette = new palette_1.Palette();\n          this._network.forEach(function (neuron) {\n            palette.add(neuron.toPoint());\n          });\n          palette.sort();\n          return palette;\n        };\n        /**\r\n         * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n         */\n        NeuQuant.prototype._alterNeighbour = function (rad, i, b, g, r, al) {\n          var lo = i - rad;\n          if (lo < -1) lo = -1;\n          var hi = i + rad;\n          if (hi > this._networkSize) hi = this._networkSize;\n          var j = i + 1,\n            k = i - 1,\n            m = 1;\n          while (j < hi || k > lo) {\n            var a = this._radPower[m++] / NeuQuant._alphaRadBias;\n            if (j < hi) {\n              var p = this._network[j++];\n              p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n            }\n            if (k > lo) {\n              var p = this._network[k--];\n              p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n            }\n          }\n        };\n        /**\r\n         * Move neuron i towards biased (b,g,r) by factor alpha\r\n         */\n        NeuQuant.prototype._alterSingle = function (alpha, i, b, g, r, a) {\n          alpha /= NeuQuant._initAlpha;\n          /* alter hit neuron */\n          var n = this._network[i];\n          n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n        };\n        /**\r\n         * Search for biased BGR values\r\n         * description:\r\n         *    finds closest neuron (min dist) and updates freq\r\n         *    finds best neuron (min dist-bias) and returns position\r\n         *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n         *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n         *\r\n         * Original distance equation:\r\n         *        dist = abs(dR) + abs(dG) + abs(dB)\r\n         */\n        NeuQuant.prototype._contest = function (b, g, r, a) {\n          var multiplier = 255 * 4 << networkBiasShift;\n          var bestd = ~(1 << 31),\n            bestbiasd = bestd,\n            bestpos = -1,\n            bestbiaspos = bestpos;\n          for (var i = 0; i < this._networkSize; i++) {\n            var n = this._network[i],\n              dist = this._distance.calculateNormalized(n, {\n                r: r,\n                g: g,\n                b: b,\n                a: a\n              }) * multiplier | 0;\n            if (dist < bestd) {\n              bestd = dist;\n              bestpos = i;\n            }\n            var biasdist = dist - (this._bias[i] >> NeuQuant._initialBiasShift - networkBiasShift);\n            if (biasdist < bestbiasd) {\n              bestbiasd = biasdist;\n              bestbiaspos = i;\n            }\n            var betafreq = this._freq[i] >> NeuQuant._betaShift;\n            this._freq[i] -= betafreq;\n            this._bias[i] += betafreq << NeuQuant._gammaShift;\n          }\n          this._freq[bestpos] += NeuQuant._beta;\n          this._bias[bestpos] -= NeuQuant._betaGamma;\n          return bestbiaspos;\n        };\n        /*\r\n         four primes near 500 - assume no image has a length so large\r\n         that it is divisible by all four primes\r\n         */\n        NeuQuant._prime1 = 499;\n        NeuQuant._prime2 = 491;\n        NeuQuant._prime3 = 487;\n        NeuQuant._prime4 = 503;\n        NeuQuant._minpicturebytes = NeuQuant._prime4;\n        // no. of learning cycles\n        NeuQuant._nCycles = 100;\n        // defs for freq and bias\n        NeuQuant._initialBiasShift = 16;\n        // bias for fractions\n        NeuQuant._initialBias = 1 << NeuQuant._initialBiasShift;\n        NeuQuant._gammaShift = 10;\n        // gamma = 1024\n        // TODO: why gamma is never used?\n        //private static _gamma : number     = (1 << NeuQuant._gammaShift);\n        NeuQuant._betaShift = 10;\n        NeuQuant._beta = NeuQuant._initialBias >> NeuQuant._betaShift;\n        // beta = 1/1024\n        NeuQuant._betaGamma = NeuQuant._initialBias << NeuQuant._gammaShift - NeuQuant._betaShift;\n        /*\r\n         * for 256 cols, radius starts\r\n         */\n        NeuQuant._radiusBiasShift = 6;\n        // at 32.0 biased by 6 bits\n        NeuQuant._radiusBias = 1 << NeuQuant._radiusBiasShift;\n        // and decreases by a factor of 1/30 each cycle\n        NeuQuant._radiusDecrease = 30;\n        /* defs for decreasing alpha factor */\n        // alpha starts at 1.0\n        NeuQuant._alphaBiasShift = 10;\n        // biased by 10 bits\n        NeuQuant._initAlpha = 1 << NeuQuant._alphaBiasShift;\n        /* radBias and alphaRadBias used for radpower calculation */\n        NeuQuant._radBiasShift = 8;\n        NeuQuant._radBias = 1 << NeuQuant._radBiasShift;\n        NeuQuant._alphaRadBiasShift = NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\n        NeuQuant._alphaRadBias = 1 << NeuQuant._alphaRadBiasShift;\n        return NeuQuant;\n      }();\n      exports.NeuQuant = NeuQuant;\n\n      /***/\n    }, /* 22 */\n    /***/function (module, exports, __webpack_require__) {\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * palette.ts - part of Image Quantization Library\r\n       */\n      \"use strict\";\n\n      var pointContainer_1 = __webpack_require__(23);\n      var rgb2hsl_1 = __webpack_require__(5);\n      // TODO: make paletteArray via pointBuffer, so, export will be available via pointBuffer.exportXXX\n      var hueGroups = 10;\n      function hueGroup(hue, segmentsNumber) {\n        var maxHue = 360,\n          seg = maxHue / segmentsNumber,\n          half = seg / 2;\n        for (var i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n          if (hue >= mid && hue < mid + seg) return i;\n        }\n        return 0;\n      }\n      exports.hueGroup = hueGroup;\n      var Palette = function () {\n        function Palette() {\n          this._pointArray = [];\n          this._i32idx = {};\n          this._pointContainer = new pointContainer_1.PointContainer();\n          this._pointContainer.setHeight(1);\n          this._pointArray = this._pointContainer.getPointArray();\n        }\n        Palette.prototype.add = function (color) {\n          this._pointArray.push(color);\n          this._pointContainer.setWidth(this._pointArray.length);\n        };\n        Palette.prototype.has = function (color) {\n          for (var i = this._pointArray.length - 1; i >= 0; i--) {\n            if (color.uint32 === this._pointArray[i].uint32) return true;\n          }\n          return false;\n        };\n        // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\n        Palette.prototype.getNearestColor = function (colorDistanceCalculator, color) {\n          return this._pointArray[this.getNearestIndex(colorDistanceCalculator, color) | 0];\n        };\n        Palette.prototype.getPointContainer = function () {\n          return this._pointContainer;\n        };\n        // TOTRY: use HUSL - http://boronine.com/husl/\n        /*\r\n         public nearestIndexByUint32(i32) {\r\n         var idx : number = this._nearestPointFromCache(\"\" + i32);\r\n         if (idx >= 0) return idx;\r\n            var min = 1000,\r\n         rgb = [\r\n         (i32 & 0xff),\r\n         (i32 >>> 8) & 0xff,\r\n         (i32 >>> 16) & 0xff,\r\n         (i32 >>> 24) & 0xff\r\n         ],\r\n         len = this._pointArray.length;\r\n            idx = 0;\r\n         for (var i = 0; i < len; i++) {\r\n         var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\r\n            if (dist < min) {\r\n         min = dist;\r\n         idx = i;\r\n         }\r\n         }\r\n            this._i32idx[i32] = idx;\r\n         return idx;\r\n         }\r\n         */\n        Palette.prototype._nearestPointFromCache = function (key) {\n          return typeof this._i32idx[key] === \"number\" ? this._i32idx[key] : -1;\n        };\n        Palette.prototype.getNearestIndex = function (colorDistanceCalculator, point) {\n          var idx = this._nearestPointFromCache(\"\" + point.uint32);\n          if (idx >= 0) return idx;\n          var minimalDistance = Number.MAX_VALUE;\n          idx = 0;\n          for (var i = 0, l = this._pointArray.length; i < l; i++) {\n            var p = this._pointArray[i],\n              distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\n            if (distance < minimalDistance) {\n              minimalDistance = distance;\n              idx = i;\n            }\n          }\n          this._i32idx[point.uint32] = idx;\n          return idx;\n        };\n        /*\r\n         public reduce(histogram : ColorHistogram, colors : number) {\r\n         if (this._pointArray.length > colors) {\r\n         var idxi32 = histogram.getImportanceSortedColorsIDXI32();\r\n            // quantize histogram to existing palette\r\n         var keep = [], uniqueColors = 0, idx, pruned = false;\r\n            for (var i = 0, len = idxi32.length; i < len; i++) {\r\n         // palette length reached, unset all remaining colors (sparse palette)\r\n         if (uniqueColors >= colors) {\r\n         this.prunePal(keep);\r\n         pruned = true;\r\n         break;\r\n         } else {\r\n         idx = this.nearestIndexByUint32(idxi32[i]);\r\n         if (keep.indexOf(idx) < 0) {\r\n         keep.push(idx);\r\n         uniqueColors++;\r\n         }\r\n         }\r\n         }\r\n            if (!pruned) {\r\n         this.prunePal(keep);\r\n         }\r\n         }\r\n         }\r\n            // TODO: check usage, not tested!\r\n         public prunePal(keep : number[]) {\r\n         var colors = this._pointArray.length;\r\n         for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n         if (keep.indexOf(colorIndex) < 0) {\r\n            if(colorIndex + 1 < colors) {\r\n         this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\r\n         }\r\n         --colors;\r\n         //this._pointArray[colorIndex] = null;\r\n         }\r\n         }\r\n         console.log(\"colors pruned: \" + (this._pointArray.length - colors));\r\n         this._pointArray.length = colors;\r\n         this._i32idx = {};\r\n         }\r\n         */\n        // TODO: group very low lum and very high lum colors\n        // TODO: pass custom sort order\n        // TODO: sort criteria function should be placed to HueStats class\n        Palette.prototype.sort = function () {\n          this._i32idx = {};\n          this._pointArray.sort(function (a, b) {\n            var hslA = rgb2hsl_1.rgb2hsl(a.r, a.g, a.b),\n              hslB = rgb2hsl_1.rgb2hsl(b.r, b.g, b.b);\n            // sort all grays + whites together\n            var hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups),\n              hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n            /*\r\n             var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\r\n             var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\r\n             */\n            var hueDiff = hueB - hueA;\n            if (hueDiff) return -hueDiff;\n            /*\r\n             var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\r\n             if (lumDiff) return -lumDiff;\r\n             */\n            var lA = a.getLuminosity(true),\n              lB = b.getLuminosity(true);\n            if (lB - lA !== 0) return lB - lA;\n            var satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);\n            if (satDiff) return -satDiff;\n            return 0;\n          });\n        };\n        return Palette;\n      }();\n      exports.Palette = Palette;\n\n      /***/\n    }, /* 23 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * pointContainer.ts - part of Image Quantization Library\r\n       */\n      var point_1 = __webpack_require__(24);\n      /**\r\n       * v8 optimizations done.\r\n       * fromXXX methods are static to move out polymorphic code from class instance itself.\r\n       */\n      var PointContainer = function () {\n        function PointContainer() {\n          this._width = 0;\n          this._height = 0;\n          this._pointArray = [];\n        }\n        PointContainer.prototype.getWidth = function () {\n          return this._width;\n        };\n        PointContainer.prototype.getHeight = function () {\n          return this._height;\n        };\n        PointContainer.prototype.setWidth = function (width) {\n          this._width = width;\n        };\n        PointContainer.prototype.setHeight = function (height) {\n          this._height = height;\n        };\n        PointContainer.prototype.getPointArray = function () {\n          return this._pointArray;\n        };\n        PointContainer.prototype.clone = function () {\n          var clone = new PointContainer();\n          clone._width = this._width;\n          clone._height = this._height;\n          for (var i = 0, l = this._pointArray.length; i < l; i++) {\n            clone._pointArray[i] = point_1.Point.createByUint32(this._pointArray[i].uint32 | 0); // \"| 0\" is added for v8 optimization\n          }\n\n          return clone;\n        };\n        PointContainer.prototype.toUint32Array = function () {\n          var l = this._pointArray.length,\n            uint32Array = new Uint32Array(l);\n          for (var i = 0; i < l; i++) {\n            uint32Array[i] = this._pointArray[i].uint32;\n          }\n          return uint32Array;\n        };\n        PointContainer.prototype.toUint8Array = function () {\n          return new Uint8Array(this.toUint32Array().buffer);\n        };\n        PointContainer.fromHTMLImageElement = function (img) {\n          var width = img.naturalWidth,\n            height = img.naturalHeight;\n          var canvas = document.createElement(\"canvas\");\n          canvas.width = width;\n          canvas.height = height;\n          var ctx = canvas.getContext(\"2d\");\n          ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\n          return PointContainer.fromHTMLCanvasElement(canvas);\n        };\n        PointContainer.fromHTMLCanvasElement = function (canvas) {\n          var width = canvas.width,\n            height = canvas.height;\n          var ctx = canvas.getContext(\"2d\"),\n            imgData = ctx.getImageData(0, 0, width, height);\n          return PointContainer.fromImageData(imgData);\n        };\n        PointContainer.fromNodeCanvas = function (canvas) {\n          return PointContainer.fromHTMLCanvasElement(canvas);\n        };\n        PointContainer.fromImageData = function (imageData) {\n          var width = imageData.width,\n            height = imageData.height;\n          return PointContainer.fromCanvasPixelArray(imageData.data, width, height);\n          /*\r\n           var buf8;\r\n           if (Utils.typeOf(imageData.data) == \"CanvasPixelArray\")\r\n           buf8 = new Uint8Array(imageData.data);\r\n           else\r\n           buf8 = imageData.data;\r\n              this.fromUint32Array(new Uint32Array(buf8.buffer), width, height);\r\n           */\n        };\n\n        PointContainer.fromArray = function (byteArray, width, height) {\n          var uint8array = new Uint8Array(byteArray);\n          return PointContainer.fromUint8Array(uint8array, width, height);\n        };\n        PointContainer.fromCanvasPixelArray = function (data, width, height) {\n          return PointContainer.fromArray(data, width, height);\n        };\n        PointContainer.fromUint8Array = function (uint8array, width, height) {\n          return PointContainer.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);\n        };\n        PointContainer.fromUint32Array = function (uint32array, width, height) {\n          var container = new PointContainer();\n          container._width = width;\n          container._height = height;\n          for (var i = 0, l = uint32array.length; i < l; i++) {\n            container._pointArray[i] = point_1.Point.createByUint32(uint32array[i] | 0); // \"| 0\" is added for v8 optimization\n          }\n\n          return container;\n        };\n        return PointContainer;\n      }();\n      exports.PointContainer = PointContainer;\n\n      /***/\n    }, /* 24 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * point.ts - part of Image Quantization Library\r\n       */\n      var bt709_1 = __webpack_require__(2);\n      /**\r\n       * v8 optimized class\r\n       * 1) \"constructor\" should have initialization with worst types\r\n       * 2) \"set\" should have |0 / >>> 0\r\n       */\n      var Point = function () {\n        function Point() {\n          this.uint32 = -1 >>> 0;\n          this.r = this.g = this.b = this.a = 0;\n          this.rgba = new Array(4);\n          /*[ this.r , this.g , this.b , this.a ]*/\n          this.rgba[0] = 0;\n          this.rgba[1] = 0;\n          this.rgba[2] = 0;\n          this.rgba[3] = 0;\n          /*\r\n           this.Lab = {\r\n           L : 0.0,\r\n           a : 0.0,\r\n           b : 0.0\r\n           };\r\n           */\n        }\n\n        Point.createByQuadruplet = function (quadruplet) {\n          var point = new Point();\n          point.r = quadruplet[0] | 0;\n          point.g = quadruplet[1] | 0;\n          point.b = quadruplet[2] | 0;\n          point.a = quadruplet[3] | 0;\n          point._loadUINT32();\n          point._loadQuadruplet();\n          //point._loadLab();\n          return point;\n        };\n        Point.createByRGBA = function (red, green, blue, alpha) {\n          var point = new Point();\n          point.r = red | 0;\n          point.g = green | 0;\n          point.b = blue | 0;\n          point.a = alpha | 0;\n          point._loadUINT32();\n          point._loadQuadruplet();\n          //point._loadLab();\n          return point;\n        };\n        Point.createByUint32 = function (uint32) {\n          var point = new Point();\n          point.uint32 = uint32 >>> 0;\n          point._loadRGBA();\n          point._loadQuadruplet();\n          //point._loadLab();\n          return point;\n        };\n        Point.prototype.from = function (point) {\n          this.r = point.r;\n          this.g = point.g;\n          this.b = point.b;\n          this.a = point.a;\n          this.uint32 = point.uint32;\n          this.rgba[0] = point.r;\n          this.rgba[1] = point.g;\n          this.rgba[2] = point.b;\n          this.rgba[3] = point.a;\n          /*\r\n           this.Lab.L = point.Lab.L;\r\n           this.Lab.a = point.Lab.a;\r\n           this.Lab.b = point.Lab.b;\r\n           */\n        };\n        /*\r\n         * TODO:\r\n         Luminance from RGB:\r\n            Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\r\n         Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\r\n         Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\r\n         */\n        Point.prototype.getLuminosity = function (useAlphaChannel) {\n          var r = this.r,\n            g = this.g,\n            b = this.b;\n          if (useAlphaChannel) {\n            r = Math.min(255, 255 - this.a + this.a * r / 255);\n            g = Math.min(255, 255 - this.a + this.a * g / 255);\n            b = Math.min(255, 255 - this.a + this.a * b / 255);\n          }\n          //var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\n          /*\r\n           if(useAlphaChannel) {\r\n           luma = (luma * (255 - this.a)) / 255;\r\n           }\r\n           */\n          return r * bt709_1.Y.RED + g * bt709_1.Y.GREEN + b * bt709_1.Y.BLUE;\n        };\n        Point.prototype._loadUINT32 = function () {\n          this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\n        };\n        Point.prototype._loadRGBA = function () {\n          this.r = this.uint32 & 0xff;\n          this.g = this.uint32 >>> 8 & 0xff;\n          this.b = this.uint32 >>> 16 & 0xff;\n          this.a = this.uint32 >>> 24 & 0xff;\n        };\n        Point.prototype._loadQuadruplet = function () {\n          this.rgba[0] = this.r;\n          this.rgba[1] = this.g;\n          this.rgba[2] = this.b;\n          this.rgba[3] = this.a;\n          /*\r\n           var xyz = rgb2xyz(this.r, this.g, this.b);\r\n           var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\r\n           this.lab.l = lab.l;\r\n           this.lab.a = lab.a;\r\n           this.lab.b = lab.b;\r\n           */\n        };\n\n        return Point;\n      }();\n      exports.Point = Point;\n\n      /***/\n    }, /* 25 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /*\r\n       * NeuQuantFloat Neural-Net Quantization Algorithm\r\n       * ------------------------------------------\r\n       *\r\n       * Copyright (c) 1994 Anthony Dekker\r\n       *\r\n       * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n       * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n       * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n       * the algorithm.\r\n       *\r\n       * Any party obtaining a copy of these files from the author, directly or\r\n       * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n       * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n       * this software and documentation files (the \"Software\"), including without\r\n       * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n       * sublicense, and/or sell copies of the Software, and to permit persons who\r\n       * receive copies from any such party to do so, with the only requirement being\r\n       * that this copyright notice remain intact.\r\n       */\n      /**\r\n       * @preserve TypeScript port:\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * neuquant.ts - part of Image Quantization Library\r\n       */\n      var palette_1 = __webpack_require__(22);\n      var point_1 = __webpack_require__(24);\n      // bias for colour values\n      var networkBiasShift = 3;\n      var NeuronFloat = function () {\n        function NeuronFloat(defaultValue) {\n          this.r = this.g = this.b = this.a = defaultValue;\n        }\n        /**\r\n         * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n         * @example\r\n         * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n         */\n        NeuronFloat.prototype.toPoint = function () {\n          return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\n        };\n        NeuronFloat.prototype.subtract = function (r, g, b, a) {\n          this.r -= r;\n          this.g -= g;\n          this.b -= b;\n          this.a -= a;\n        };\n        return NeuronFloat;\n      }();\n      var NeuQuantFloat = function () {\n        function NeuQuantFloat(colorDistanceCalculator, colors) {\n          if (colors === void 0) {\n            colors = 256;\n          }\n          this._distance = colorDistanceCalculator;\n          this._pointArray = [];\n          this._sampleFactor = 1;\n          this._networkSize = colors;\n          this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\n        }\n        NeuQuantFloat.prototype.sample = function (pointBuffer) {\n          this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());\n        };\n        NeuQuantFloat.prototype.quantize = function () {\n          this._init();\n          this._learn();\n          return this._buildPalette();\n        };\n        NeuQuantFloat.prototype._init = function () {\n          this._freq = [];\n          this._bias = [];\n          this._radPower = [];\n          this._network = [];\n          for (var i = 0; i < this._networkSize; i++) {\n            this._network[i] = new NeuronFloat((i << networkBiasShift + 8) / this._networkSize);\n            // 1/this._networkSize\n            this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;\n            this._bias[i] = 0;\n          }\n        };\n        /**\r\n         * Main Learning Loop\r\n         */\n        NeuQuantFloat.prototype._learn = function () {\n          var sampleFactor = this._sampleFactor;\n          var pointsNumber = this._pointArray.length;\n          if (pointsNumber < NeuQuantFloat._minpicturebytes) sampleFactor = 1;\n          var alphadec = 30 + (sampleFactor - 1) / 3,\n            pointsToSample = pointsNumber / sampleFactor;\n          var delta = pointsToSample / NeuQuantFloat._nCycles | 0,\n            alpha = NeuQuantFloat._initAlpha,\n            radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\n          var rad = radius >> NeuQuantFloat._radiusBiasShift;\n          if (rad <= 1) rad = 0;\n          for (var i = 0; i < rad; i++) {\n            this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuantFloat._radBias / (rad * rad));\n          }\n          var step;\n          if (pointsNumber < NeuQuantFloat._minpicturebytes) {\n            step = 1;\n          } else if (pointsNumber % NeuQuantFloat._prime1 != 0) {\n            step = NeuQuantFloat._prime1;\n          } else if (pointsNumber % NeuQuantFloat._prime2 != 0) {\n            step = NeuQuantFloat._prime2;\n          } else if (pointsNumber % NeuQuantFloat._prime3 != 0) {\n            step = NeuQuantFloat._prime3;\n          } else {\n            step = NeuQuantFloat._prime4;\n          }\n          for (var i = 0, pointIndex = 0; i < pointsToSample;) {\n            var point = this._pointArray[pointIndex],\n              b = point.b << networkBiasShift,\n              g = point.g << networkBiasShift,\n              r = point.r << networkBiasShift,\n              a = point.a << networkBiasShift,\n              neuronIndex = this._contest(b, g, r, a);\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\n            if (rad != 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n            /* alter neighbours */\n            pointIndex += step;\n            if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n            i++;\n            if (delta == 0) delta = 1;\n            if (i % delta == 0) {\n              alpha -= alpha / alphadec;\n              radius -= radius / NeuQuantFloat._radiusDecrease;\n              rad = radius >> NeuQuantFloat._radiusBiasShift;\n              if (rad <= 1) rad = 0;\n              for (var j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuantFloat._radBias / (rad * rad));\n            }\n          }\n        };\n        NeuQuantFloat.prototype._buildPalette = function () {\n          var palette = new palette_1.Palette();\n          this._network.forEach(function (neuron) {\n            palette.add(neuron.toPoint());\n          });\n          palette.sort();\n          return palette;\n        };\n        /**\r\n         * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n         */\n        NeuQuantFloat.prototype._alterNeighbour = function (rad, i, b, g, r, al) {\n          var lo = i - rad;\n          if (lo < -1) lo = -1;\n          var hi = i + rad;\n          if (hi > this._networkSize) hi = this._networkSize;\n          var j = i + 1,\n            k = i - 1,\n            m = 1;\n          while (j < hi || k > lo) {\n            var a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;\n            if (j < hi) {\n              var p = this._network[j++];\n              p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n            }\n            if (k > lo) {\n              var p = this._network[k--];\n              p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n            }\n          }\n        };\n        /**\r\n         * Move neuron i towards biased (b,g,r) by factor alpha\r\n         */\n        NeuQuantFloat.prototype._alterSingle = function (alpha, i, b, g, r, a) {\n          alpha /= NeuQuantFloat._initAlpha;\n          /* alter hit neuron */\n          var n = this._network[i];\n          n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n        };\n        /**\r\n         * Search for biased BGR values\r\n         * description:\r\n         *    finds closest neuron (min dist) and updates freq\r\n         *    finds best neuron (min dist-bias) and returns position\r\n         *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n         *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n         *\r\n         * Original distance equation:\r\n         *        dist = abs(dR) + abs(dG) + abs(dB)\r\n         */\n        NeuQuantFloat.prototype._contest = function (b, g, r, al) {\n          var multiplier = 255 * 4 << networkBiasShift;\n          var bestd = ~(1 << 31),\n            bestbiasd = bestd,\n            bestpos = -1,\n            bestbiaspos = bestpos;\n          for (var i = 0; i < this._networkSize; i++) {\n            var n = this._network[i],\n              dist = this._distance.calculateNormalized(n, {\n                r: r,\n                g: g,\n                b: b,\n                a: al\n              }) * multiplier;\n            if (dist < bestd) {\n              bestd = dist;\n              bestpos = i;\n            }\n            var biasdist = dist - (this._bias[i] >> NeuQuantFloat._initialBiasShift - networkBiasShift);\n            if (biasdist < bestbiasd) {\n              bestbiasd = biasdist;\n              bestbiaspos = i;\n            }\n            var betafreq = this._freq[i] >> NeuQuantFloat._betaShift;\n            this._freq[i] -= betafreq;\n            this._bias[i] += betafreq << NeuQuantFloat._gammaShift;\n          }\n          this._freq[bestpos] += NeuQuantFloat._beta;\n          this._bias[bestpos] -= NeuQuantFloat._betaGamma;\n          return bestbiaspos;\n        };\n        /*\r\n         four primes near 500 - assume no image has a length so large\r\n         that it is divisible by all four primes\r\n         */\n        NeuQuantFloat._prime1 = 499;\n        NeuQuantFloat._prime2 = 491;\n        NeuQuantFloat._prime3 = 487;\n        NeuQuantFloat._prime4 = 503;\n        NeuQuantFloat._minpicturebytes = NeuQuantFloat._prime4;\n        // no. of learning cycles\n        NeuQuantFloat._nCycles = 100;\n        // defs for freq and bias\n        NeuQuantFloat._initialBiasShift = 16;\n        // bias for fractions\n        NeuQuantFloat._initialBias = 1 << NeuQuantFloat._initialBiasShift;\n        NeuQuantFloat._gammaShift = 10;\n        // gamma = 1024\n        // TODO: why gamma is never used?\n        //private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\n        NeuQuantFloat._betaShift = 10;\n        NeuQuantFloat._beta = NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift;\n        // beta = 1/1024\n        NeuQuantFloat._betaGamma = NeuQuantFloat._initialBias << NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift;\n        /*\r\n         * for 256 cols, radius starts\r\n         */\n        NeuQuantFloat._radiusBiasShift = 6;\n        // at 32.0 biased by 6 bits\n        NeuQuantFloat._radiusBias = 1 << NeuQuantFloat._radiusBiasShift;\n        // and decreases by a factor of 1/30 each cycle\n        NeuQuantFloat._radiusDecrease = 30;\n        /* defs for decreasing alpha factor */\n        // alpha starts at 1.0\n        NeuQuantFloat._alphaBiasShift = 10;\n        // biased by 10 bits\n        NeuQuantFloat._initAlpha = 1 << NeuQuantFloat._alphaBiasShift;\n        /* radBias and alphaRadBias used for radpower calculation */\n        NeuQuantFloat._radBiasShift = 8;\n        NeuQuantFloat._radBias = 1 << NeuQuantFloat._radBiasShift;\n        NeuQuantFloat._alphaRadBiasShift = NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\n        NeuQuantFloat._alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;\n        return NeuQuantFloat;\n      }();\n      exports.NeuQuantFloat = NeuQuantFloat;\n\n      /***/\n    }, /* 26 */\n    /***/function (module, exports, __webpack_require__) {\n      /*\r\n       * Copyright (c) 2015, Leon Sorokin\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * RgbQuant.js - an image quantization lib\r\n       */\n      \"use strict\";\n\n      /**\r\n       * @preserve TypeScript port:\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * rgbquant.ts - part of Image Quantization Library\r\n       */\n      var palette_1 = __webpack_require__(22);\n      var point_1 = __webpack_require__(24);\n      var colorHistogram_1 = __webpack_require__(27);\n      var arithmetic_1 = __webpack_require__(6);\n      var RemovedColor = function () {\n        function RemovedColor(index, color, distance) {\n          this.index = index;\n          this.color = color;\n          this.distance = distance;\n        }\n        return RemovedColor;\n      }();\n      // TODO: make input/output image and input/output palettes with instances of class Point only!\n      var RGBQuant = function () {\n        function RGBQuant(colorDistanceCalculator, colors, method) {\n          if (colors === void 0) {\n            colors = 256;\n          }\n          if (method === void 0) {\n            method = 2;\n          }\n          this._distance = colorDistanceCalculator;\n          // desired final palette size\n          this._colors = colors;\n          // histogram to accumulate\n          this._histogram = new colorHistogram_1.ColorHistogram(method, colors);\n          this._initialDistance = 0.01;\n          this._distanceIncrement = 0.005;\n        }\n        // gathers histogram info\n        RGBQuant.prototype.sample = function (image) {\n          /*\r\n           var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\r\n              for (var i = 0, l = pointArray.length; i < l; i++) {\r\n           var color = pointArray[i];\r\n           for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\r\n           if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\r\n           if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\r\n           }\r\n           }\r\n           var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\r\n           this._distance.setWhitePoint(rd, gd, bd, ad);\r\n              this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\r\n           */\n          this._histogram.sample(image);\n        };\n        // reduces histogram to palette, remaps & memoizes reduced colors\n        RGBQuant.prototype.quantize = function () {\n          var idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\n          if (idxi32.length === 0) {\n            throw new Error(\"No colors in image\");\n          }\n          var palette = this._buildPalette(idxi32);\n          palette.sort();\n          return palette;\n        };\n        // reduces similar colors from an importance-sorted Uint32 rgba array\n        RGBQuant.prototype._buildPalette = function (idxi32) {\n          // reduce histogram to create initial palette\n          // build full rgb palette\n          var palette = new palette_1.Palette(),\n            colorArray = palette.getPointContainer().getPointArray(),\n            usageArray = new Array(idxi32.length);\n          for (var i = 0; i < idxi32.length; i++) {\n            colorArray.push(point_1.Point.createByUint32(idxi32[i]));\n            usageArray[i] = 1;\n          }\n          var len = colorArray.length,\n            memDist = [];\n          var palLen = len,\n            thold = this._initialDistance;\n          // palette already at or below desired length\n          while (palLen > this._colors) {\n            memDist.length = 0;\n            // iterate palette\n            for (var i = 0; i < len; i++) {\n              if (usageArray[i] === 0) continue;\n              var pxi = colorArray[i];\n              //if (!pxi) continue;\n              for (var j = i + 1; j < len; j++) {\n                if (usageArray[j] === 0) continue;\n                var pxj = colorArray[j];\n                //if (!pxj) continue;\n                var dist = this._distance.calculateNormalized(pxi, pxj);\n                if (dist < thold) {\n                  // store index,rgb,dist\n                  memDist.push(new RemovedColor(j, pxj, dist));\n                  usageArray[j] = 0;\n                  palLen--;\n                }\n              }\n            }\n            // palette reduction pass\n            // console.log(\"palette length: \" + palLen);\n            // if palette is still much larger than target, increment by larger initDist\n            thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;\n          }\n          // if palette is over-reduced, re-add removed colors with largest distances from last round\n          if (palLen < this._colors) {\n            // sort descending\n            arithmetic_1.stableSort(memDist, function (a, b) {\n              return b.distance - a.distance;\n            });\n            var k = 0;\n            while (palLen < this._colors && k < memDist.length) {\n              var removedColor = memDist[k];\n              // re-inject rgb into final palette\n              usageArray[removedColor.index] = 1;\n              palLen++;\n              k++;\n            }\n          }\n          var colors = colorArray.length;\n          for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n            if (usageArray[colorIndex] === 0) {\n              if (colorIndex !== colors - 1) {\n                colorArray[colorIndex] = colorArray[colors - 1];\n              }\n              --colors;\n            }\n          }\n          colorArray.length = colors;\n          return palette;\n        };\n        return RGBQuant;\n      }();\n      exports.RGBQuant = RGBQuant;\n\n      /***/\n    }, /* 27 */\n    /***/function (module, exports, __webpack_require__) {\n      /*\r\n       * Copyright (c) 2015, Leon Sorokin\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * ColorHistogram.js - an image quantization lib\r\n       */\n      \"use strict\";\n\n      /**\r\n       * @preserve TypeScript port:\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * colorHistogram.ts - part of Image Quantization Library\r\n       */\n      var hueStatistics_1 = __webpack_require__(28);\n      var arithmetic_1 = __webpack_require__(6);\n      var ColorHistogram = function () {\n        function ColorHistogram(method, colors) {\n          // 1 = by global population, 2 = subregion population threshold\n          this._method = method;\n          // if > 0, enables hues stats and min-color retention per group\n          this._minHueCols = colors << 2; //opts.minHueCols || 0;\n          // # of highest-frequency colors to start with for palette reduction\n          this._initColors = colors << 2;\n          // HueStatistics instance\n          this._hueStats = new hueStatistics_1.HueStatistics(ColorHistogram._hueGroups, this._minHueCols);\n          this._histogram = Object.create(null);\n        }\n        ColorHistogram.prototype.sample = function (pointBuffer) {\n          switch (this._method) {\n            case 1:\n              this._colorStats1D(pointBuffer);\n              break;\n            case 2:\n              this._colorStats2D(pointBuffer);\n              break;\n          }\n        };\n        ColorHistogram.prototype.getImportanceSortedColorsIDXI32 = function () {\n          var _this = this;\n          // TODO: fix typing issue in stableSort func\n          var sorted = arithmetic_1.stableSort(Object.keys(this._histogram), function (a, b) {\n            return _this._histogram[b] - _this._histogram[a];\n          });\n          if (sorted.length === 0) {\n            return [];\n          }\n          var idxi32;\n          switch (this._method) {\n            case 1:\n              var initialColorsLimit = Math.min(sorted.length, this._initColors),\n                last = sorted[initialColorsLimit - 1],\n                freq = this._histogram[last];\n              idxi32 = sorted.slice(0, initialColorsLimit);\n              // add any cut off colors with same freq as last\n              var pos = initialColorsLimit,\n                len = sorted.length;\n              while (pos < len && this._histogram[sorted[pos]] == freq) idxi32.push(sorted[pos++]);\n              // inject min huegroup colors\n              this._hueStats.injectIntoArray(idxi32);\n              break;\n            case 2:\n              idxi32 = sorted;\n              break;\n            default:\n              // TODO: rethink errors\n              throw new Error(\"Incorrect method\");\n          }\n          // int32-ify values\n          return idxi32.map(function (v) {\n            return +v;\n          });\n        };\n        // global top-population\n        ColorHistogram.prototype._colorStats1D = function (pointBuffer) {\n          var histG = this._histogram,\n            pointArray = pointBuffer.getPointArray(),\n            len = pointArray.length;\n          for (var i = 0; i < len; i++) {\n            var col = pointArray[i].uint32;\n            // collect hue stats\n            this._hueStats.check(col);\n            if (col in histG) histG[col]++;else histG[col] = 1;\n          }\n        };\n        // population threshold within subregions\n        // FIXME: this can over-reduce (few/no colors same?), need a way to keep\n        // important colors that dont ever reach local thresholds (gradients?)\n        ColorHistogram.prototype._colorStats2D = function (pointBuffer) {\n          var _this = this;\n          var width = pointBuffer.getWidth(),\n            height = pointBuffer.getHeight(),\n            pointArray = pointBuffer.getPointArray();\n          var boxW = ColorHistogram._boxSize[0],\n            boxH = ColorHistogram._boxSize[1],\n            area = boxW * boxH,\n            boxes = this._makeBoxes(width, height, boxW, boxH),\n            histG = this._histogram;\n          boxes.forEach(function (box) {\n            var effc = Math.round(box.w * box.h / area) * ColorHistogram._boxPixels;\n            if (effc < 2) effc = 2;\n            var histL = {};\n            _this._iterateBox(box, width, function (i) {\n              var col = pointArray[i].uint32;\n              // collect hue stats\n              _this._hueStats.check(col);\n              if (col in histG) histG[col]++;else if (col in histL) {\n                if (++histL[col] >= effc) histG[col] = histL[col];\n              } else histL[col] = 1;\n            });\n          });\n          // inject min huegroup colors\n          this._hueStats.injectIntoDictionary(histG);\n        };\n        // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n        ColorHistogram.prototype._iterateBox = function (bbox, wid, fn) {\n          var b = bbox,\n            i0 = b.y * wid + b.x,\n            i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1),\n            incr = wid - b.w + 1;\n          var cnt = 0,\n            i = i0;\n          do {\n            fn.call(this, i);\n            i += ++cnt % b.w == 0 ? incr : 1;\n          } while (i <= i1);\n        };\n        /**\r\n         *    partitions a rectangle of width x height into\r\n         *    array of boxes stepX x stepY (or less)\r\n         */\n        ColorHistogram.prototype._makeBoxes = function (width, height, stepX, stepY) {\n          var wrem = width % stepX,\n            hrem = height % stepY,\n            xend = width - wrem,\n            yend = height - hrem,\n            boxesArray = [];\n          for (var y = 0; y < height; y += stepY) for (var x = 0; x < width; x += stepX) boxesArray.push({\n            x: x,\n            y: y,\n            w: x == xend ? wrem : stepX,\n            h: y == yend ? hrem : stepY\n          });\n          return boxesArray;\n        };\n        ColorHistogram._boxSize = [64, 64];\n        ColorHistogram._boxPixels = 2;\n        ColorHistogram._hueGroups = 10;\n        return ColorHistogram;\n      }();\n      exports.ColorHistogram = ColorHistogram;\n\n      /***/\n    }, /* 28 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * hueStatistics.ts - part of Image Quantization Library\r\n       */\n      var rgb2hsl_1 = __webpack_require__(5);\n      var palette_1 = __webpack_require__(22);\n      var HueGroup = function () {\n        function HueGroup() {\n          this.num = 0;\n          this.cols = [];\n        }\n        return HueGroup;\n      }();\n      var HueStatistics = function () {\n        function HueStatistics(numGroups, minCols) {\n          this._numGroups = numGroups;\n          this._minCols = minCols;\n          this._stats = [];\n          for (var i = 0; i <= numGroups; i++) {\n            this._stats[i] = new HueGroup();\n          }\n          this._groupsFull = 0;\n        }\n        HueStatistics.prototype.check = function (i32) {\n          if (this._groupsFull == this._numGroups + 1) {\n            this.check = function () {};\n          }\n          var r = i32 & 0xff,\n            g = i32 >>> 8 & 0xff,\n            b = i32 >>> 16 & 0xff,\n            hg = r == g && g == b ? 0 : 1 + palette_1.hueGroup(rgb2hsl_1.rgb2hsl(r, g, b).h, this._numGroups),\n            gr = this._stats[hg],\n            min = this._minCols;\n          gr.num++;\n          if (gr.num > min) return;\n          if (gr.num == min) this._groupsFull++;\n          if (gr.num <= min) this._stats[hg].cols.push(i32);\n        };\n        HueStatistics.prototype.injectIntoDictionary = function (histG) {\n          for (var i = 0; i <= this._numGroups; i++) {\n            if (this._stats[i].num <= this._minCols) {\n              this._stats[i].cols.forEach(function (col) {\n                if (!histG[col]) histG[col] = 1;else histG[col]++;\n              });\n            }\n          }\n        };\n        HueStatistics.prototype.injectIntoArray = function (histG) {\n          for (var i = 0; i <= this._numGroups; i++) {\n            if (this._stats[i].num <= this._minCols) {\n              this._stats[i].cols.forEach(function (col) {\n                if (histG.indexOf(col) == -1) histG.push(col);\n              });\n            }\n          }\n        };\n        return HueStatistics;\n      }();\n      exports.HueStatistics = HueStatistics;\n\n      /***/\n    }, /* 29 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * wuQuant.ts - part of Image Quantization Library\r\n       */\n      var palette_1 = __webpack_require__(22);\n      var point_1 = __webpack_require__(24);\n      function createArray1D(dimension1) {\n        var a = [];\n        for (var k = 0; k < dimension1; k++) {\n          a[k] = 0;\n        }\n        return a;\n      }\n      function createArray4D(dimension1, dimension2, dimension3, dimension4) {\n        var a = new Array(dimension1);\n        for (var i = 0; i < dimension1; i++) {\n          a[i] = new Array(dimension2);\n          for (var j = 0; j < dimension2; j++) {\n            a[i][j] = new Array(dimension3);\n            for (var k = 0; k < dimension3; k++) {\n              a[i][j][k] = new Array(dimension4);\n              for (var l = 0; l < dimension4; l++) {\n                a[i][j][k][l] = 0;\n              }\n            }\n          }\n        }\n        return a;\n      }\n      function createArray3D(dimension1, dimension2, dimension3) {\n        var a = new Array(dimension1);\n        for (var i = 0; i < dimension1; i++) {\n          a[i] = new Array(dimension2);\n          for (var j = 0; j < dimension2; j++) {\n            a[i][j] = new Array(dimension3);\n            for (var k = 0; k < dimension3; k++) {\n              a[i][j][k] = 0;\n            }\n          }\n        }\n        return a;\n      }\n      function fillArray3D(a, dimension1, dimension2, dimension3, value) {\n        for (var i = 0; i < dimension1; i++) {\n          a[i] = [];\n          for (var j = 0; j < dimension2; j++) {\n            a[i][j] = [];\n            for (var k = 0; k < dimension3; k++) {\n              a[i][j][k] = value;\n            }\n          }\n        }\n      }\n      function fillArray1D(a, dimension1, value) {\n        for (var i = 0; i < dimension1; i++) {\n          a[i] = value;\n        }\n      }\n      var WuColorCube = function () {\n        function WuColorCube() {}\n        return WuColorCube;\n      }();\n      exports.WuColorCube = WuColorCube;\n      var WuQuant = function () {\n        function WuQuant(colorDistanceCalculator, colors, significantBitsPerChannel) {\n          if (colors === void 0) {\n            colors = 256;\n          }\n          if (significantBitsPerChannel === void 0) {\n            significantBitsPerChannel = 5;\n          }\n          this._distance = colorDistanceCalculator;\n          this._setQuality(significantBitsPerChannel);\n          this._initialize(colors);\n        }\n        WuQuant.prototype.sample = function (image) {\n          var pointArray = image.getPointArray();\n          for (var i = 0, l = pointArray.length; i < l; i++) {\n            this._addColor(pointArray[i]);\n          }\n          this._pixels = this._pixels.concat(pointArray);\n        };\n        WuQuant.prototype.quantize = function () {\n          this._preparePalette();\n          var palette = new palette_1.Palette();\n          // generates palette\n          for (var paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\n            if (this._sums[paletteIndex] > 0) {\n              var sum = this._sums[paletteIndex],\n                r = this._reds[paletteIndex] / sum,\n                g = this._greens[paletteIndex] / sum,\n                b = this._blues[paletteIndex] / sum,\n                a = this._alphas[paletteIndex] / sum;\n              var color = point_1.Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\n              palette.add(color);\n            }\n          }\n          palette.sort();\n          return palette;\n        };\n        WuQuant.prototype._preparePalette = function () {\n          // preprocess the colors\n          this._calculateMoments();\n          var next = 0,\n            volumeVariance = createArray1D(this._colors);\n          // processes the cubes\n          for (var cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\n            // if cut is possible; make it\n            if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\n              volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0.0;\n              volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0.0;\n            } else {\n              // the cut was not possible, revert the index\n              volumeVariance[next] = 0.0;\n              cubeIndex--;\n            }\n            next = 0;\n            var temp = volumeVariance[0];\n            for (var index = 1; index <= cubeIndex; ++index) {\n              if (volumeVariance[index] > temp) {\n                temp = volumeVariance[index];\n                next = index;\n              }\n            }\n            if (temp <= 0.0) {\n              this._colors = cubeIndex + 1;\n              break;\n            }\n          }\n          var lookupRed = [],\n            lookupGreen = [],\n            lookupBlue = [],\n            lookupAlpha = [];\n          // precalculates lookup tables\n          for (var k = 0; k < this._colors; ++k) {\n            var weight = WuQuant._volume(this._cubes[k], this._weights);\n            if (weight > 0) {\n              lookupRed[k] = WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;\n              lookupGreen[k] = WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;\n              lookupBlue[k] = WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;\n              lookupAlpha[k] = WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;\n            } else {\n              lookupRed[k] = 0;\n              lookupGreen[k] = 0;\n              lookupBlue[k] = 0;\n              lookupAlpha[k] = 0;\n            }\n          }\n          this._reds = createArray1D(this._colors + 1);\n          this._greens = createArray1D(this._colors + 1);\n          this._blues = createArray1D(this._colors + 1);\n          this._alphas = createArray1D(this._colors + 1);\n          this._sums = createArray1D(this._colors + 1);\n          // scans and adds colors\n          for (var index = 0, l = this._pixels.length; index < l; index++) {\n            var color = this._pixels[index];\n            var match = -1;\n            var bestMatch = match,\n              bestDistance = Number.MAX_VALUE;\n            for (var lookup = 0; lookup < this._colors; lookup++) {\n              var foundRed = lookupRed[lookup],\n                foundGreen = lookupGreen[lookup],\n                foundBlue = lookupBlue[lookup],\n                foundAlpha = lookupAlpha[lookup];\n              var distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\n              //var distance = this._distance.calculateRaw(Utils.Point.createByRGBA(foundRed, foundGreen, foundBlue, foundAlpha), color);\n              //deltaRed   = color.r - foundRed,\n              //deltaGreen = color.g - foundGreen,\n              //deltaBlue  = color.b - foundBlue,\n              //deltaAlpha = color.a - foundAlpha,\n              //distance   = deltaRed * deltaRed + deltaGreen * deltaGreen + deltaBlue * deltaBlue + deltaAlpha * deltaAlpha;\n              if (distance < bestDistance) {\n                bestDistance = distance;\n                bestMatch = lookup;\n              }\n            }\n            this._reds[bestMatch] += color.r;\n            this._greens[bestMatch] += color.g;\n            this._blues[bestMatch] += color.b;\n            this._alphas[bestMatch] += color.a;\n            this._sums[bestMatch]++;\n          }\n        };\n        WuQuant.prototype._addColor = function (color) {\n          var bitsToRemove = 8 - this._significantBitsPerChannel,\n            indexRed = (color.r >> bitsToRemove) + 1,\n            indexGreen = (color.g >> bitsToRemove) + 1,\n            indexBlue = (color.b >> bitsToRemove) + 1,\n            indexAlpha = (color.a >> bitsToRemove) + 1;\n          //if(color.a > 10) {\n          this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\n          this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\n          this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\n          this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\n          this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\n          this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];\n          //\t\t\t}\n        };\n        /**\r\n         * Converts the histogram to a series of _moments.\r\n         */\n        WuQuant.prototype._calculateMoments = function () {\n          var area = [],\n            areaRed = [],\n            areaGreen = [],\n            areaBlue = [],\n            areaAlpha = [],\n            area2 = [];\n          var xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize),\n            xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize),\n            xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize),\n            xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize),\n            xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize),\n            xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n          for (var alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {\n            fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\n            fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\n            fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\n            fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\n            fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\n            fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\n            for (var redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {\n              fillArray1D(area, this._sideSize, 0);\n              fillArray1D(areaRed, this._sideSize, 0);\n              fillArray1D(areaGreen, this._sideSize, 0);\n              fillArray1D(areaBlue, this._sideSize, 0);\n              fillArray1D(areaAlpha, this._sideSize, 0);\n              fillArray1D(area2, this._sideSize, 0);\n              for (var greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\n                var line = 0,\n                  lineRed = 0,\n                  lineGreen = 0,\n                  lineBlue = 0,\n                  lineAlpha = 0,\n                  line2 = 0.0;\n                for (var blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\n                  line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\n                  lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\n                  lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\n                  lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\n                  lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\n                  line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\n                  area[blueIndex] += line;\n                  areaRed[blueIndex] += lineRed;\n                  areaGreen[blueIndex] += lineGreen;\n                  areaBlue[blueIndex] += lineBlue;\n                  areaAlpha[blueIndex] += lineAlpha;\n                  area2[blueIndex] += line2;\n                  xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\n                  xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];\n                  xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];\n                  xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];\n                  xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];\n                  xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\n                  this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];\n                  this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];\n                  this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];\n                  this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];\n                  this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];\n                  this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];\n                }\n              }\n            }\n          }\n        };\n        /**\r\n         * Computes the volume of the cube in a specific moment.\r\n         */\n        WuQuant._volumeFloat = function (cube, moment) {\n          return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n        };\n        /**\r\n         * Computes the volume of the cube in a specific moment.\r\n         */\n        WuQuant._volume = function (cube, moment) {\n          return WuQuant._volumeFloat(cube, moment) | 0;\n        };\n        /**\r\n         * Splits the cube in given position][and color direction.\r\n         */\n        WuQuant._top = function (cube, direction, position, moment) {\n          var result;\n          switch (direction) {\n            case WuQuant.alpha:\n              result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n              break;\n            case WuQuant.red:\n              result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);\n              break;\n            case WuQuant.green:\n              result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);\n              break;\n            case WuQuant.blue:\n              result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);\n              break;\n            default:\n              throw new Error(\"impossible\");\n          }\n          return result | 0;\n        };\n        /**\r\n         * Splits the cube in a given color direction at its minimum.\r\n         */\n        WuQuant._bottom = function (cube, direction, moment) {\n          switch (direction) {\n            case WuQuant.alpha:\n              return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n            case WuQuant.red:\n              return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n            case WuQuant.green:\n              return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n            case WuQuant.blue:\n              return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n            default:\n              // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\n              return 0;\n          }\n        };\n        /**\r\n         * Calculates statistical variance for a given cube.\r\n         */\n        WuQuant.prototype._calculateVariance = function (cube) {\n          var volumeRed = WuQuant._volume(cube, this._momentsRed),\n            volumeGreen = WuQuant._volume(cube, this._momentsGreen),\n            volumeBlue = WuQuant._volume(cube, this._momentsBlue),\n            volumeAlpha = WuQuant._volume(cube, this._momentsAlpha),\n            volumeMoment = WuQuant._volumeFloat(cube, this._moments),\n            volumeWeight = WuQuant._volume(cube, this._weights),\n            distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\n          return volumeMoment - distance / volumeWeight;\n        };\n        /**\r\n         * Finds the optimal (maximal) position for the cut.\r\n         */\n        WuQuant.prototype._maximize = function (cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {\n          var bottomRed = WuQuant._bottom(cube, direction, this._momentsRed) | 0,\n            bottomGreen = WuQuant._bottom(cube, direction, this._momentsGreen) | 0,\n            bottomBlue = WuQuant._bottom(cube, direction, this._momentsBlue) | 0,\n            bottomAlpha = WuQuant._bottom(cube, direction, this._momentsAlpha) | 0,\n            bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\n          var result = 0.0,\n            cutPosition = -1;\n          for (var position = first; position < last; ++position) {\n            // determines the cube cut at a certain position\n            var halfRed = bottomRed + WuQuant._top(cube, direction, position, this._momentsRed),\n              halfGreen = bottomGreen + WuQuant._top(cube, direction, position, this._momentsGreen),\n              halfBlue = bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue),\n              halfAlpha = bottomAlpha + WuQuant._top(cube, direction, position, this._momentsAlpha),\n              halfWeight = bottomWeight + WuQuant._top(cube, direction, position, this._weights);\n            // the cube cannot be cut at bottom (this would lead to empty cube)\n            if (halfWeight != 0) {\n              var halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha,\n                temp = halfDistance / halfWeight;\n              halfRed = wholeRed - halfRed;\n              halfGreen = wholeGreen - halfGreen;\n              halfBlue = wholeBlue - halfBlue;\n              halfAlpha = wholeAlpha - halfAlpha;\n              halfWeight = wholeWeight - halfWeight;\n              if (halfWeight != 0) {\n                halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\n                temp += halfDistance / halfWeight;\n                if (temp > result) {\n                  result = temp;\n                  cutPosition = position;\n                }\n              }\n            }\n          }\n          return {\n            max: result,\n            position: cutPosition\n          };\n        };\n        // Cuts a cube with another one.\n        WuQuant.prototype._cut = function (first, second) {\n          var direction;\n          var wholeRed = WuQuant._volume(first, this._momentsRed),\n            wholeGreen = WuQuant._volume(first, this._momentsGreen),\n            wholeBlue = WuQuant._volume(first, this._momentsBlue),\n            wholeAlpha = WuQuant._volume(first, this._momentsAlpha),\n            wholeWeight = WuQuant._volume(first, this._weights),\n            red = this._maximize(first, WuQuant.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\n            green = this._maximize(first, WuQuant.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\n            blue = this._maximize(first, WuQuant.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\n            alpha = this._maximize(first, WuQuant.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n          if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\n            direction = WuQuant.alpha;\n            // cannot split empty cube\n            if (alpha.position < 0) return false;\n          } else {\n            if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\n              direction = WuQuant.red;\n            } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\n              direction = WuQuant.green;\n            } else {\n              direction = WuQuant.blue;\n            }\n          }\n          second.redMaximum = first.redMaximum;\n          second.greenMaximum = first.greenMaximum;\n          second.blueMaximum = first.blueMaximum;\n          second.alphaMaximum = first.alphaMaximum;\n          // cuts in a certain direction\n          switch (direction) {\n            case WuQuant.red:\n              second.redMinimum = first.redMaximum = red.position;\n              second.greenMinimum = first.greenMinimum;\n              second.blueMinimum = first.blueMinimum;\n              second.alphaMinimum = first.alphaMinimum;\n              break;\n            case WuQuant.green:\n              second.greenMinimum = first.greenMaximum = green.position;\n              second.redMinimum = first.redMinimum;\n              second.blueMinimum = first.blueMinimum;\n              second.alphaMinimum = first.alphaMinimum;\n              break;\n            case WuQuant.blue:\n              second.blueMinimum = first.blueMaximum = blue.position;\n              second.redMinimum = first.redMinimum;\n              second.greenMinimum = first.greenMinimum;\n              second.alphaMinimum = first.alphaMinimum;\n              break;\n            case WuQuant.alpha:\n              second.alphaMinimum = first.alphaMaximum = alpha.position;\n              second.blueMinimum = first.blueMinimum;\n              second.redMinimum = first.redMinimum;\n              second.greenMinimum = first.greenMinimum;\n              break;\n          }\n          // determines the volumes after cut\n          first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\n          second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\n          // the cut was successful\n          return true;\n        };\n        WuQuant.prototype._initialize = function (colors) {\n          this._colors = colors;\n          // creates all the _cubes\n          this._cubes = [];\n          // initializes all the _cubes\n          for (var cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\n            this._cubes[cubeIndex] = new WuColorCube();\n          }\n          // resets the reference minimums\n          this._cubes[0].redMinimum = 0;\n          this._cubes[0].greenMinimum = 0;\n          this._cubes[0].blueMinimum = 0;\n          this._cubes[0].alphaMinimum = 0;\n          // resets the reference maximums\n          this._cubes[0].redMaximum = this._maxSideIndex;\n          this._cubes[0].greenMaximum = this._maxSideIndex;\n          this._cubes[0].blueMaximum = this._maxSideIndex;\n          this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\n          this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n          this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n          this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n          this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n          this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n          this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n          this._table = [];\n          for (var tableIndex = 0; tableIndex < 256; ++tableIndex) {\n            this._table[tableIndex] = tableIndex * tableIndex;\n          }\n          this._pixels = [];\n        };\n        WuQuant.prototype._setQuality = function (significantBitsPerChannel) {\n          if (significantBitsPerChannel === void 0) {\n            significantBitsPerChannel = 5;\n          }\n          this._significantBitsPerChannel = significantBitsPerChannel;\n          this._maxSideIndex = 1 << this._significantBitsPerChannel;\n          this._alphaMaxSideIndex = this._maxSideIndex;\n          this._sideSize = this._maxSideIndex + 1;\n          this._alphaSideSize = this._alphaMaxSideIndex + 1;\n        };\n        WuQuant.alpha = 3;\n        WuQuant.red = 2;\n        WuQuant.green = 1;\n        WuQuant.blue = 0;\n        return WuQuant;\n      }();\n      exports.WuQuant = WuQuant;\n\n      /***/\n    }, /* 30 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var nearestColor_1 = __webpack_require__(31);\n      exports.NearestColor = nearestColor_1.NearestColor;\n      var array_1 = __webpack_require__(32);\n      exports.ErrorDiffusionArray = array_1.ErrorDiffusionArray;\n      exports.ErrorDiffusionArrayKernel = array_1.ErrorDiffusionArrayKernel;\n      var riemersma_1 = __webpack_require__(33);\n      exports.ErrorDiffusionRiemersma = riemersma_1.ErrorDiffusionRiemersma;\n\n      /***/\n    }, /* 31 */\n    /***/function (module, exports) {\n      \"use strict\";\n\n      var NearestColor = function () {\n        function NearestColor(colorDistanceCalculator) {\n          this._distance = colorDistanceCalculator;\n        }\n        NearestColor.prototype.quantize = function (pointBuffer, palette) {\n          var pointArray = pointBuffer.getPointArray(),\n            width = pointBuffer.getWidth(),\n            height = pointBuffer.getHeight();\n          for (var y = 0; y < height; y++) {\n            for (var x = 0, idx = y * width; x < width; x++, idx++) {\n              // Image pixel\n              var point = pointArray[idx];\n              // Reduced pixel\n              point.from(palette.getNearestColor(this._distance, point));\n            }\n          }\n          return pointBuffer;\n        };\n        return NearestColor;\n      }();\n      exports.NearestColor = NearestColor;\n\n      /***/\n    }, /* 32 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var point_1 = __webpack_require__(24);\n      var arithmetic_1 = __webpack_require__(6);\n      // TODO: is it the best name for this enum \"kernel\"?\n      (function (ErrorDiffusionArrayKernel) {\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"FloydSteinberg\"] = 0] = \"FloydSteinberg\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"FalseFloydSteinberg\"] = 1] = \"FalseFloydSteinberg\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Stucki\"] = 2] = \"Stucki\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Atkinson\"] = 3] = \"Atkinson\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Jarvis\"] = 4] = \"Jarvis\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Burkes\"] = 5] = \"Burkes\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"Sierra\"] = 6] = \"Sierra\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"TwoSierra\"] = 7] = \"TwoSierra\";\n        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel[\"SierraLite\"] = 8] = \"SierraLite\";\n      })(exports.ErrorDiffusionArrayKernel || (exports.ErrorDiffusionArrayKernel = {}));\n      var ErrorDiffusionArrayKernel = exports.ErrorDiffusionArrayKernel;\n      // http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\n      var ErrorDiffusionArray = function () {\n        function ErrorDiffusionArray(colorDistanceCalculator, kernel, serpentine, minimumColorDistanceToDither, calculateErrorLikeGIMP) {\n          if (serpentine === void 0) {\n            serpentine = true;\n          }\n          if (minimumColorDistanceToDither === void 0) {\n            minimumColorDistanceToDither = 0;\n          }\n          if (calculateErrorLikeGIMP === void 0) {\n            calculateErrorLikeGIMP = false;\n          }\n          this._setKernel(kernel);\n          this._distance = colorDistanceCalculator;\n          this._minColorDistance = minimumColorDistanceToDither;\n          this._serpentine = serpentine;\n          this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\n        }\n        // adapted from http://jsbin.com/iXofIji/2/edit by PAEz\n        // fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\n        ErrorDiffusionArray.prototype.quantize = function (pointBuffer, palette) {\n          var pointArray = pointBuffer.getPointArray(),\n            originalPoint = new point_1.Point(),\n            width = pointBuffer.getWidth(),\n            height = pointBuffer.getHeight(),\n            errorLines = [];\n          var dir = 1,\n            maxErrorLines = 1;\n          // initial error lines (number is taken from dithering kernel)\n          for (var i = 0; i < this._kernel.length; i++) {\n            var kernelErrorLines = this._kernel[i][2] + 1;\n            if (maxErrorLines < kernelErrorLines) maxErrorLines = kernelErrorLines;\n          }\n          for (var i = 0; i < maxErrorLines; i++) {\n            this._fillErrorLine(errorLines[i] = [], width);\n          }\n          for (var y = 0; y < height; y++) {\n            // always serpentine\n            if (this._serpentine) dir = dir * -1;\n            var lni = y * width,\n              xStart = dir == 1 ? 0 : width - 1,\n              xEnd = dir == 1 ? width : -1;\n            // cyclic shift with erasing\n            this._fillErrorLine(errorLines[0], width);\n            // TODO: why it is needed to cast types here?\n            errorLines.push(errorLines.shift());\n            var errorLine = errorLines[0];\n            for (var x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {\n              // Image pixel\n              var point = pointArray[idx],\n                //originalPoint = new Utils.Point(),\n                error = errorLine[x];\n              originalPoint.from(point);\n              var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(point.r + error[0]), arithmetic_1.inRange0to255Rounded(point.g + error[1]), arithmetic_1.inRange0to255Rounded(point.b + error[2]), arithmetic_1.inRange0to255Rounded(point.a + error[3]));\n              // Reduced pixel\n              var palettePoint = palette.getNearestColor(this._distance, correctedPoint);\n              point.from(palettePoint);\n              // dithering strength\n              if (this._minColorDistance) {\n                var dist = this._distance.calculateNormalized(point, palettePoint);\n                if (dist < this._minColorDistance) continue;\n              }\n              // Component distance\n              var er = void 0,\n                eg = void 0,\n                eb = void 0,\n                ea = void 0;\n              if (this._calculateErrorLikeGIMP) {\n                er = correctedPoint.r - palettePoint.r;\n                eg = correctedPoint.g - palettePoint.g;\n                eb = correctedPoint.b - palettePoint.b;\n                ea = correctedPoint.a - palettePoint.a;\n              } else {\n                er = originalPoint.r - palettePoint.r;\n                eg = originalPoint.g - palettePoint.g;\n                eb = originalPoint.b - palettePoint.b;\n                ea = originalPoint.a - palettePoint.a;\n              }\n              var dStart = dir == 1 ? 0 : this._kernel.length - 1,\n                dEnd = dir == 1 ? this._kernel.length : -1;\n              for (var i = dStart; i !== dEnd; i += dir) {\n                var x1 = this._kernel[i][1] * dir,\n                  y1 = this._kernel[i][2];\n                if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n                  var d = this._kernel[i][0],\n                    e = errorLines[y1][x1 + x];\n                  e[0] = e[0] + er * d;\n                  e[1] = e[1] + eg * d;\n                  e[2] = e[2] + eb * d;\n                  e[3] = e[3] + ea * d;\n                }\n              }\n            }\n          }\n          return pointBuffer;\n        };\n        ErrorDiffusionArray.prototype._fillErrorLine = function (errorLine, width) {\n          // shrink\n          if (errorLine.length > width) {\n            errorLine.length = width;\n          }\n          // reuse existing arrays\n          var l = errorLine.length;\n          for (var i = 0; i < l; i++) {\n            var error = errorLine[i];\n            error[0] = error[1] = error[2] = error[3] = 0;\n          }\n          // create missing arrays\n          for (var i = l; i < width; i++) {\n            errorLine[i] = [0.0, 0.0, 0.0, 0.0];\n          }\n        };\n        ErrorDiffusionArray.prototype._setKernel = function (kernel) {\n          switch (kernel) {\n            case ErrorDiffusionArrayKernel.FloydSteinberg:\n              this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];\n              break;\n            case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\n              this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];\n              break;\n            case ErrorDiffusionArrayKernel.Stucki:\n              this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];\n              break;\n            case ErrorDiffusionArrayKernel.Atkinson:\n              this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];\n              break;\n            case ErrorDiffusionArrayKernel.Jarvis:\n              this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];\n              break;\n            case ErrorDiffusionArrayKernel.Burkes:\n              this._kernel = [[8 / 32, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [8 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];\n              break;\n            case ErrorDiffusionArrayKernel.Sierra:\n              this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];\n              break;\n            case ErrorDiffusionArrayKernel.TwoSierra:\n              this._kernel = [[4 / 16, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];\n              break;\n            case ErrorDiffusionArrayKernel.SierraLite:\n              this._kernel = [[2 / 4, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];\n              break;\n            default:\n              throw new Error(\"ErrorDiffusionArray: unknown kernel = \" + kernel);\n          }\n        };\n        return ErrorDiffusionArray;\n      }();\n      exports.ErrorDiffusionArray = ErrorDiffusionArray;\n\n      /***/\n    }, /* 33 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var hilbertCurve_1 = __webpack_require__(34);\n      var point_1 = __webpack_require__(24);\n      var arithmetic_1 = __webpack_require__(6);\n      var ErrorDiffusionRiemersma = function () {\n        function ErrorDiffusionRiemersma(colorDistanceCalculator, errorQueueSize, errorPropagation) {\n          if (errorQueueSize === void 0) {\n            errorQueueSize = 16;\n          }\n          if (errorPropagation === void 0) {\n            errorPropagation = 1;\n          }\n          this._distance = colorDistanceCalculator;\n          this._errorPropagation = errorPropagation;\n          this._errorQueueSize = errorQueueSize;\n          this._max = this._errorQueueSize;\n          this._createWeights();\n        }\n        ErrorDiffusionRiemersma.prototype.quantize = function (pointBuffer, palette) {\n          var _this = this;\n          var curve = new hilbertCurve_1.HilbertCurveBase(),\n            pointArray = pointBuffer.getPointArray(),\n            width = pointBuffer.getWidth(),\n            height = pointBuffer.getHeight(),\n            errorQueue = [];\n          var head = 0;\n          for (var i = 0; i < this._errorQueueSize; i++) {\n            errorQueue[i] = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n          }\n          curve.walk(width, height, function (x, y) {\n            var p = pointArray[x + y * width];\n            var r = p.r,\n              g = p.g,\n              b = p.b,\n              a = p.a;\n            for (var i = 0; i < _this._errorQueueSize; i++) {\n              var weight = _this._weights[i],\n                e = errorQueue[(i + head) % _this._errorQueueSize];\n              r += e.r * weight;\n              g += e.g * weight;\n              b += e.b * weight;\n              a += e.a * weight;\n            }\n            var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(r), arithmetic_1.inRange0to255Rounded(g), arithmetic_1.inRange0to255Rounded(b), arithmetic_1.inRange0to255Rounded(a));\n            var quantizedPoint = palette.getNearestColor(_this._distance, correctedPoint);\n            // update head and calculate tail\n            head = (head + 1) % _this._errorQueueSize;\n            var tail = (head + _this._errorQueueSize - 1) % _this._errorQueueSize;\n            // update error with new value\n            errorQueue[tail].r = p.r - quantizedPoint.r;\n            errorQueue[tail].g = p.g - quantizedPoint.g;\n            errorQueue[tail].b = p.b - quantizedPoint.b;\n            errorQueue[tail].a = p.a - quantizedPoint.a;\n            // update point\n            p.from(quantizedPoint);\n          });\n          return pointBuffer;\n        };\n        ErrorDiffusionRiemersma.prototype._createWeights = function () {\n          this._weights = [];\n          var multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1));\n          for (var i = 0, next = 1; i < this._errorQueueSize; i++) {\n            this._weights[i] = (next + 0.5 | 0) / this._max * this._errorPropagation;\n            next *= multiplier;\n          }\n        };\n        return ErrorDiffusionRiemersma;\n      }();\n      exports.ErrorDiffusionRiemersma = ErrorDiffusionRiemersma;\n\n      /***/\n    }, /* 34 */\n    /***/function (module, exports) {\n      \"use strict\";\n\n      var Direction;\n      (function (Direction) {\n        Direction[Direction[\"NONE\"] = 0] = \"NONE\";\n        Direction[Direction[\"UP\"] = 1] = \"UP\";\n        Direction[Direction[\"LEFT\"] = 2] = \"LEFT\";\n        Direction[Direction[\"RIGHT\"] = 3] = \"RIGHT\";\n        Direction[Direction[\"DOWN\"] = 4] = \"DOWN\";\n      })(Direction || (Direction = {}));\n      // Check code against double-entrance into walk (walk=> callback => walk)\n      var HilbertCurveBase = function () {\n        function HilbertCurveBase() {}\n        HilbertCurveBase.prototype.walk = function (width, height, visitorCallback) {\n          this._x = 0;\n          this._y = 0;\n          this._d = 0;\n          this._width = width;\n          this._height = height;\n          this._callback = visitorCallback;\n          var maxBound = Math.max(width, height);\n          this._level = Math.log(maxBound) / Math.log(2) + 1 | 0;\n          this._walkHilbert(Direction.UP);\n          this._visit(Direction.NONE);\n        };\n        HilbertCurveBase.prototype._walkHilbert = function (direction) {\n          if (this._level < 1) return;\n          this._level--;\n          switch (direction) {\n            case Direction.LEFT:\n              this._walkHilbert(Direction.UP);\n              this._visit(Direction.RIGHT);\n              this._walkHilbert(Direction.LEFT);\n              this._visit(Direction.DOWN);\n              this._walkHilbert(Direction.LEFT);\n              this._visit(Direction.LEFT);\n              this._walkHilbert(Direction.DOWN);\n              break;\n            case Direction.RIGHT:\n              this._walkHilbert(Direction.DOWN);\n              this._visit(Direction.LEFT);\n              this._walkHilbert(Direction.RIGHT);\n              this._visit(Direction.UP);\n              this._walkHilbert(Direction.RIGHT);\n              this._visit(Direction.RIGHT);\n              this._walkHilbert(Direction.UP);\n              break;\n            case Direction.UP:\n              this._walkHilbert(Direction.LEFT);\n              this._visit(Direction.DOWN);\n              this._walkHilbert(Direction.UP);\n              this._visit(Direction.RIGHT);\n              this._walkHilbert(Direction.UP);\n              this._visit(Direction.UP);\n              this._walkHilbert(Direction.RIGHT);\n              break;\n            case Direction.DOWN:\n              this._walkHilbert(Direction.RIGHT);\n              this._visit(Direction.UP);\n              this._walkHilbert(Direction.DOWN);\n              this._visit(Direction.LEFT);\n              this._walkHilbert(Direction.DOWN);\n              this._visit(Direction.DOWN);\n              this._walkHilbert(Direction.LEFT);\n              break;\n            default:\n              break;\n          }\n          this._level++;\n        };\n        HilbertCurveBase.prototype._visit = function (direction) {\n          if (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height) {\n            this._callback(this._x, this._y, this._d);\n            this._d++;\n          }\n          switch (direction) {\n            case Direction.LEFT:\n              this._x--;\n              break;\n            case Direction.RIGHT:\n              this._x++;\n              break;\n            case Direction.UP:\n              this._y--;\n              break;\n            case Direction.DOWN:\n              this._y++;\n              break;\n          }\n        };\n        return HilbertCurveBase;\n      }();\n      exports.HilbertCurveBase = HilbertCurveBase;\n\n      /***/\n    }, /* 35 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * iq.ts - Image Quantization Library\r\n       */\n      var ssim_1 = __webpack_require__(36);\n      exports.SSIM = ssim_1.SSIM;\n\n      /***/\n    }, /* 36 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var bt709_1 = __webpack_require__(2);\n      // based on https://github.com/rhys-e/structural-similarity\n      // http://en.wikipedia.org/wiki/Structural_similarity\n      var K1 = 0.01,\n        K2 = 0.03;\n      var SSIM = function () {\n        function SSIM() {}\n        SSIM.prototype.compare = function (image1, image2) {\n          if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\n            throw new Error(\"Images have different sizes!\");\n          }\n          var bitsPerComponent = 8,\n            L = (1 << bitsPerComponent) - 1,\n            c1 = Math.pow(K1 * L, 2),\n            c2 = Math.pow(K2 * L, 2);\n          var numWindows = 0,\n            mssim = 0.0;\n          //calculate ssim for each window\n          this._iterate(image1, image2, function (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {\n            //calculate variance and covariance\n            var sigxy = 0.0,\n              sigsqx = 0.0,\n              sigsqy = 0.0;\n            for (var i = 0; i < lumaValues1.length; i++) {\n              sigsqx += Math.pow(lumaValues1[i] - averageLumaValue1, 2);\n              sigsqy += Math.pow(lumaValues2[i] - averageLumaValue2, 2);\n              sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);\n            }\n            var numPixelsInWin = lumaValues1.length - 1;\n            sigsqx /= numPixelsInWin;\n            sigsqy /= numPixelsInWin;\n            sigxy /= numPixelsInWin;\n            //perform ssim calculation on window\n            var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2),\n              denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2),\n              ssim = numerator / denominator;\n            mssim += ssim;\n            numWindows++;\n          });\n          return mssim / numWindows;\n        };\n        SSIM.prototype._iterate = function (image1, image2, callback) {\n          var windowSize = 8,\n            width = image1.getWidth(),\n            height = image1.getHeight();\n          for (var y = 0; y < height; y += windowSize) {\n            for (var x = 0; x < width; x += windowSize) {\n              // avoid out-of-width/height\n              var windowWidth = Math.min(windowSize, width - x),\n                windowHeight = Math.min(windowSize, height - y);\n              var lumaValues1 = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight),\n                lumaValues2 = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight),\n                averageLuma1 = this._calculateAverageLuma(lumaValues1),\n                averageLuma2 = this._calculateAverageLuma(lumaValues2);\n              callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n            }\n          }\n        };\n        SSIM.prototype._calculateLumaValuesForWindow = function (image, x, y, width, height) {\n          var pointArray = image.getPointArray(),\n            lumaValues = [];\n          var counter = 0;\n          for (var j = y; j < y + height; j++) {\n            var offset = j * image.getWidth();\n            for (var i = x; i < x + width; i++) {\n              var point = pointArray[offset + i];\n              lumaValues[counter] = point.r * bt709_1.Y.RED + point.g * bt709_1.Y.GREEN + point.b * bt709_1.Y.BLUE;\n              counter++;\n            }\n          }\n          return lumaValues;\n        };\n        SSIM.prototype._calculateAverageLuma = function (lumaValues) {\n          var sumLuma = 0.0;\n          for (var i = 0; i < lumaValues.length; i++) {\n            sumLuma += lumaValues[i];\n          }\n          return sumLuma / lumaValues.length;\n        };\n        return SSIM;\n      }();\n      exports.SSIM = SSIM;\n\n      /***/\n    }, /* 37 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      /**\r\n       * @preserve\r\n       * Copyright 2015-2016 Igor Bezkrovnyi\r\n       * All rights reserved. (MIT Licensed)\r\n       *\r\n       * iq.ts - Image Quantization Library\r\n       */\n      var arithmetic = __webpack_require__(6);\n      exports.arithmetic = arithmetic;\n      var hueStatistics_1 = __webpack_require__(28);\n      exports.HueStatistics = hueStatistics_1.HueStatistics;\n      var palette_1 = __webpack_require__(22);\n      exports.Palette = palette_1.Palette;\n      var point_1 = __webpack_require__(24);\n      exports.Point = point_1.Point;\n      var pointContainer_1 = __webpack_require__(23);\n      exports.PointContainer = pointContainer_1.PointContainer;\n\n      /***/\n    }\n    /******/])\n  );\n});\n\n;","map":{"version":3,"mappings":"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","names":["module","define","exports","root","modules","__webpack_require__","constants","conversion","distance","palette","image","quality","utils","bt709","Y","x","y","n","Math","pow","r","g","b","correctGamma","z","min","arithmetic_1","max","delta","l","s","h","PI","a","c","m","value","low","high","round","arrayToSort","callback","type","sorted","ord_1","Object","create","i","length","val","sort","ord2_1","slice","indexOf","xyz","rgb2xyz_1","xyz2lab_1","refX","refY","refZ","pivot","Error","L","lab2xyz_1","xyz2rgb_1","_setDefaults","setWhitePoint","AbstractDistanceCalculator","_whitePoint","_maxDistance","calculateRaw","colorA","colorB","__extends","_super","AbstractCIE94","r1","g1","b1","a1","r2","g2","b2","a2","lab1","rgb2lab_1","lab2","dL","dA","dB","c1","sqrt","c2","dC","deltaH","dAlpha","_kA","_Kl","_K1","_K2","abstractDistanceCalculator_1","CIE94Textiles","CIE94GraphicArts","CIEDE2000","dE2","calculateRawInLab","Lab1","Lab2","L1","L2","C1","C2","pow_a_C1_C2_to_7","G","_pow25to7","a1p","a2p","C1p","C2p","C1pC2p","h1p","_calculatehp","h2p","h_bar","abs","dLp","dCp","dHp","_calculate_dHp","ahp","_calculate_ahp","T","_calculateT","aCp","aLp_minus_50_square","S_L","S_C","S_H","R_T","_calculateRT","dLpSL","dCpSC","dHpSH","ap","hp","atan2","_deg360InRad","aCp_to_7","R_C","delta_theta","_deg30InRad","exp","_deg275InRad","_deg25InRad","sin","cos","_deg6InRad","_deg63InRad","hpSum","_deg180InRad","dhp","CMETRIC","rmean","dE","AbstractEuclidean","dR","dG","_kR","_kG","_kB","Euclidean","EuclideanRgbQuantWithAlpha","bt709_1","RED","GREEN","BLUE","EuclideanRgbQuantWOAlpha","AbstractManhattan","Manhattan","ManhattanNommyde","ManhattanSRGB","PNGQUANT","alphas","_colordifference_ch","black","white","networkBiasShift","defaultValue","Neuron","point_1","createByRGBA","colorDistanceCalculator","colors","_distance","_pointArray","_sampleFactor","_networkSize","NeuQuant","pointBuffer","concat","getPointArray","_init","_learn","_buildPalette","_freq","_bias","_radPower","_network","_initialBias","sampleFactor","pointsNumber","_minpicturebytes","alphadec","pointsToSample","_nCycles","alpha","_initAlpha","radius","_radiusBias","rad","_radiusBiasShift","_radBias","step","_prime1","_prime2","_prime3","_prime4","pointIndex","point","neuronIndex","_contest","_alterSingle","_alterNeighbour","_radiusDecrease","j","palette_1","forEach","add","neuron","toPoint","al","lo","hi","k","_alphaRadBias","p","subtract","multiplier","bestd","bestbiasd","bestpos","bestbiaspos","dist","calculateNormalized","biasdist","_initialBiasShift","betafreq","_betaShift","_gammaShift","_beta","_betaGamma","_alphaBiasShift","_radBiasShift","_alphaRadBiasShift","hueGroups","hue","segmentsNumber","maxHue","seg","half","mid","_pointContainer","pointContainer_1","setHeight","Palette","color","push","setWidth","uint32","getNearestIndex","key","_i32idx","idx","_nearestPointFromCache","minimalDistance","Number","MAX_VALUE","hslA","rgb2hsl_1","hslB","hueA","hueGroup","hueB","hueDiff","lA","getLuminosity","lB","satDiff","_width","_height","PointContainer","width","height","clone","createByUint32","uint32Array","Uint32Array","Uint8Array","toUint32Array","buffer","img","naturalWidth","naturalHeight","canvas","document","createElement","ctx","getContext","drawImage","fromHTMLCanvasElement","imgData","getImageData","fromImageData","imageData","fromCanvasPixelArray","data","byteArray","uint8array","fromUint8Array","fromArray","fromUint32Array","uint32array","container","rgba","Array","Point","quadruplet","_loadUINT32","_loadQuadruplet","red","green","blue","_loadRGBA","useAlphaChannel","NeuronFloat","NeuQuantFloat","index","method","_colors","_histogram","colorHistogram_1","_initialDistance","_distanceIncrement","RGBQuant","sample","idxi32","getImportanceSortedColorsIDXI32","colorArray","getPointContainer","usageArray","len","memDist","palLen","thold","pxi","pxj","RemovedColor","removedColor","colorIndex","_method","_minHueCols","_initColors","_hueStats","hueStatistics_1","ColorHistogram","_hueGroups","_colorStats1D","_colorStats2D","keys","_this","initialColorsLimit","last","freq","pos","injectIntoArray","map","v","histG","pointArray","col","check","getWidth","getHeight","boxW","_boxSize","boxH","area","boxes","_makeBoxes","effc","box","w","_boxPixels","histL","_iterateBox","injectIntoDictionary","bbox","wid","fn","i0","i1","incr","cnt","call","stepX","stepY","wrem","hrem","xend","yend","boxesArray","numGroups","minCols","_numGroups","_minCols","_stats","HueGroup","_groupsFull","HueStatistics","i32","hg","gr","num","cols","dimension1","dimension2","dimension3","dimension4","significantBitsPerChannel","_setQuality","_initialize","WuQuant","_addColor","_pixels","_preparePalette","paletteIndex","_sums","sum","_reds","_greens","_blues","_alphas","_calculateMoments","next","volumeVariance","createArray1D","cubeIndex","_cut","_cubes","volume","_calculateVariance","temp","lookupRed","lookupGreen","lookupBlue","lookupAlpha","weight","_volume","_weights","_momentsRed","_momentsGreen","_momentsBlue","_momentsAlpha","match","bestMatch","bestDistance","lookup","foundRed","foundGreen","foundBlue","foundAlpha","bitsToRemove","_significantBitsPerChannel","indexRed","indexGreen","indexBlue","indexAlpha","_moments","_table","areaRed","areaGreen","areaBlue","areaAlpha","area2","xarea","createArray3D","_sideSize","xareaRed","xareaGreen","xareaBlue","xareaAlpha","xarea2","alphaIndex","_alphaMaxSideIndex","fillArray3D","redIndex","_maxSideIndex","fillArray1D","greenIndex","line","lineRed","lineGreen","lineBlue","lineAlpha","line2","blueIndex","cube","moment","alphaMaximum","redMaximum","greenMaximum","blueMaximum","greenMinimum","redMinimum","alphaMinimum","blueMinimum","_volumeFloat","direction","position","result","volumeRed","volumeGreen","volumeBlue","volumeAlpha","volumeMoment","volumeWeight","first","wholeRed","wholeGreen","wholeBlue","wholeAlpha","wholeWeight","bottomRed","_bottom","bottomGreen","bottomBlue","bottomAlpha","bottomWeight","cutPosition","halfRed","_top","halfGreen","halfBlue","halfAlpha","halfWeight","halfDistance","second","_maximize","WuColorCube","createArray4D","_alphaSideSize","tableIndex","NearestColor","from","getNearestColor","ErrorDiffusionArrayKernel","kernel","serpentine","minimumColorDistanceToDither","calculateErrorLikeGIMP","_setKernel","_minColorDistance","_serpentine","_calculateErrorLikeGIMP","ErrorDiffusionArray","originalPoint","errorLines","dir","maxErrorLines","_kernel","kernelErrorLines","_fillErrorLine","lni","xStart","xEnd","shift","errorLine","error","correctedPoint","palettePoint","er","eg","eb","ea","dStart","dEnd","x1","y1","d","e","FloydSteinberg","FalseFloydSteinberg","Stucki","Atkinson","Jarvis","Burkes","Sierra","TwoSierra","SierraLite","errorQueueSize","errorPropagation","_errorPropagation","_errorQueueSize","_max","_createWeights","ErrorDiffusionRiemersma","curve","hilbertCurve_1","errorQueue","head","walk","quantizedPoint","tail","log","Direction","HilbertCurveBase","visitorCallback","_x","_y","_d","_callback","maxBound","_level","_walkHilbert","UP","_visit","NONE","LEFT","RIGHT","DOWN","K1","K2","SSIM","image1","image2","bitsPerComponent","numWindows","mssim","_iterate","lumaValues1","lumaValues2","averageLumaValue1","averageLumaValue2","sigxy","sigsqx","sigsqy","numPixelsInWin","numerator","denominator","ssim","windowSize","windowWidth","windowHeight","_calculateLumaValuesForWindow","averageLuma1","_calculateAverageLuma","averageLuma2","lumaValues","counter","offset","sumLuma","arithmetic"],"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap cc12c561526565ac4570","webpack:///src/iq.ts","webpack:///src/constants/index.ts","webpack:///src/constants/bt709.ts","webpack:///src/conversion/index.ts","webpack:///src/conversion/rgb2xyz.ts","webpack:///src/conversion/rgb2hsl.ts","webpack:///src/utils/arithmetic.ts","webpack:///src/conversion/rgb2lab.ts","webpack:///src/conversion/xyz2lab.ts","webpack:///src/conversion/lab2xyz.ts","webpack:///src/conversion/lab2rgb.ts","webpack:///src/conversion/xyz2rgb.ts","webpack:///src/distance/index.ts","webpack:///src/distance/abstractDistanceCalculator.ts","webpack:///src/distance/cie94.ts","webpack:///src/distance/ciede2000.ts","webpack:///src/distance/cmetric.ts","webpack:///src/distance/euclidean.ts","webpack:///src/distance/manhattan.ts","webpack:///src/distance/pngQuant.ts","webpack:///src/palette/index.ts","webpack:///src/palette/neuquant/neuquant.ts","webpack:///src/utils/palette.ts","webpack:///src/utils/pointContainer.ts","webpack:///src/utils/point.ts","webpack:///src/palette/neuquant/neuquantFloat.ts","webpack:///src/palette/rgbquant/rgbquant.ts","webpack:///src/palette/rgbquant/colorHistogram.ts","webpack:///src/utils/hueStatistics.ts","webpack:///src/palette/wu/wuQuant.ts","webpack:///src/image/index.ts","webpack:///src/image/nearestColor.ts","webpack:///src/image/array.ts","webpack:///src/image/riemersma.ts","webpack:///src/image/spaceFillingCurves/hilbertCurve.ts","webpack:///src/quality/index.ts","webpack:///src/quality/ssim.ts","webpack:///src/utils/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"iq\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"iq\"] = factory();\n\telse\n\t\troot[\"iq\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap cc12c561526565ac4570\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport * as constants from \"./constants\"\r\nimport * as conversion from \"./conversion\"\r\nimport * as distance from \"./distance\"\r\nimport * as palette from \"./palette\"\r\nimport * as image from \"./image\"\r\nimport * as quality from \"./quality\"\r\nimport * as utils from \"./utils\"\r\n\r\nexport {\r\n    constants,\r\n    conversion,\r\n    distance,\r\n    palette,\r\n    image,\r\n    quality,\r\n    utils\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/iq.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\nimport * as bt709 from \"./bt709\"\r\n\r\nexport {\r\n    bt709\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants/index.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * sRGB (based on ITU-R Recommendation BT.709)\r\n * http://en.wikipedia.org/wiki/SRGB\r\n */\r\nenum Y {\r\n    RED = .2126, GREEN = .7152, BLUE = .0722, WHITE = 1\r\n}\r\n\r\nenum x {\r\n    RED = .6400, GREEN = .3000, BLUE = .1500, WHITE = .3127\r\n}\r\n\r\nenum y {\r\n    RED = .3300, GREEN = .6000, BLUE = .0600, WHITE = .3290\r\n}\r\n\r\nexport {\r\n    Y,\r\n    x,\r\n    y\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants/bt709.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { rgb2xyz } from \"./rgb2xyz\"\r\nimport { rgb2hsl } from \"./rgb2hsl\"\r\nimport { rgb2lab } from \"./rgb2lab\"\r\nimport { lab2xyz } from \"./lab2xyz\"\r\nimport { lab2rgb } from \"./lab2rgb\"\r\nimport { xyz2lab } from \"./xyz2lab\"\r\nimport { xyz2rgb } from \"./xyz2rgb\"\r\n\r\nexport {\r\n    rgb2xyz,\r\n    rgb2hsl,\r\n    rgb2lab,\r\n    lab2xyz,\r\n    lab2rgb,\r\n    xyz2lab,\r\n    xyz2rgb,\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/index.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2xyz.ts - part of Image Quantization Library\r\n */\r\nfunction correctGamma(n : number) {\r\n    return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;\r\n}\r\n\r\nexport function rgb2xyz(r : number, g : number, b : number) : { x : number; y : number; z : number } {\r\n    // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\n    r = correctGamma(r / 255);\r\n    g = correctGamma(g / 255);\r\n    b = correctGamma(b / 255);\r\n\r\n    // Observer. = 2째, Illuminant = D65\r\n    return {\r\n        x : r * 0.4124 + g * 0.3576 + b * 0.1805,\r\n        y : r * 0.2126 + g * 0.7152 + b * 0.0722,\r\n        z : r * 0.0193 + g * 0.1192 + b * 0.9505\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/rgb2xyz.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2hsl.ts - part of Image Quantization Library\r\n */\r\nimport { min3, max3 } from \"../utils/arithmetic\"\r\n\r\n/**\r\n * Calculate HSL from RGB\r\n * Hue is in degrees [0..360]\r\n * Lightness: [0..1]\r\n * Saturation: [0..1]\r\n * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\r\n */\r\nexport function rgb2hsl(r : number, g : number, b : number) : {h : number; s : number; l : number} {\r\n    const min   = min3(r, g, b),\r\n          max   = max3(r, g, b),\r\n          delta = max - min,\r\n          l     = (min + max) / 510;\r\n\r\n    let s = 0;\r\n    if (l > 0 && l < 1) s = delta / (l < 0.5 ? (max + min) : (510 - max - min));\r\n\r\n    let h = 0;\r\n    if (delta > 0) {\r\n        if (max === r) {\r\n            h = (g - b) / delta;\r\n        } else if (max === g) {\r\n            h = (2 + (b - r) / delta);\r\n        } else {\r\n            h = (4 + (r - g) / delta);\r\n        }\r\n\r\n        h *= 60;\r\n        if (h < 0) h += 360;\r\n    }\r\n    return { h, s, l };\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/rgb2hsl.ts\n **/","export function degrees2radians(n : number) : number {\r\n    return n * (Math.PI / 180);\r\n}\r\n\r\nexport function max3(a : number, b : number, c : number) {\r\n    let m = a;\r\n    (m < b) && (m = b);\r\n    (m < c) && (m = c);\r\n    return m;\r\n}\r\n\r\nexport function min3(a : number, b : number, c : number) {\r\n    let m = a;\r\n    (m > b) && (m = b);\r\n    (m > c) && (m = c);\r\n    return m;\r\n}\r\n\r\nexport function intInRange(value : number, low : number, high : number) {\r\n    if (value > high) value = high;\r\n    if (value < low) value = low;\r\n    return value | 0;\r\n}\r\n\r\nexport function inRange0to255Rounded(n : number) {\r\n    n = Math.round(n);\r\n    if (n > 255) n = 255;\r\n    else if (n < 0) n = 0;\r\n    return n;\r\n}\r\n\r\nexport function inRange0to255(n : number) {\r\n    if (n > 255) n = 255;\r\n    else if (n < 0) n = 0;\r\n    return n;\r\n}\r\n\r\nexport function stableSort<T>(arrayToSort : T[], callback : (a : T, b : T) => number) : T[] {\r\n    const type = typeof arrayToSort[ 0 ];\r\n    let sorted : T[];\r\n\r\n    if (type === \"number\" || type === \"string\") {\r\n        const ord = Object.create(null);\r\n        for (let i = 0, l = arrayToSort.length; i < l; i++) {\r\n            const val : string = <any>arrayToSort[ i ];\r\n            if (ord[ val ] || ord[ val ] === 0) continue;\r\n            ord[ val ] = i;\r\n        }\r\n\r\n        sorted = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord[ <any>a ] - ord[ <any>b ];\r\n        });\r\n    } else {\r\n        const ord2 : T[] = arrayToSort.slice(0);\r\n        sorted           = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b);\r\n        });\r\n    }\r\n\r\n    return sorted;\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/arithmetic.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2lab.ts - part of Image Quantization Library\r\n */\r\nimport { rgb2xyz } from \"./rgb2xyz\"\r\nimport { xyz2lab } from \"./xyz2lab\"\r\n\r\nexport function rgb2lab(r : number, g : number, b : number) : { L : number; a : number; b : number } {\r\n    const xyz = rgb2xyz(r, g, b);\r\n    return xyz2lab(xyz.x, xyz.y, xyz.z);\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/rgb2lab.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2lab.ts - part of Image Quantization Library\r\n */\r\nconst refX : number = 0.95047, //ref_X =  95.047   Observer= 2째, Illuminant= D65\r\n      refY : number = 1.00000, //ref_Y = 100.000\r\n      refZ : number = 1.08883; //ref_Z = 108.883\r\n\r\nfunction pivot(n : number) : number {\r\n    return n > 0.008856 ? Math.pow(n, 1 / 3) : ( 7.787 * n + 16 / 116);\r\n}\r\n\r\nexport function xyz2lab(x : number, y : number, z : number) : {L : number; a : number; b : number} {\r\n    x = pivot(x / refX);\r\n    y = pivot(y / refY);\r\n    z = pivot(z / refZ);\r\n\r\n    if (( 116 * y ) - 16 < 0) throw new Error(\"xxx\")\r\n    return {\r\n        L : Math.max(0, ( 116 * y ) - 16),\r\n        a : 500 * ( x - y ),\r\n        b : 200 * ( y - z )\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/xyz2lab.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2xyz.ts - part of Image Quantization Library\r\n */\r\nconst refX : number = 0.95047, //ref_X =  95.047   Observer= 2째, Illuminant = D65\r\n      refY : number = 1.00000, //ref_Y = 100.000\r\n      refZ : number = 1.08883; //ref_Z = 108.883\r\n\r\nfunction pivot(n : number) {\r\n    return n > 0.206893034 ? Math.pow(n, 3) : ( n - 16 / 116 ) / 7.787\r\n}\r\n\r\nexport function lab2xyz(L : number, a : number, b : number) : {x : number; y : number; z : number} {\r\n    const y = ( L + 16 ) / 116,\r\n          x = a / 500 + y,\r\n          z = y - b / 200;\r\n\r\n    return {\r\n        x : refX * pivot(x),\r\n        y : refY * pivot(y),\r\n        z : refZ * pivot(z)\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/lab2xyz.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2rgb.ts - part of Image Quantization Library\r\n */\r\nimport { lab2xyz } from \"./lab2xyz\"\r\nimport { xyz2rgb } from \"./xyz2rgb\"\r\n\r\nexport function lab2rgb(L : number, a : number, b : number) : { r : number; g : number; b : number } {\r\n    const xyz = lab2xyz(L, a, b);\r\n    return xyz2rgb(xyz.x, xyz.y, xyz.z);\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/lab2rgb.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2rgb.ts - part of Image Quantization Library\r\n */\r\nimport { inRange0to255Rounded } from \"../utils/arithmetic\"\r\n\r\n// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\nfunction correctGamma(n : number) {\r\n    return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;\r\n}\r\n\r\nexport function xyz2rgb(x : number, y : number, z : number) : { r : number; g : number; b : number } {\r\n    // Observer. = 2째, Illuminant = D65\r\n    const r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986),\r\n          g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415),\r\n          b = correctGamma(x * 0.0557 + y * -0.2040 + z * 1.0570);\r\n\r\n    return {\r\n        r : inRange0to255Rounded(r * 255),\r\n        g : inRange0to255Rounded(g * 255),\r\n        b : inRange0to255Rounded(b * 255)\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/xyz2rgb.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { CIE94Textiles, CIE94GraphicArts } from \"./cie94\"\r\nimport { CIEDE2000 } from \"./ciede2000\"\r\nimport { CMETRIC } from \"./cmetric\"\r\nimport { AbstractEuclidean, Euclidean, EuclideanRgbQuantWOAlpha, EuclideanRgbQuantWithAlpha } from \"./euclidean\"\r\nimport { AbstractManhattan, Manhattan, ManhattanSRGB, ManhattanNommyde } from \"./manhattan\"\r\nimport { PNGQUANT } from \"./pngQuant\"\r\n\r\nexport {\r\n    AbstractDistanceCalculator,\r\n    CIE94Textiles,\r\n    CIE94GraphicArts,\r\n    CIEDE2000,\r\n    CMETRIC,\r\n    PNGQUANT,\r\n\r\n    AbstractEuclidean,\r\n    Euclidean,\r\n    EuclideanRgbQuantWithAlpha,\r\n    EuclideanRgbQuantWOAlpha,\r\n\r\n    AbstractManhattan,\r\n    Manhattan,\r\n    ManhattanSRGB,\r\n    ManhattanNommyde\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/index.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * common.ts - part of Image Quantization Library\r\n */\r\nimport { Point } from \"../utils/point\"\r\n\r\nexport abstract class AbstractDistanceCalculator {\r\n    protected _maxDistance : number;\r\n    protected _whitePoint : { r : number; g : number; b : number; a : number };\r\n\r\n    constructor() {\r\n        this._setDefaults();\r\n\r\n        // set default maximal color component deltas (255 - 0 = 255)\r\n        this.setWhitePoint(255, 255, 255, 255);\r\n    }\r\n\r\n    setWhitePoint(r : number, g : number, b : number, a : number) : void {\r\n        this._whitePoint  = {\r\n            r : (r > 0) ? 255 / r : 0,\r\n            g : (g > 0) ? 255 / g : 0,\r\n            b : (b > 0) ? 255 / b : 0,\r\n            a : (a > 0) ? 255 / a : 0\r\n        };\r\n        this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\r\n    }\r\n\r\n    calculateNormalized(colorA : Point, colorB : Point) : number {\r\n        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\r\n    }\r\n\r\n    protected _setDefaults() : void {\r\n    }\r\n\r\n    /**\r\n     * Calculate raw distance (non-normalized)\r\n     */\r\n    abstract calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number;\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/abstractDistanceCalculator.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cie94.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { rgb2lab } from \"../conversion/rgb2lab\"\r\nimport { inRange0to255 } from \"../utils/arithmetic\"\r\n\r\n/**\r\n * CIE94 method of delta-e\r\n * http://en.wikipedia.org/wiki/Color_difference#CIE94\r\n */\r\nexport abstract class AbstractCIE94 extends AbstractDistanceCalculator {\r\n    /**\r\n     * Weight in distance: 0.25\r\n     * Max DeltaE: 100\r\n     * Max DeltaA: 255\r\n     */\r\n    protected _kA : number;\r\n    protected _Kl : number;\r\n    protected _K1 : number;\r\n    protected _K2 : number;\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)),\r\n              lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\r\n\r\n        const dL = lab1.L - lab2.L,\r\n              dA = lab1.a - lab2.a,\r\n              dB = lab1.b - lab2.b,\r\n              c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b),\r\n              c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b),\r\n              dC = c1 - c2;\r\n\r\n        let deltaH = dA * dA + dB * dB - dC * dC;\r\n        deltaH     = deltaH < 0 ? 0 : Math.sqrt(deltaH);\r\n\r\n        const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\r\n\r\n        // TODO: add alpha channel support\r\n        return Math.sqrt(\r\n            Math.pow(dL / this._Kl, 2) +\r\n            Math.pow(dC / (1.0 + this._K1 * c1), 2) +\r\n            Math.pow(deltaH / (1.0 + this._K2 * c1), 2) +\r\n            Math.pow(dAlpha, 2)\r\n        );\r\n    }\r\n}\r\n\r\nexport class CIE94Textiles extends AbstractCIE94 {\r\n    protected _setDefaults() {\r\n        this._Kl = 2.0;\r\n        this._K1 = 0.048;\r\n        this._K2 = 0.014;\r\n        this._kA = 0.25 * 50 / 255;\r\n    }\r\n}\r\n\r\nexport class CIE94GraphicArts extends AbstractCIE94 {\r\n    protected _setDefaults() {\r\n        this._Kl = 1.0;\r\n        this._K1 = 0.045;\r\n        this._K2 = 0.015;\r\n        this._kA = 0.25 * 100 / 255;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/cie94.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ciede2000.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\";\r\nimport { rgb2lab } from \"../conversion/rgb2lab\";\r\nimport { degrees2radians, inRange0to255 } from \"../utils/arithmetic\";\r\n\r\n/**\r\n * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at\r\n * http://www.ece.rochester.edu/~gsharma/ciede2000/\r\n */\r\nexport class CIEDE2000 extends AbstractDistanceCalculator {\r\n    /**\r\n     * Weight in distance: 0.25\r\n     * Max DeltaE: 100\r\n     * Max DeltaA: 255\r\n     */\r\n    private static readonly _kA                   = 0.25 * 100 / 255;\r\n    private static readonly _pow25to7 : number    = Math.pow(25, 7);\r\n    private static readonly _deg360InRad : number = degrees2radians(360);\r\n    private static readonly _deg180InRad : number = degrees2radians(180);\r\n    private static readonly _deg30InRad : number  = degrees2radians(30);\r\n    private static readonly _deg6InRad : number   = degrees2radians(6);\r\n    private static readonly _deg63InRad : number  = degrees2radians(63);\r\n    private static readonly _deg275InRad : number = degrees2radians(275);\r\n    private static readonly _deg25InRad : number  = degrees2radians(25);\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)),\r\n              lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b)),\r\n              dA   = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA,\r\n              dE2  = this.calculateRawInLab(lab1, lab2);\r\n\r\n        return Math.sqrt(dE2 + dA * dA);\r\n    }\r\n\r\n    calculateRawInLab(Lab1 : {L : number; a : number; b : number}, Lab2 : {L : number; a : number; b : number}) : number {\r\n        // Get L,a,b values for color 1\r\n        const L1 = Lab1.L,\r\n              a1 = Lab1.a,\r\n              b1 = Lab1.b;\r\n\r\n        // Get L,a,b values for color 2\r\n        const L2 = Lab2.L,\r\n              a2 = Lab2.a,\r\n              b2 = Lab2.b;\r\n\r\n        // Calculate Cprime1, Cprime2, Cabbar\r\n        const C1                  = Math.sqrt(a1 * a1 + b1 * b1),\r\n              C2                  = Math.sqrt(a2 * a2 + b2 * b2),\r\n              pow_a_C1_C2_to_7    = Math.pow((C1 + C2) / 2.0, 7.0),\r\n\r\n              G                   = 0.5 * (1.0 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))), //25^7\r\n              a1p                 = (1.0 + G) * a1,\r\n              a2p                 = (1.0 + G) * a2,\r\n\r\n              C1p                 = Math.sqrt(a1p * a1p + b1 * b1),\r\n              C2p                 = Math.sqrt(a2p * a2p + b2 * b2),\r\n              C1pC2p              = C1p * C2p,\r\n\r\n              // Angles in Degree.\r\n              h1p                 = CIEDE2000._calculatehp(b1, a1p),\r\n              h2p                 = CIEDE2000._calculatehp(b2, a2p),\r\n              h_bar               = Math.abs(h1p - h2p),\r\n              dLp                 = L2 - L1,\r\n              dCp                 = C2p - C1p,\r\n              dHp                 = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p),\r\n              ahp                 = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p),\r\n\r\n              T                   = CIEDE2000._calculateT(ahp),\r\n\r\n              aCp                 = (C1p + C2p) / 2.0,\r\n              aLp_minus_50_square = Math.pow((L1 + L2) / 2.0 - 50.0, 2.0),\r\n              S_L                 = 1.0 + (.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square),\r\n              S_C                 = 1.0 + .045 * aCp,\r\n              S_H                 = 1.0 + .015 * T * aCp,\r\n\r\n              R_T                 = CIEDE2000._calculateRT(ahp, aCp),\r\n\r\n              dLpSL               = dLp / S_L, // S_L * kL, where kL is 1.0\r\n              dCpSC               = dCp / S_C, // S_C * kC, where kC is 1.0\r\n              dHpSH               = dHp / S_H; // S_H * kH, where kH is 1.0\r\n\r\n        return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;\r\n    }\r\n\r\n    private static _calculatehp(b : number, ap : number) {\r\n        const hp = Math.atan2(b, ap);\r\n        if (hp >= 0) return hp;\r\n        return hp + CIEDE2000._deg360InRad;\r\n    }\r\n\r\n    private static _calculateRT(ahp : number, aCp : number) {\r\n        const aCp_to_7    = Math.pow(aCp, 7.0),\r\n              R_C         = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)), // 25^7\r\n              delta_theta = CIEDE2000._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad, 2.0));\r\n        return -Math.sin(2.0 * delta_theta) * R_C;\r\n    }\r\n\r\n    private static _calculateT(ahp : number) {\r\n        return 1.0 - .17 * Math.cos(ahp - CIEDE2000._deg30InRad) + .24 * Math.cos(ahp * 2.0) + .32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) - .2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad);\r\n    }\r\n\r\n    private static _calculate_ahp(C1pC2p : number, h_bar : number, h1p : number, h2p : number) {\r\n        const hpSum = h1p + h2p;\r\n        if (C1pC2p == 0) return hpSum;\r\n        if (h_bar <= CIEDE2000._deg180InRad) return hpSum / 2.0;\r\n        if (hpSum < CIEDE2000._deg360InRad) return (hpSum + CIEDE2000._deg360InRad) / 2.0;\r\n        return (hpSum - CIEDE2000._deg360InRad) / 2.0;\r\n    }\r\n\r\n    private static _calculate_dHp(C1pC2p : number, h_bar : number, h2p : number, h1p : number) {\r\n        let dhp : number;\r\n        if (C1pC2p == 0) {\r\n            dhp = 0;\r\n        } else if (h_bar <= CIEDE2000._deg180InRad) {\r\n            dhp = h2p - h1p;\r\n        } else if (h2p <= h1p) {\r\n            dhp = h2p - h1p + CIEDE2000._deg360InRad;\r\n        } else {\r\n            dhp = h2p - h1p - CIEDE2000._deg360InRad;\r\n        }\r\n        return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/ciede2000.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cmetric.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\n\r\n/**\r\n * TODO: Name it: http://www.compuphase.com/cmetric.htm\r\n */\r\nexport class CMETRIC extends AbstractDistanceCalculator {\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const rmean = (r1 + r2) / 2 * this._whitePoint.r,\r\n              r     = (r1 - r2) * this._whitePoint.r,\r\n              g     = (g1 - g2) * this._whitePoint.g,\r\n              b     = (b1 - b2) * this._whitePoint.b,\r\n              dE    = ((((512 + rmean) * r * r) >> 8) + 4 * g * g + (((767 - rmean) * b * b) >> 8)),\r\n              dA    = (a2 - a1) * this._whitePoint.a;\r\n\r\n        return Math.sqrt(dE + dA * dA);\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/cmetric.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * euclidean.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n/**\r\n * Euclidean color distance\r\n */\r\nexport class AbstractEuclidean extends AbstractDistanceCalculator {\r\n    protected _kR : number;\r\n    protected _kG : number;\r\n    protected _kB : number;\r\n    protected _kA : number;\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;\r\n        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\r\n    }\r\n}\r\n\r\nexport class Euclidean extends AbstractEuclidean {\r\n    protected _setDefaults() {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Euclidean color distance (RgbQuant modification w Alpha)\r\n */\r\nexport class EuclideanRgbQuantWithAlpha extends AbstractEuclidean {\r\n    protected _setDefaults() {\r\n        this._kR = Y.RED;\r\n        this._kG = Y.GREEN;\r\n        this._kB = Y.BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Euclidean color distance (RgbQuant modification w/o Alpha)\r\n */\r\nexport class EuclideanRgbQuantWOAlpha extends AbstractEuclidean {\r\n    protected _setDefaults() {\r\n        this._kR = Y.RED;\r\n        this._kG = Y.GREEN;\r\n        this._kB = Y.BLUE;\r\n        this._kA = 0;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/euclidean.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * manhattanNeuQuant.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n/**\r\n * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\r\n */\r\nexport abstract class AbstractManhattan extends AbstractDistanceCalculator {\r\n    protected _kR : number;\r\n    protected _kG : number;\r\n    protected _kB : number;\r\n    protected _kA : number;\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        let dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;\r\n        if (dR < 0) dR = 0 - dR;\r\n        if (dG < 0) dG = 0 - dG;\r\n        if (dB < 0) dB = 0 - dB;\r\n        if (dA < 0) dA = 0 - dA;\r\n\r\n        return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\r\n    }\r\n}\r\n\r\nexport class Manhattan extends AbstractManhattan {\r\n    protected _setDefaults() {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Manhattan distance (Nommyde modification)\r\n * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\r\n */\r\nexport class ManhattanNommyde extends AbstractManhattan {\r\n    protected _setDefaults() {\r\n        this._kR = 0.4984;\r\n        this._kG = 0.8625;\r\n        this._kB = 0.2979;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Manhattan distance (sRGB coefficients)\r\n */\r\nexport class ManhattanSRGB extends AbstractManhattan {\r\n    protected _setDefaults() {\r\n        this._kR = Y.RED;\r\n        this._kG = Y.GREEN;\r\n        this._kB = Y.BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/manhattan.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pngQuant.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\n\r\n/**\r\n * TODO: check quality of this distance equation\r\n * TODO: ask author for usage rights\r\n * taken from:\r\n * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\r\n * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\r\n */\r\nexport class PNGQUANT extends AbstractDistanceCalculator {\r\n    /**\r\n     * Author's comments\r\n     * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\r\n     * px_b.a   = px.a   + 1*(1-px.a)\r\n     * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\r\n     * px_w.a   = px.a   + 1*(1-px.a)\r\n\r\n     * px_b.rgb = px.rgb              // difference same as in opaque RGB\r\n     * px_b.a   = 1\r\n     * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\r\n     * px_w.a   = 1\r\n\r\n     * (px.rgb - px.a) - (py.rgb - py.a)\r\n     * (px.rgb - py.rgb) + (py.a - px.a)\r\n     *\r\n     */\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const alphas = (a2 - a1) * this._whitePoint.a;\r\n        return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) +\r\n            this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) +\r\n            this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\r\n    }\r\n\r\n    private _colordifference_ch(x : number, y : number, alphas : number) {\r\n        // maximum of channel blended on white, and blended on black\r\n        // premultiplied alpha and backgrounds 0/1 shorten the formula\r\n        const black = x - y,\r\n              white = black + alphas;\r\n\r\n        return black * black + white * white;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/pngQuant.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { IPaletteQuantizer } from \"./common\"\r\nimport { NeuQuant } from \"./neuquant/neuquant\"\r\nimport { NeuQuantFloat } from \"./neuquant/neuquantFloat\"\r\nimport { RGBQuant } from \"./rgbquant/rgbquant\"\r\nimport { ColorHistogram } from \"./rgbquant/colorHistogram\"\r\nimport { WuQuant, WuColorCube } from \"./wu/wuQuant\"\r\n\r\nexport {\r\n    IPaletteQuantizer,\r\n\r\n    NeuQuant,\r\n    NeuQuantFloat,\r\n    RGBQuant,\r\n    WuQuant,\r\n\r\n    ColorHistogram,\r\n    WuColorCube\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/index.ts\n **/","/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\n\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\nimport { IPaletteQuantizer } from \"../common\"\r\n\r\n// bias for colour values\r\nconst networkBiasShift = 3;\r\n\r\nclass Neuron {\r\n    r : number;\r\n    g : number;\r\n    b : number;\r\n    a : number;\r\n\r\n    constructor(defaultValue : number) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    toPoint() : Point {\r\n        return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    }\r\n\r\n    subtract(r : number, g : number, b : number, a : number) : void {\r\n        this.r -= r | 0;\r\n        this.g -= g | 0;\r\n        this.b -= b | 0;\r\n        this.a -= a | 0;\r\n    }\r\n\r\n    /*\r\n     public subtract(r : number, g : number, b : number, a : number) : void {\r\n     this.r = (-r + this.r) | 0;\r\n     this.g = (-g + this.g) | 0;\r\n     this.b = (-b + this.b) | 0;\r\n     this.a = (-a + this.a) | 0;\r\n\r\n     this.r -= r;\r\n     this.g -= g;\r\n     this.b -= b;\r\n     this.a -= a;\r\n\r\n     this.r -= r | 0;\r\n     this.g -= g | 0;\r\n     this.b -= b | 0;\r\n     this.a -= a | 0;\r\n     }\r\n     */\r\n}\r\n\r\nexport class NeuQuant implements IPaletteQuantizer {\r\n    /*\r\n     four primes near 500 - assume no image has a length so large\r\n     that it is divisible by all four primes\r\n     */\r\n    private static readonly _prime1 : number          = 499;\r\n    private static readonly _prime2 : number          = 491;\r\n    private static readonly _prime3 : number          = 487;\r\n    private static readonly _prime4 : number          = 503;\r\n    private static readonly _minpicturebytes : number = NeuQuant._prime4;\r\n\r\n    // no. of learning cycles\r\n    private static readonly _nCycles : number = 100;\r\n\r\n    // defs for freq and bias\r\n    private static readonly _initialBiasShift : number = 16;\r\n\r\n    // bias for fractions\r\n    private static readonly _initialBias : number = (1 << NeuQuant._initialBiasShift);\r\n    private static readonly _gammaShift : number  = 10;\r\n\r\n    // gamma = 1024\r\n    // TODO: why gamma is never used?\r\n    //private static _gamma : number     = (1 << NeuQuant._gammaShift);\r\n    private static readonly _betaShift : number = 10;\r\n    private static readonly _beta : number      = (NeuQuant._initialBias >> NeuQuant._betaShift);\r\n\r\n    // beta = 1/1024\r\n    private static readonly _betaGamma : number = (NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift));\r\n\r\n    /*\r\n     * for 256 cols, radius starts\r\n     */\r\n    private static readonly _radiusBiasShift : number = 6;\r\n\r\n    // at 32.0 biased by 6 bits\r\n    private static readonly _radiusBias : number = 1 << NeuQuant._radiusBiasShift;\r\n\r\n    // and decreases by a factor of 1/30 each cycle\r\n    private static readonly _radiusDecrease : number = 30;\r\n\r\n    /* defs for decreasing alpha factor */\r\n\r\n    // alpha starts at 1.0\r\n    private static readonly _alphaBiasShift : number = 10;\r\n\r\n    // biased by 10 bits\r\n    private static readonly _initAlpha : number = (1 << NeuQuant._alphaBiasShift);\r\n\r\n    /* radBias and alphaRadBias used for radpower calculation */\r\n    private static readonly _radBiasShift : number      = 8;\r\n    private static readonly _radBias : number           = 1 << NeuQuant._radBiasShift;\r\n    private static readonly _alphaRadBiasShift : number = NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\r\n    private static readonly _alphaRadBias : number      = 1 << NeuQuant._alphaRadBiasShift;\r\n\r\n    private _pointArray : Point[];\r\n    private readonly _networkSize : number;\r\n    private _network : Neuron[];\r\n\r\n    /** sampling factor 1..30 */\r\n    private readonly _sampleFactor : number;\r\n    private _radPower : number[];\r\n\r\n    // bias and freq arrays for learning\r\n    private _freq : number[];\r\n\r\n    /* for network lookup - really 256 */\r\n    private _bias : number[];\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256) {\r\n        this._distance     = colorDistanceCalculator;\r\n        this._pointArray   = [];\r\n        this._sampleFactor = 1;\r\n        this._networkSize  = colors;\r\n\r\n        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n    }\r\n\r\n    sample(pointBuffer : PointContainer) : void {\r\n        this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());\r\n    }\r\n\r\n    quantize() : Palette {\r\n        this._init();\r\n        this._learn();\r\n\r\n        return this._buildPalette();\r\n    }\r\n\r\n    private _init() : void {\r\n        this._freq     = [];\r\n        this._bias     = [];\r\n        this._radPower = [];\r\n        this._network  = [];\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            this._network[ i ] = new Neuron((i << (networkBiasShift + 8)) / this._networkSize | 0);\r\n\r\n            // 1/this._networkSize\r\n            this._freq[ i ] = NeuQuant._initialBias / this._networkSize | 0;\r\n            this._bias[ i ] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    private _learn() : void {\r\n        let sampleFactor   = this._sampleFactor;\r\n        const pointsNumber = this._pointArray.length;\r\n        if (pointsNumber < NeuQuant._minpicturebytes) sampleFactor = 1;\r\n\r\n        const alphadec       = 30 + (sampleFactor - 1) / 3 | 0,\r\n              pointsToSample = pointsNumber / sampleFactor | 0;\r\n\r\n        let delta  = pointsToSample / NeuQuant._nCycles | 0,\r\n            alpha  = NeuQuant._initAlpha,\r\n            radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\r\n\r\n        let rad = radius >> NeuQuant._radiusBiasShift;\r\n        if (rad <= 1) rad = 0;\r\n\r\n        for (let i = 0; i < rad; i++) {\r\n            this._radPower[ i ] = alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n        }\r\n\r\n        let step : number;\r\n        if (pointsNumber < NeuQuant._minpicturebytes) {\r\n            step = 1;\r\n        } else if (pointsNumber % NeuQuant._prime1 != 0) {\r\n            step = NeuQuant._prime1;\r\n        } else if ((pointsNumber % NeuQuant._prime2) != 0) {\r\n            step = NeuQuant._prime2;\r\n        } else if ((pointsNumber % NeuQuant._prime3) != 0) {\r\n            step = NeuQuant._prime3;\r\n        } else {\r\n            step = NeuQuant._prime4;\r\n        }\r\n\r\n        for (let i = 0, pointIndex = 0; i < pointsToSample;) {\r\n            const point       = this._pointArray[ pointIndex ],\r\n                  b           = point.b << networkBiasShift,\r\n                  g           = point.g << networkBiasShift,\r\n                  r           = point.r << networkBiasShift,\r\n                  a           = point.a << networkBiasShift,\r\n                  neuronIndex = this._contest(b, g, r, a);\r\n\r\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n            if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n\r\n            /* alter neighbours */\r\n            pointIndex += step;\r\n            if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\r\n            i++;\r\n\r\n            if (delta === 0) delta = 1;\r\n\r\n            if (i % delta === 0) {\r\n                alpha -= (alpha / alphadec) | 0;\r\n                radius -= (radius / NeuQuant._radiusDecrease) | 0;\r\n                rad = radius >> NeuQuant._radiusBiasShift;\r\n\r\n                if (rad <= 1) rad = 0;\r\n                for (let j = 0; j < rad; j++) this._radPower[ j ] = alpha * (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _buildPalette() : Palette {\r\n        const palette = new Palette();\r\n\r\n        this._network.forEach(neuron => {\r\n            palette.add(neuron.toPoint());\r\n        });\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    private _alterNeighbour(rad : number, i : number, b : number, g : number, r : number, al : number) : void {\r\n        let lo = i - rad;\r\n        if (lo < -1) lo = -1;\r\n\r\n        let hi = i + rad;\r\n        if (hi > this._networkSize) hi = this._networkSize;\r\n\r\n        let j = i + 1,\r\n            k = i - 1,\r\n            m = 1;\r\n\r\n        while (j < hi || k > lo) {\r\n            const a = this._radPower[ m++ ] / NeuQuant._alphaRadBias;\r\n            if (j < hi) {\r\n                const p = this._network[ j++ ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n\r\n            if (k > lo) {\r\n                const p = this._network[ k-- ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    private _alterSingle(alpha : number, i : number, b : number, g : number, r : number, a : number) : void {\r\n        alpha /= NeuQuant._initAlpha;\r\n\r\n        /* alter hit neuron */\r\n        const n = this._network[ i ];\r\n        n.subtract(\r\n            alpha * (n.r - r),\r\n            alpha * (n.g - g),\r\n            alpha * (n.b - b),\r\n            alpha * (n.a - a)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    private _contest(b : number, g : number, r : number, a : number) : number {\r\n        const multiplier = (255 * 4) << networkBiasShift;\r\n\r\n        let bestd       = ~(1 << 31),\r\n            bestbiasd   = bestd,\r\n            bestpos     = -1,\r\n            bestbiaspos = bestpos;\r\n\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            const n    = this._network[ i ],\r\n                  dist = this._distance.calculateNormalized(<any>n, <any>{ r, g, b, a }) * multiplier | 0;\r\n\r\n            if (dist < bestd) {\r\n                bestd   = dist;\r\n                bestpos = i;\r\n            }\r\n\r\n            const biasdist = dist - ((this._bias[ i ]) >> (NeuQuant._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd   = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            const betafreq = (this._freq[ i ] >> NeuQuant._betaShift);\r\n            this._freq[ i ] -= betafreq;\r\n            this._bias[ i ] += (betafreq << NeuQuant._gammaShift);\r\n        }\r\n        this._freq[ bestpos ] += NeuQuant._beta;\r\n        this._bias[ bestpos ] -= NeuQuant._betaGamma;\r\n        return bestbiaspos;\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/neuquant/neuquant.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * palette.ts - part of Image Quantization Library\r\n */\r\n\r\nimport { Point } from \"./point\"\r\nimport { PointContainer } from \"./pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { rgb2hsl } from \"../conversion/rgb2hsl\"\r\n\r\n// TODO: make paletteArray via pointBuffer, so, export will be available via pointBuffer.exportXXX\r\n\r\nconst hueGroups : number = 10;\r\n\r\nexport function hueGroup(hue : number, segmentsNumber : number) {\r\n    const maxHue = 360,\r\n          seg    = maxHue / segmentsNumber,\r\n          half   = seg / 2;\r\n\r\n    for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\r\n        if (hue >= mid && hue < mid + seg) return i;\r\n    }\r\n    return 0;\r\n}\r\n\r\nexport class Palette {\r\n    private readonly _pointContainer : PointContainer;\r\n    private readonly _pointArray : Point[]          = [];\r\n    private _i32idx : { [ key : string ] : number } = {};\r\n\r\n    constructor() {\r\n        this._pointContainer = new PointContainer();\r\n        this._pointContainer.setHeight(1);\r\n        this._pointArray = this._pointContainer.getPointArray();\r\n    }\r\n\r\n    add(color : Point) {\r\n        this._pointArray.push(color);\r\n        this._pointContainer.setWidth(this._pointArray.length);\r\n    }\r\n\r\n    has(color : Point) {\r\n        for (let i = this._pointArray.length - 1; i >= 0; i--) {\r\n            if (color.uint32 === this._pointArray[ i ].uint32) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\r\n    getNearestColor(colorDistanceCalculator : AbstractDistanceCalculator, color : Point) : Point {\r\n        return this._pointArray[ this.getNearestIndex(colorDistanceCalculator, color) | 0 ];\r\n    }\r\n\r\n    getPointContainer() : PointContainer {\r\n        return this._pointContainer;\r\n    }\r\n\r\n    // TOTRY: use HUSL - http://boronine.com/husl/\r\n    /*\r\n     public nearestIndexByUint32(i32) {\r\n     var idx : number = this._nearestPointFromCache(\"\" + i32);\r\n     if (idx >= 0) return idx;\r\n\r\n     var min = 1000,\r\n     rgb = [\r\n     (i32 & 0xff),\r\n     (i32 >>> 8) & 0xff,\r\n     (i32 >>> 16) & 0xff,\r\n     (i32 >>> 24) & 0xff\r\n     ],\r\n     len = this._pointArray.length;\r\n\r\n     idx = 0;\r\n     for (var i = 0; i < len; i++) {\r\n     var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\r\n\r\n     if (dist < min) {\r\n     min = dist;\r\n     idx = i;\r\n     }\r\n     }\r\n\r\n     this._i32idx[i32] = idx;\r\n     return idx;\r\n     }\r\n     */\r\n\r\n    private _nearestPointFromCache(key : string) {\r\n        return typeof this._i32idx[ key ] === \"number\" ? this._i32idx[ key ] : -1;\r\n    }\r\n\r\n    private getNearestIndex(colorDistanceCalculator : AbstractDistanceCalculator, point : Point) : number {\r\n        let idx : number = this._nearestPointFromCache(\"\" + point.uint32);\r\n        if (idx >= 0) return idx;\r\n\r\n        let minimalDistance : number = Number.MAX_VALUE;\r\n\r\n        idx = 0;\r\n        for (let i = 0, l = this._pointArray.length; i < l; i++) {\r\n            const p        = this._pointArray[ i ],\r\n                  distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\r\n\r\n            if (distance < minimalDistance) {\r\n                minimalDistance = distance;\r\n                idx             = i;\r\n            }\r\n        }\r\n\r\n        this._i32idx[ point.uint32 ] = idx;\r\n        return idx;\r\n    }\r\n\r\n    /*\r\n     public reduce(histogram : ColorHistogram, colors : number) {\r\n     if (this._pointArray.length > colors) {\r\n     var idxi32 = histogram.getImportanceSortedColorsIDXI32();\r\n\r\n     // quantize histogram to existing palette\r\n     var keep = [], uniqueColors = 0, idx, pruned = false;\r\n\r\n     for (var i = 0, len = idxi32.length; i < len; i++) {\r\n     // palette length reached, unset all remaining colors (sparse palette)\r\n     if (uniqueColors >= colors) {\r\n     this.prunePal(keep);\r\n     pruned = true;\r\n     break;\r\n     } else {\r\n     idx = this.nearestIndexByUint32(idxi32[i]);\r\n     if (keep.indexOf(idx) < 0) {\r\n     keep.push(idx);\r\n     uniqueColors++;\r\n     }\r\n     }\r\n     }\r\n\r\n     if (!pruned) {\r\n     this.prunePal(keep);\r\n     }\r\n     }\r\n     }\r\n\r\n     // TODO: check usage, not tested!\r\n     public prunePal(keep : number[]) {\r\n     var colors = this._pointArray.length;\r\n     for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n     if (keep.indexOf(colorIndex) < 0) {\r\n\r\n     if(colorIndex + 1 < colors) {\r\n     this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\r\n     }\r\n     --colors;\r\n     //this._pointArray[colorIndex] = null;\r\n     }\r\n     }\r\n     console.log(\"colors pruned: \" + (this._pointArray.length - colors));\r\n     this._pointArray.length = colors;\r\n     this._i32idx = {};\r\n     }\r\n     */\r\n\r\n    // TODO: group very low lum and very high lum colors\r\n    // TODO: pass custom sort order\r\n    // TODO: sort criteria function should be placed to HueStats class\r\n    sort() {\r\n        this._i32idx = {};\r\n        this._pointArray.sort((a : Point, b : Point) => {\r\n            const hslA = rgb2hsl(a.r, a.g, a.b),\r\n                  hslB = rgb2hsl(b.r, b.g, b.b);\r\n\r\n            // sort all grays + whites together\r\n            const hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + hueGroup(hslA.h, hueGroups),\r\n                  hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + hueGroup(hslB.h, hueGroups);\r\n            /*\r\n             var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\r\n             var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\r\n             */\r\n\r\n            const hueDiff = hueB - hueA;\r\n            if (hueDiff) return -hueDiff;\r\n\r\n            /*\r\n             var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\r\n             if (lumDiff) return -lumDiff;\r\n             */\r\n            const lA = a.getLuminosity(true),\r\n                  lB = b.getLuminosity(true);\r\n\r\n            if (lB - lA !== 0) return lB - lA;\r\n\r\n            const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\r\n            if (satDiff) return -satDiff;\r\n\r\n            return 0;\r\n        });\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/palette.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pointContainer.ts - part of Image Quantization Library\r\n */\r\nimport { Point } from \"./point\"\r\n\r\n/**\r\n * v8 optimizations done.\r\n * fromXXX methods are static to move out polymorphic code from class instance itself.\r\n */\r\nexport class PointContainer {\r\n    private readonly _pointArray : Point[];\r\n    private _width : number;\r\n    private _height : number;\r\n\r\n    constructor() {\r\n        this._width      = 0;\r\n        this._height     = 0;\r\n        this._pointArray = [];\r\n    }\r\n\r\n    getWidth() : number {\r\n        return this._width;\r\n    }\r\n\r\n    getHeight() : number {\r\n        return this._height;\r\n    }\r\n\r\n    setWidth(width : number) : void {\r\n        this._width = width;\r\n    }\r\n\r\n    setHeight(height : number) : void {\r\n        this._height = height;\r\n    }\r\n\r\n    getPointArray() : Point[] {\r\n        return this._pointArray;\r\n    }\r\n\r\n    clone() : PointContainer {\r\n        const clone   = new PointContainer();\r\n        clone._width  = this._width;\r\n        clone._height = this._height;\r\n\r\n        for (let i = 0, l = this._pointArray.length; i < l; i++) {\r\n            clone._pointArray[ i ] = Point.createByUint32(this._pointArray[ i ].uint32 | 0); // \"| 0\" is added for v8 optimization\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    toUint32Array() : Uint32Array {\r\n        const l           = this._pointArray.length,\r\n              uint32Array = new Uint32Array(l);\r\n\r\n        for (let i = 0; i < l; i++) {\r\n            uint32Array[ i ] = this._pointArray[ i ].uint32;\r\n        }\r\n\r\n        return uint32Array;\r\n    }\r\n\r\n    toUint8Array() : Uint8Array {\r\n        return new Uint8Array(this.toUint32Array().buffer);\r\n    }\r\n\r\n    static fromHTMLImageElement(img : HTMLImageElement) : PointContainer {\r\n        const width  = img.naturalWidth,\r\n              height = img.naturalHeight;\r\n\r\n        const canvas  = document.createElement(\"canvas\");\r\n        canvas.width  = width;\r\n        canvas.height = height;\r\n\r\n        const ctx = <CanvasRenderingContext2D>canvas.getContext(\"2d\");\r\n        ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\r\n\r\n        return PointContainer.fromHTMLCanvasElement(canvas);\r\n    }\r\n\r\n    static fromHTMLCanvasElement(canvas : HTMLCanvasElement) : PointContainer {\r\n        const width  = canvas.width,\r\n              height = canvas.height;\r\n\r\n        const ctx     = <CanvasRenderingContext2D>canvas.getContext(\"2d\"),\r\n              imgData = ctx.getImageData(0, 0, width, height);\r\n\r\n        return PointContainer.fromImageData(imgData);\r\n    }\r\n\r\n    static fromNodeCanvas(canvas : any) : PointContainer {\r\n        return PointContainer.fromHTMLCanvasElement(canvas);\r\n    }\r\n\r\n    static fromImageData(imageData : ImageData) : PointContainer {\r\n        const width  = imageData.width,\r\n              height = imageData.height;\r\n\r\n        return PointContainer.fromCanvasPixelArray(imageData.data, width, height);\r\n        /*\r\n         var buf8;\r\n         if (Utils.typeOf(imageData.data) == \"CanvasPixelArray\")\r\n         buf8 = new Uint8Array(imageData.data);\r\n         else\r\n         buf8 = imageData.data;\r\n\r\n         this.fromUint32Array(new Uint32Array(buf8.buffer), width, height);\r\n         */\r\n    }\r\n\r\n    static fromArray(byteArray : number[], width : number, height : number) : PointContainer {\r\n        const uint8array = new Uint8Array(byteArray);\r\n        return PointContainer.fromUint8Array(uint8array, width, height);\r\n    }\r\n\r\n    static fromCanvasPixelArray(data : any, width : number, height : number) : PointContainer {\r\n        return PointContainer.fromArray(data, width, height);\r\n    }\r\n\r\n    static fromUint8Array(uint8array : Uint8Array, width : number, height : number) : PointContainer {\r\n        return PointContainer.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);\r\n    }\r\n\r\n    static fromUint32Array(uint32array : Uint32Array, width : number, height : number) : PointContainer {\r\n        const container = new PointContainer();\r\n\r\n        container._width  = width;\r\n        container._height = height;\r\n\r\n        for (let i = 0, l = uint32array.length; i < l; i++) {\r\n            container._pointArray[ i ] = Point.createByUint32(uint32array[ i ] | 0); // \"| 0\" is added for v8 optimization\r\n        }\r\n\r\n        return container;\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/pointContainer.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * point.ts - part of Image Quantization Library\r\n */\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n/**\r\n * v8 optimized class\r\n * 1) \"constructor\" should have initialization with worst types\r\n * 2) \"set\" should have |0 / >>> 0\r\n */\r\nexport class Point {\r\n    r : number;\r\n    g : number;\r\n    b : number;\r\n    a : number;\r\n    uint32 : number;\r\n    rgba : number[]; // TODO: better name is quadruplet or quad may be?\r\n    Lab : { L : number; a : number; b : number };\r\n\r\n    static createByQuadruplet(quadruplet : number[]) : Point {\r\n        const point : Point = new Point();\r\n\r\n        point.r = quadruplet[ 0 ] | 0;\r\n        point.g = quadruplet[ 1 ] | 0;\r\n        point.b = quadruplet[ 2 ] | 0;\r\n        point.a = quadruplet[ 3 ] | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        //point._loadLab();\r\n        return point;\r\n    }\r\n\r\n    static createByRGBA(red : number, green : number, blue : number, alpha : number) : Point {\r\n        const point : Point = new Point();\r\n\r\n        point.r = red | 0;\r\n        point.g = green | 0;\r\n        point.b = blue | 0;\r\n        point.a = alpha | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        //point._loadLab();\r\n        return point;\r\n    }\r\n\r\n    static createByUint32(uint32 : number) : Point {\r\n        const point : Point = new Point();\r\n\r\n        point.uint32 = uint32 >>> 0;\r\n        point._loadRGBA();\r\n        point._loadQuadruplet();\r\n        //point._loadLab();\r\n        return point;\r\n    }\r\n\r\n    constructor() {\r\n        this.uint32 = -1 >>> 0;\r\n        this.r      = this.g = this.b = this.a = 0;\r\n        this.rgba = new Array(4);\r\n        /*[ this.r , this.g , this.b , this.a ]*/\r\n        this.rgba[ 0 ] = 0;\r\n        this.rgba[ 1 ] = 0;\r\n        this.rgba[ 2 ] = 0;\r\n        this.rgba[ 3 ] = 0;\r\n        /*\r\n         this.Lab = {\r\n         L : 0.0,\r\n         a : 0.0,\r\n         b : 0.0\r\n         };\r\n         */\r\n    }\r\n\r\n    from(point : Point) {\r\n        this.r         = point.r;\r\n        this.g         = point.g;\r\n        this.b         = point.b;\r\n        this.a         = point.a;\r\n        this.uint32    = point.uint32;\r\n        this.rgba[ 0 ] = point.r;\r\n        this.rgba[ 1 ] = point.g;\r\n        this.rgba[ 2 ] = point.b;\r\n        this.rgba[ 3 ] = point.a;\r\n\r\n        /*\r\n         this.Lab.L = point.Lab.L;\r\n         this.Lab.a = point.Lab.a;\r\n         this.Lab.b = point.Lab.b;\r\n         */\r\n    }\r\n\r\n    /*\r\n     * TODO:\r\n     Luminance from RGB:\r\n\r\n     Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\r\n     Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\r\n     Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\r\n     */\r\n    getLuminosity(useAlphaChannel : boolean) : number {\r\n        let r = this.r,\r\n            g = this.g,\r\n            b = this.b;\r\n\r\n        if (useAlphaChannel) {\r\n            r = Math.min(255, 255 - this.a + this.a * r / 255);\r\n            g = Math.min(255, 255 - this.a + this.a * g / 255);\r\n            b = Math.min(255, 255 - this.a + this.a * b / 255);\r\n        }\r\n\r\n        //var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\r\n\r\n        /*\r\n         if(useAlphaChannel) {\r\n         luma = (luma * (255 - this.a)) / 255;\r\n         }\r\n         */\r\n\r\n        return r * Y.RED + g * Y.GREEN + b * Y.BLUE;\r\n    }\r\n\r\n    private _loadUINT32() {\r\n        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\r\n    }\r\n\r\n    private _loadRGBA() {\r\n        this.r = this.uint32 & 0xff;\r\n        this.g = (this.uint32 >>> 8) & 0xff;\r\n        this.b = (this.uint32 >>> 16) & 0xff;\r\n        this.a = (this.uint32 >>> 24) & 0xff;\r\n    }\r\n\r\n    private _loadQuadruplet() {\r\n        this.rgba[ 0 ] = this.r;\r\n        this.rgba[ 1 ] = this.g;\r\n        this.rgba[ 2 ] = this.b;\r\n        this.rgba[ 3 ] = this.a;\r\n\r\n        /*\r\n         var xyz = rgb2xyz(this.r, this.g, this.b);\r\n         var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\r\n         this.lab.l = lab.l;\r\n         this.lab.a = lab.a;\r\n         this.lab.b = lab.b;\r\n         */\r\n    }\r\n\r\n    /*\r\n     private _loadLab() : void {\r\n     var Lab = Color.Conversion.rgb2lab(this.r, this.g, this.b);\r\n     this.Lab.L = Lab.L;\r\n     this.Lab.a = Lab.a;\r\n     this.Lab.b = Lab.b;\r\n     }\r\n     */\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/point.ts\n **/","/*\r\n * NeuQuantFloat Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\nimport { IPaletteQuantizer } from \"../common\"\r\n\r\n// bias for colour values\r\nconst networkBiasShift = 3;\r\n\r\nclass NeuronFloat {\r\n    r : number;\r\n    g : number;\r\n    b : number;\r\n    a : number;\r\n\r\n    constructor(defaultValue : number) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    toPoint() : Point {\r\n        return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    }\r\n\r\n    subtract(r : number, g : number, b : number, a : number) : void {\r\n        this.r -= r;\r\n        this.g -= g;\r\n        this.b -= b;\r\n        this.a -= a;\r\n    }\r\n}\r\n\r\nexport class NeuQuantFloat implements IPaletteQuantizer {\r\n    /*\r\n     four primes near 500 - assume no image has a length so large\r\n     that it is divisible by all four primes\r\n     */\r\n    private static readonly _prime1 : number          = 499;\r\n    private static readonly _prime2 : number          = 491;\r\n    private static readonly _prime3 : number          = 487;\r\n    private static readonly _prime4 : number          = 503;\r\n    private static readonly _minpicturebytes : number = NeuQuantFloat._prime4;\r\n\r\n    // no. of learning cycles\r\n    private static readonly _nCycles : number = 100;\r\n\r\n    // defs for freq and bias\r\n    private static readonly _initialBiasShift : number = 16;\r\n\r\n    // bias for fractions\r\n    private static readonly _initialBias : number = (1 << NeuQuantFloat._initialBiasShift);\r\n    private static readonly _gammaShift : number  = 10;\r\n\r\n    // gamma = 1024\r\n    // TODO: why gamma is never used?\r\n    //private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\r\n    private static readonly _betaShift : number = 10;\r\n    private static readonly _beta : number      = (NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift);\r\n\r\n    // beta = 1/1024\r\n    private static readonly _betaGamma : number = (NeuQuantFloat._initialBias << (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift));\r\n\r\n    /*\r\n     * for 256 cols, radius starts\r\n     */\r\n    private static readonly _radiusBiasShift : number = 6;\r\n\r\n    // at 32.0 biased by 6 bits\r\n    private static readonly _radiusBias : number = 1 << NeuQuantFloat._radiusBiasShift;\r\n\r\n    // and decreases by a factor of 1/30 each cycle\r\n    private static readonly _radiusDecrease : number = 30;\r\n\r\n    /* defs for decreasing alpha factor */\r\n\r\n    // alpha starts at 1.0\r\n    private static readonly _alphaBiasShift : number = 10;\r\n\r\n    // biased by 10 bits\r\n    private static readonly _initAlpha : number = (1 << NeuQuantFloat._alphaBiasShift);\r\n\r\n    /* radBias and alphaRadBias used for radpower calculation */\r\n    private static readonly _radBiasShift : number      = 8;\r\n    private static readonly _radBias : number           = 1 << NeuQuantFloat._radBiasShift;\r\n    private static readonly _alphaRadBiasShift : number = NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\r\n    private static readonly _alphaRadBias : number      = 1 << NeuQuantFloat._alphaRadBiasShift;\r\n\r\n    private _pointArray : Point[];\r\n    private readonly _networkSize : number;\r\n    private _network : NeuronFloat[];\r\n\r\n    /** sampling factor 1..30 */\r\n    private readonly _sampleFactor : number;\r\n    private _radPower : number[];\r\n\r\n    // bias and freq arrays for learning\r\n    private _freq : number[];\r\n\r\n    /* for network lookup - really 256 */\r\n    private _bias : number[];\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256) {\r\n        this._distance     = colorDistanceCalculator;\r\n        this._pointArray   = [];\r\n        this._sampleFactor = 1;\r\n        this._networkSize  = colors;\r\n\r\n        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n    }\r\n\r\n    sample(pointBuffer : PointContainer) : void {\r\n        this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());\r\n    }\r\n\r\n    quantize() : Palette {\r\n        this._init();\r\n        this._learn();\r\n\r\n        return this._buildPalette();\r\n    }\r\n\r\n    private _init() : void {\r\n        this._freq     = [];\r\n        this._bias     = [];\r\n        this._radPower = [];\r\n        this._network  = [];\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            this._network[ i ] = new NeuronFloat((i << (networkBiasShift + 8)) / this._networkSize);\r\n\r\n            // 1/this._networkSize\r\n            this._freq[ i ] = NeuQuantFloat._initialBias / this._networkSize;\r\n            this._bias[ i ] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    private _learn() : void {\r\n        let sampleFactor = this._sampleFactor;\r\n\r\n        let pointsNumber = this._pointArray.length;\r\n        if (pointsNumber < NeuQuantFloat._minpicturebytes) sampleFactor = 1;\r\n\r\n        const alphadec       = 30 + (sampleFactor - 1) / 3,\r\n              pointsToSample = pointsNumber / sampleFactor;\r\n\r\n        let delta  = pointsToSample / NeuQuantFloat._nCycles | 0,\r\n            alpha  = NeuQuantFloat._initAlpha,\r\n            radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\r\n\r\n        let rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n        if (rad <= 1) rad = 0;\r\n\r\n        for (let i = 0; i < rad; i++) {\r\n            this._radPower[ i ] = alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\r\n        }\r\n\r\n        let step : number;\r\n        if (pointsNumber < NeuQuantFloat._minpicturebytes) {\r\n            step = 1;\r\n        } else if (pointsNumber % NeuQuantFloat._prime1 != 0) {\r\n            step = NeuQuantFloat._prime1;\r\n        } else if ((pointsNumber % NeuQuantFloat._prime2) != 0) {\r\n            step = NeuQuantFloat._prime2;\r\n        } else if ((pointsNumber % NeuQuantFloat._prime3) != 0) {\r\n            step = NeuQuantFloat._prime3;\r\n        } else {\r\n            step = NeuQuantFloat._prime4;\r\n        }\r\n\r\n        for (let i = 0, pointIndex = 0; i < pointsToSample;) {\r\n            const point       = this._pointArray[ pointIndex ],\r\n                  b           = point.b << networkBiasShift,\r\n                  g           = point.g << networkBiasShift,\r\n                  r           = point.r << networkBiasShift,\r\n                  a           = point.a << networkBiasShift,\r\n                  neuronIndex = this._contest(b, g, r, a);\r\n\r\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n            if (rad != 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n\r\n            /* alter neighbours */\r\n            pointIndex += step;\r\n            if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\r\n            i++;\r\n\r\n            if (delta == 0) delta = 1;\r\n\r\n            if (i % delta == 0) {\r\n                alpha -= (alpha / alphadec);\r\n                radius -= (radius / NeuQuantFloat._radiusDecrease);\r\n                rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n\r\n                if (rad <= 1) rad = 0;\r\n                for (let j = 0; j < rad; j++) this._radPower[ j ] = alpha * (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private _buildPalette() : Palette {\r\n        const palette = new Palette();\r\n\r\n        this._network.forEach(neuron => {\r\n            palette.add(neuron.toPoint());\r\n        });\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    private _alterNeighbour(rad : number, i : number, b : number, g : number, r : number, al : number) : void {\r\n        let lo = i - rad;\r\n        if (lo < -1) lo = -1;\r\n\r\n        let hi = i + rad;\r\n        if (hi > this._networkSize) hi = this._networkSize;\r\n\r\n        let j = i + 1,\r\n            k = i - 1,\r\n            m = 1;\r\n\r\n        while (j < hi || k > lo) {\r\n            const a = this._radPower[ m++ ] / NeuQuantFloat._alphaRadBias;\r\n            if (j < hi) {\r\n                const p = this._network[ j++ ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n\r\n            if (k > lo) {\r\n                const p = this._network[ k-- ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    private _alterSingle(alpha : number, i : number, b : number, g : number, r : number, a : number) : void {\r\n        alpha /= NeuQuantFloat._initAlpha;\r\n\r\n        /* alter hit neuron */\r\n        const n = this._network[ i ];\r\n        n.subtract(\r\n            alpha * (n.r - r),\r\n            alpha * (n.g - g),\r\n            alpha * (n.b - b),\r\n            alpha * (n.a - a)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    private _contest(b : number, g : number, r : number, al : number) : number {\r\n        const multiplier = (255 * 4) << networkBiasShift;\r\n\r\n        let bestd       = ~(1 << 31),\r\n            bestbiasd   = bestd,\r\n            bestpos     = -1,\r\n            bestbiaspos = bestpos;\r\n\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            const n    = this._network[ i ],\r\n                  dist = this._distance.calculateNormalized(<any>n, <any>{ r : r, g : g, b : b, a : al }) * multiplier;\r\n\r\n            if (dist < bestd) {\r\n                bestd   = dist;\r\n                bestpos = i;\r\n            }\r\n\r\n            const biasdist = dist - ((this._bias[ i ]) >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd   = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            const betafreq = (this._freq[ i ] >> NeuQuantFloat._betaShift);\r\n            this._freq[ i ] -= betafreq;\r\n            this._bias[ i ] += (betafreq << NeuQuantFloat._gammaShift);\r\n        }\r\n        this._freq[ bestpos ] += NeuQuantFloat._beta;\r\n        this._bias[ bestpos ] -= NeuQuantFloat._betaGamma;\r\n        return bestbiaspos;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/neuquant/neuquantFloat.ts\n **/","/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * RgbQuant.js - an image quantization lib\r\n */\r\n\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgbquant.ts - part of Image Quantization Library\r\n */\r\n\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\nimport { ColorHistogram } from \"./colorHistogram\"\r\nimport { IPaletteQuantizer } from \"../common\"\r\nimport { stableSort } from \"../../utils/arithmetic\"\r\n\r\nclass RemovedColor {\r\n    readonly index : number;\r\n    readonly color : Point;\r\n    readonly distance : number;\r\n\r\n    constructor(index : number, color : Point, distance : number) {\r\n        this.index    = index;\r\n        this.color    = color;\r\n        this.distance = distance;\r\n    }\r\n}\r\n\r\n// TODO: make input/output image and input/output palettes with instances of class Point only!\r\nexport class RGBQuant implements IPaletteQuantizer {\r\n    // desired final palette size\r\n    private readonly _colors : number;\r\n\r\n    // color-distance threshold for initial reduction pass\r\n    private readonly _initialDistance : number;\r\n\r\n    // subsequent passes threshold\r\n    private readonly _distanceIncrement : number;\r\n\r\n    // accumulated histogram\r\n    private readonly _histogram : ColorHistogram;\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256, method : number = 2) {\r\n        this._distance = colorDistanceCalculator;\r\n        // desired final palette size\r\n        this._colors   = colors;\r\n\r\n        // histogram to accumulate\r\n        this._histogram = new ColorHistogram(method, colors);\r\n\r\n        this._initialDistance   = 0.01;\r\n        this._distanceIncrement = 0.005;\r\n    }\r\n\r\n    // gathers histogram info\r\n    sample(image : PointContainer) : void {\r\n        /*\r\n         var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\r\n\r\n         for (var i = 0, l = pointArray.length; i < l; i++) {\r\n         var color = pointArray[i];\r\n         for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\r\n         if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\r\n         if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\r\n         }\r\n         }\r\n         var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\r\n         this._distance.setWhitePoint(rd, gd, bd, ad);\r\n\r\n         this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\r\n         */\r\n\r\n        this._histogram.sample(image);\r\n    }\r\n\r\n    // reduces histogram to palette, remaps & memoizes reduced colors\r\n    quantize() : Palette {\r\n        const idxi32 = this._histogram.getImportanceSortedColorsIDXI32()\r\n        if (idxi32.length === 0) {\r\n            throw new Error(\"No colors in image\")\r\n        }\r\n\r\n        const palette = this._buildPalette(idxi32);\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    // reduces similar colors from an importance-sorted Uint32 rgba array\r\n    private _buildPalette(idxi32 : number[]) : Palette {\r\n        // reduce histogram to create initial palette\r\n        // build full rgb palette\r\n        const palette    = new Palette(),\r\n              colorArray = palette.getPointContainer().getPointArray(),\r\n              usageArray = new Array(idxi32.length);\r\n\r\n        for (let i = 0; i < idxi32.length; i++) {\r\n            colorArray.push(Point.createByUint32(idxi32[ i ]));\r\n            usageArray[ i ] = 1;\r\n        }\r\n\r\n        const len                      = colorArray.length,\r\n              memDist : RemovedColor[] = [];\r\n\r\n        let palLen = len,\r\n            thold  = this._initialDistance;\r\n\r\n        // palette already at or below desired length\r\n        while (palLen > this._colors) {\r\n            memDist.length = 0;\r\n\r\n            // iterate palette\r\n            for (let i = 0; i < len; i++) {\r\n                if (usageArray[ i ] === 0) continue;\r\n                const pxi = colorArray[ i ];\r\n                //if (!pxi) continue;\r\n\r\n                for (let j = i + 1; j < len; j++) {\r\n                    if (usageArray[ j ] === 0) continue;\r\n                    const pxj = colorArray[ j ];\r\n                    //if (!pxj) continue;\r\n\r\n                    const dist = this._distance.calculateNormalized(pxi, pxj);\r\n                    if (dist < thold) {\r\n                        // store index,rgb,dist\r\n                        memDist.push(new RemovedColor(j, pxj, dist));\r\n                        usageArray[ j ] = 0;\r\n                        palLen--;\r\n                    }\r\n                }\r\n            }\r\n            // palette reduction pass\r\n            // console.log(\"palette length: \" + palLen);\r\n\r\n            // if palette is still much larger than target, increment by larger initDist\r\n            thold += (palLen > this._colors * 3) ? this._initialDistance : this._distanceIncrement;\r\n        }\r\n\r\n        // if palette is over-reduced, re-add removed colors with largest distances from last round\r\n        if (palLen < this._colors) {\r\n            // sort descending\r\n            stableSort(memDist, function (a : RemovedColor, b : RemovedColor) {\r\n                return b.distance - a.distance;\r\n            });\r\n\r\n            let k = 0;\r\n            while (palLen < this._colors && k < memDist.length) {\r\n                const removedColor               = memDist[ k ];\r\n                // re-inject rgb into final palette\r\n                usageArray[ removedColor.index ] = 1;\r\n                palLen++;\r\n                k++;\r\n            }\r\n        }\r\n\r\n        let colors = colorArray.length;\r\n        for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n            if (usageArray[ colorIndex ] === 0) {\r\n                if (colorIndex !== colors - 1) {\r\n                    colorArray[ colorIndex ] = colorArray[ colors - 1 ];\r\n                }\r\n                --colors;\r\n            }\r\n        }\r\n        colorArray.length = colors;\r\n\r\n        return palette;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/rgbquant/rgbquant.ts\n **/","/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ColorHistogram.js - an image quantization lib\r\n */\r\n\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * colorHistogram.ts - part of Image Quantization Library\r\n */\r\nimport { HueStatistics } from \"../../utils/hueStatistics\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { stableSort } from \"../../utils/arithmetic\"\r\n\r\ninterface Box {\r\n    x : number,\r\n    y : number,\r\n    h : number,\r\n    w : number\r\n}\r\n\r\nexport class ColorHistogram {\r\n    private static _boxSize   = [ 64, 64 ];\r\n    private static _boxPixels = 2;\r\n    private static _hueGroups = 10;\r\n\r\n    // 1 = by global population, 2 = subregion population threshold\r\n    private _method : number;\r\n\r\n    // HueStatistics instance\r\n    private _hueStats : HueStatistics;\r\n\r\n    private _histogram : {[color : string] : number};\r\n\r\n    // # of highest-frequency colors to start with for palette reduction\r\n    private _initColors : number;\r\n\r\n    // if > 0, enables hues stats and min-color retention per group\r\n    private _minHueCols : number;\r\n\r\n    constructor(method : number, colors : number) {\r\n        // 1 = by global population, 2 = subregion population threshold\r\n        this._method = method;\r\n\r\n        // if > 0, enables hues stats and min-color retention per group\r\n        this._minHueCols = colors << 2;//opts.minHueCols || 0;\r\n\r\n        // # of highest-frequency colors to start with for palette reduction\r\n        this._initColors = colors << 2;\r\n\r\n        // HueStatistics instance\r\n        this._hueStats = new HueStatistics(ColorHistogram._hueGroups, this._minHueCols);\r\n\r\n        this._histogram = Object.create(null);\r\n    }\r\n\r\n    sample(pointBuffer : PointContainer) : void {\r\n        switch (this._method) {\r\n            case 1:\r\n                this._colorStats1D(pointBuffer);\r\n                break;\r\n            case 2:\r\n                this._colorStats2D(pointBuffer);\r\n                break;\r\n        }\r\n    }\r\n\r\n    getImportanceSortedColorsIDXI32() {\r\n        // TODO: fix typing issue in stableSort func\r\n        const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[ b ] - this._histogram[ a ]);\r\n        if (sorted.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        let idxi32 : string[];\r\n        switch (this._method) {\r\n            case 1:\r\n                const initialColorsLimit = Math.min(sorted.length, this._initColors),\r\n                      last               = sorted[ initialColorsLimit - 1 ],\r\n                      freq               = this._histogram[ last ];\r\n\r\n                idxi32 = sorted.slice(0, initialColorsLimit);\r\n\r\n                // add any cut off colors with same freq as last\r\n                let pos = initialColorsLimit, len = sorted.length;\r\n                while (pos < len && this._histogram[ sorted[ pos ] ] == freq)\r\n                    idxi32.push(sorted[ pos++ ]);\r\n\r\n                // inject min huegroup colors\r\n                this._hueStats.injectIntoArray(idxi32);\r\n                break;\r\n\r\n            case 2:\r\n                idxi32 = sorted;\r\n                break;\r\n\r\n            default:\r\n                // TODO: rethink errors\r\n                throw new Error(\"Incorrect method\")\r\n        }\r\n\r\n        // int32-ify values\r\n        return (<string[]><any>idxi32).map(function (v : string) {\r\n            return +v;\r\n        });\r\n    }\r\n\r\n    // global top-population\r\n    private _colorStats1D(pointBuffer : PointContainer) {\r\n        const histG      = this._histogram,\r\n              pointArray = pointBuffer.getPointArray(),\r\n              len        = pointArray.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            const col = pointArray[ i ].uint32;\r\n\r\n            // collect hue stats\r\n            this._hueStats.check(col);\r\n\r\n            if (col in histG)\r\n                histG[ col ]++;\r\n            else\r\n                histG[ col ] = 1;\r\n        }\r\n    }\r\n\r\n    // population threshold within subregions\r\n    // FIXME: this can over-reduce (few/no colors same?), need a way to keep\r\n    // important colors that dont ever reach local thresholds (gradients?)\r\n    private _colorStats2D(pointBuffer : PointContainer) {\r\n        const width      = pointBuffer.getWidth(),\r\n              height     = pointBuffer.getHeight(),\r\n              pointArray = pointBuffer.getPointArray();\r\n\r\n        const boxW  = ColorHistogram._boxSize[ 0 ],\r\n              boxH  = ColorHistogram._boxSize[ 1 ],\r\n              area  = boxW * boxH,\r\n              boxes = this._makeBoxes(width, height, boxW, boxH),\r\n              histG = this._histogram;\r\n\r\n        boxes.forEach(box => {\r\n            let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\r\n            if (effc < 2) effc = 2;\r\n\r\n            const histL : { [key : string ] : number} = {};\r\n            this._iterateBox(box, width, (i : number) => {\r\n                const col = pointArray[ i ].uint32;\r\n\r\n                // collect hue stats\r\n                this._hueStats.check(col);\r\n\r\n                if (col in histG)\r\n                    histG[ col ]++;\r\n                else if (col in histL) {\r\n                    if (++histL[ col ] >= effc)\r\n                        histG[ col ] = histL[ col ];\r\n                }\r\n                else\r\n                    histL[ col ] = 1;\r\n            });\r\n        });\r\n\r\n        // inject min huegroup colors\r\n        this._hueStats.injectIntoDictionary(histG);\r\n\r\n    }\r\n\r\n    // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\r\n    private _iterateBox(bbox : Box, wid : number, fn : Function) {\r\n        const b    = bbox,\r\n              i0   = b.y * wid + b.x,\r\n              i1   = (b.y + b.h - 1) * wid + (b.x + b.w - 1),\r\n              incr = wid - b.w + 1;\r\n\r\n        let cnt = 0,\r\n            i   = i0;\r\n\r\n        do {\r\n            fn.call(this, i);\r\n            i += (++cnt % b.w == 0) ? incr : 1;\r\n        } while (i <= i1);\r\n    }\r\n\r\n    /**\r\n     *    partitions a rectangle of width x height into\r\n     *    array of boxes stepX x stepY (or less)\r\n     */\r\n    private _makeBoxes(width : number, height : number, stepX : number, stepY : number) {\r\n        const wrem               = width % stepX,\r\n              hrem               = height % stepY,\r\n              xend               = width - wrem,\r\n              yend               = height - hrem,\r\n              boxesArray : Box[] = [];\r\n\r\n        for (let y = 0; y < height; y += stepY)\r\n            for (let x = 0; x < width; x += stepX)\r\n                boxesArray.push({ x, y, w : (x == xend ? wrem : stepX), h : (y == yend ? hrem : stepY) });\r\n\r\n        return boxesArray;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/rgbquant/colorHistogram.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * hueStatistics.ts - part of Image Quantization Library\r\n */\r\nimport { rgb2hsl } from \"../conversion/rgb2hsl\"\r\nimport { hueGroup } from \"./palette\"\r\n\r\nclass HueGroup {\r\n    num : number    = 0;\r\n    cols : number[] = [];\r\n}\r\n\r\nexport class HueStatistics {\r\n    private _numGroups : number;\r\n    private _minCols : number;\r\n    private _stats : HueGroup[];\r\n    private _groupsFull : number;\r\n\r\n    constructor(numGroups : number, minCols : number) {\r\n        this._numGroups = numGroups;\r\n        this._minCols   = minCols;\r\n        this._stats     = [];\r\n\r\n        for (let i = 0; i <= numGroups; i++) {\r\n            this._stats[ i ] = new HueGroup();\r\n        }\r\n\r\n        this._groupsFull = 0;\r\n    }\r\n\r\n    check(i32 : number) {\r\n        if (this._groupsFull == this._numGroups + 1) {\r\n            this.check = function () {\r\n            };\r\n        }\r\n\r\n        const r   = (i32 & 0xff),\r\n              g   = (i32 >>> 8) & 0xff,\r\n              b   = (i32 >>> 16) & 0xff,\r\n              hg  = (r == g && g == b) ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups),\r\n              gr  = this._stats[ hg ],\r\n              min = this._minCols;\r\n\r\n        gr.num++;\r\n\r\n        if (gr.num > min)\r\n            return;\r\n        if (gr.num == min)\r\n            this._groupsFull++;\r\n\r\n        if (gr.num <= min)\r\n            this._stats[ hg ].cols.push(i32);\r\n    }\r\n\r\n    injectIntoDictionary(histG : { [key : string ] : number}) {\r\n        for (let i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[ i ].num <= this._minCols) {\r\n                this._stats[ i ].cols.forEach((col : number) => {\r\n                    if (!histG[ col ])\r\n                        histG[ col ] = 1;\r\n                    else\r\n                        histG[ col ]++;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    injectIntoArray(histG : string[]) {\r\n        for (let i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[ i ].num <= this._minCols) {\r\n                this._stats[ i ].cols.forEach((col : any) => {\r\n                    if (histG.indexOf(col) == -1)\r\n                        histG.push(col);\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/hueStatistics.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * wuQuant.ts - part of Image Quantization Library\r\n */\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\n\r\nfunction createArray1D(dimension1 : number) {\r\n    const a : number[] = [];\r\n    for (let k = 0; k < dimension1; k++) {\r\n        a[ k ] = 0;\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction createArray4D(dimension1 : number, dimension2 : number, dimension3 : number, dimension4 : number) : number[][][][] {\r\n    const a = new Array(dimension1);\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = new Array(dimension2);\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[ i ][ j ] = new Array(dimension3);\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[ i ][ j ][ k ] = new Array(dimension4);\r\n                for (let l = 0; l < dimension4; l++) {\r\n                    a[ i ][ j ][ k ][ l ] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction createArray3D(dimension1 : number, dimension2 : number, dimension3 : number) : number[][][] {\r\n    const a = new Array(dimension1);\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = new Array(dimension2);\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[ i ][ j ] = new Array(dimension3);\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[ i ][ j ][ k ] = 0;\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction fillArray3D<T>(a : T[][][], dimension1 : number, dimension2 : number, dimension3 : number, value : T) : void {\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = [];\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[ i ][ j ] = [];\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[ i ][ j ][ k ] = value;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction fillArray1D<T>(a : T[], dimension1 : number, value : T) : void {\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = value;\r\n    }\r\n}\r\n\r\nexport class WuColorCube {\r\n    redMinimum : number;\r\n    redMaximum : number;\r\n    greenMinimum : number;\r\n    greenMaximum : number;\r\n    blueMinimum : number;\r\n    blueMaximum : number;\r\n    volume : number;\r\n    alphaMinimum : number;\r\n    alphaMaximum : number;\r\n}\r\n\r\nexport class WuQuant {\r\n\r\n    private static readonly alpha = 3;\r\n    private static readonly red   = 2;\r\n    private static readonly green = 1;\r\n    private static readonly blue  = 0;\r\n\r\n    private _reds : number[];\r\n    private _greens : number[];\r\n    private _blues : number[];\r\n    private _alphas : number[];\r\n    private _sums : number[];\r\n\r\n    private _weights : number[][][][];\r\n    private _momentsRed : number[][][][];\r\n    private _momentsGreen : number[][][][];\r\n    private _momentsBlue : number[][][][];\r\n    private _momentsAlpha : number[][][][];\r\n    private _moments : number[][][][];\r\n\r\n    private _table : number[];\r\n    private _pixels : Point[];\r\n\r\n    private _cubes : WuColorCube[];\r\n    private _colors : number;\r\n\r\n    private _significantBitsPerChannel : number;\r\n    private _maxSideIndex : number;\r\n    private _alphaMaxSideIndex : number;\r\n    private _sideSize : number;\r\n    private _alphaSideSize : number;\r\n\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256, significantBitsPerChannel : number = 5) {\r\n        this._distance = colorDistanceCalculator;\r\n        this._setQuality(significantBitsPerChannel);\r\n        this._initialize(colors);\r\n    }\r\n\r\n    sample(image : PointContainer) : void {\r\n        const pointArray = image.getPointArray();\r\n\r\n        for (let i = 0, l = pointArray.length; i < l; i++) {\r\n            this._addColor(pointArray[ i ]);\r\n        }\r\n\r\n        this._pixels = this._pixels.concat(pointArray);\r\n    }\r\n\r\n    quantize() : Palette {\r\n        this._preparePalette();\r\n\r\n        const palette : Palette = new Palette();\r\n\r\n        // generates palette\r\n        for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\r\n            if (this._sums[ paletteIndex ] > 0) {\r\n                const sum = this._sums[ paletteIndex ],\r\n                      r   = this._reds[ paletteIndex ] / sum,\r\n                      g   = this._greens[ paletteIndex ] / sum,\r\n                      b   = this._blues[ paletteIndex ] / sum,\r\n                      a   = this._alphas[ paletteIndex ] / sum;\r\n\r\n                const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\r\n                palette.add(color);\r\n            }\r\n        }\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    private _preparePalette() : void {\r\n        // preprocess the colors\r\n        this._calculateMoments();\r\n\r\n        let next           = 0,\r\n            volumeVariance = createArray1D(this._colors);\r\n\r\n        // processes the cubes\r\n        for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\r\n            // if cut is possible; make it\r\n            if (this._cut(this._cubes[ next ], this._cubes[ cubeIndex ])) {\r\n                volumeVariance[ next ]      = this._cubes[ next ].volume > 1 ? this._calculateVariance(this._cubes[ next ]) : 0.0;\r\n                volumeVariance[ cubeIndex ] = this._cubes[ cubeIndex ].volume > 1 ? this._calculateVariance(this._cubes[ cubeIndex ]) : 0.0;\r\n            } else {\r\n                // the cut was not possible, revert the index\r\n                volumeVariance[ next ] = 0.0;\r\n                cubeIndex--;\r\n            }\r\n\r\n            next     = 0;\r\n            let temp = volumeVariance[ 0 ];\r\n\r\n            for (let index = 1; index <= cubeIndex; ++index) {\r\n                if (volumeVariance[ index ] > temp) {\r\n                    temp = volumeVariance[ index ];\r\n                    next = index;\r\n                }\r\n            }\r\n\r\n            if (temp <= 0.0) {\r\n                this._colors = cubeIndex + 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        const lookupRed : number[]   = [],\r\n              lookupGreen : number[] = [],\r\n              lookupBlue : number[]  = [],\r\n              lookupAlpha : number[] = [];\r\n\r\n        // precalculates lookup tables\r\n        for (let k = 0; k < this._colors; ++k) {\r\n\r\n            const weight = WuQuant._volume(this._cubes[ k ], this._weights);\r\n\r\n            if (weight > 0) {\r\n                lookupRed[ k ]   = (WuQuant._volume(this._cubes[ k ], this._momentsRed) / weight) | 0;\r\n                lookupGreen[ k ] = (WuQuant._volume(this._cubes[ k ], this._momentsGreen) / weight) | 0;\r\n                lookupBlue[ k ]  = (WuQuant._volume(this._cubes[ k ], this._momentsBlue) / weight) | 0;\r\n                lookupAlpha[ k ] = (WuQuant._volume(this._cubes[ k ], this._momentsAlpha) / weight) | 0;\r\n            } else {\r\n                lookupRed[ k ]   = 0;\r\n                lookupGreen[ k ] = 0;\r\n                lookupBlue[ k ]  = 0;\r\n                lookupAlpha[ k ] = 0;\r\n            }\r\n        }\r\n\r\n        this._reds   = createArray1D(this._colors + 1);\r\n        this._greens = createArray1D(this._colors + 1);\r\n        this._blues  = createArray1D(this._colors + 1);\r\n        this._alphas = createArray1D(this._colors + 1);\r\n        this._sums   = createArray1D(this._colors + 1);\r\n\r\n        // scans and adds colors\r\n        for (let index = 0, l = this._pixels.length; index < l; index++) {\r\n            const color : Point = this._pixels[ index ];\r\n\r\n            const match = -1;\r\n\r\n            let bestMatch    = match,\r\n                bestDistance = Number.MAX_VALUE;\r\n\r\n            for (let lookup = 0; lookup < this._colors; lookup++) {\r\n                const foundRed   = lookupRed[ lookup ],\r\n                      foundGreen = lookupGreen[ lookup ],\r\n                      foundBlue  = lookupBlue[ lookup ],\r\n                      foundAlpha = lookupAlpha[ lookup ];\r\n\r\n                const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\r\n                //var distance = this._distance.calculateRaw(Utils.Point.createByRGBA(foundRed, foundGreen, foundBlue, foundAlpha), color);\r\n                //deltaRed   = color.r - foundRed,\r\n                //deltaGreen = color.g - foundGreen,\r\n                //deltaBlue  = color.b - foundBlue,\r\n                //deltaAlpha = color.a - foundAlpha,\r\n\r\n                //distance   = deltaRed * deltaRed + deltaGreen * deltaGreen + deltaBlue * deltaBlue + deltaAlpha * deltaAlpha;\r\n\r\n                if (distance < bestDistance) {\r\n                    bestDistance = distance;\r\n                    bestMatch    = lookup;\r\n                }\r\n            }\r\n\r\n            this._reds[ bestMatch ] += color.r;\r\n            this._greens[ bestMatch ] += color.g;\r\n            this._blues[ bestMatch ] += color.b;\r\n            this._alphas[ bestMatch ] += color.a;\r\n            this._sums[ bestMatch ]++;\r\n        }\r\n    }\r\n\r\n    private _addColor(color : Point) : void {\r\n        const bitsToRemove = 8 - this._significantBitsPerChannel,\r\n              indexRed     = (color.r >> bitsToRemove) + 1,\r\n              indexGreen   = (color.g >> bitsToRemove) + 1,\r\n              indexBlue    = (color.b >> bitsToRemove) + 1,\r\n              indexAlpha   = (color.a >> bitsToRemove) + 1;\r\n\r\n        //if(color.a > 10) {\r\n        this._weights[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ]++;\r\n        this._momentsRed[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.r;\r\n        this._momentsGreen[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.g;\r\n        this._momentsBlue[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.b;\r\n        this._momentsAlpha[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.a;\r\n        this._moments[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += this._table[ color.r ] + this._table[ color.g ] + this._table[ color.b ] + this._table[ color.a ];\r\n//\t\t\t}\r\n    }\r\n\r\n    /**\r\n     * Converts the histogram to a series of _moments.\r\n     */\r\n    private _calculateMoments() : void {\r\n        const area : number[]      = [],\r\n              areaRed : number[]   = [],\r\n              areaGreen : number[] = [],\r\n              areaBlue : number[]  = [],\r\n              areaAlpha : number[] = [],\r\n              area2 : number[]     = [];\r\n\r\n        const xarea : number[][][]      = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaRed : number[][][]   = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaGreen : number[][][] = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaBlue : number[][][]  = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaAlpha : number[][][] = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xarea2 : number[][][]     = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n\r\n        for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {\r\n            fillArray3D<number>(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\r\n\r\n            for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {\r\n                fillArray1D<number>(area, this._sideSize, 0);\r\n                fillArray1D<number>(areaRed, this._sideSize, 0);\r\n                fillArray1D<number>(areaGreen, this._sideSize, 0);\r\n                fillArray1D<number>(areaBlue, this._sideSize, 0);\r\n                fillArray1D<number>(areaAlpha, this._sideSize, 0);\r\n                fillArray1D<number>(area2, this._sideSize, 0);\r\n\r\n                for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\r\n                    let line      = 0,\r\n                        lineRed   = 0,\r\n                        lineGreen = 0,\r\n                        lineBlue  = 0,\r\n                        lineAlpha = 0,\r\n                        line2     = 0.0;\r\n\r\n                    for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\r\n                        line += this._weights[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineRed += this._momentsRed[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineGreen += this._momentsGreen[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineBlue += this._momentsBlue[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineAlpha += this._momentsAlpha[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        line2 += this._moments[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n\r\n                        area[ blueIndex ] += line;\r\n                        areaRed[ blueIndex ] += lineRed;\r\n                        areaGreen[ blueIndex ] += lineGreen;\r\n                        areaBlue[ blueIndex ] += lineBlue;\r\n                        areaAlpha[ blueIndex ] += lineAlpha;\r\n                        area2[ blueIndex ] += line2;\r\n\r\n                        xarea[ redIndex ][ greenIndex ][ blueIndex ]      = xarea[ redIndex - 1 ][ greenIndex ][ blueIndex ] + area[ blueIndex ];\r\n                        xareaRed[ redIndex ][ greenIndex ][ blueIndex ]   = xareaRed[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaRed[ blueIndex ];\r\n                        xareaGreen[ redIndex ][ greenIndex ][ blueIndex ] = xareaGreen[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaGreen[ blueIndex ];\r\n                        xareaBlue[ redIndex ][ greenIndex ][ blueIndex ]  = xareaBlue[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaBlue[ blueIndex ];\r\n                        xareaAlpha[ redIndex ][ greenIndex ][ blueIndex ] = xareaAlpha[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaAlpha[ blueIndex ];\r\n                        xarea2[ redIndex ][ greenIndex ][ blueIndex ]     = xarea2[ redIndex - 1 ][ greenIndex ][ blueIndex ] + area2[ blueIndex ];\r\n\r\n                        this._weights[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]      = this._weights[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xarea[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsRed[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]   = this._momentsRed[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaRed[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsGreen[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ] = this._momentsGreen[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaGreen[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsBlue[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]  = this._momentsBlue[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaBlue[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsAlpha[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ] = this._momentsAlpha[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaAlpha[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._moments[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]      = this._moments[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xarea2[ redIndex ][ greenIndex ][ blueIndex ];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    private static _volumeFloat(cube : WuColorCube, moment : number[][][][]) : number {\r\n        return (moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n\r\n            (moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n    }\r\n\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    private static _volume(cube : WuColorCube, moment : number[][][][]) : number {\r\n        return WuQuant._volumeFloat(cube, moment) | 0;\r\n    }\r\n\r\n    /**\r\n     * Splits the cube in given position][and color direction.\r\n     */\r\n    private static _top(cube : WuColorCube, direction : number, position : number, moment : number[][][][]) : number {\r\n        let result : number;\r\n        switch (direction) {\r\n            case WuQuant.alpha:\r\n                result = (moment[ position ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ position ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (moment[ position ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ position ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n                break;\r\n\r\n            case WuQuant.red:\r\n                result = (moment[ cube.alphaMaximum ][ position ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMaximum ][ position ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (moment[ cube.alphaMaximum ][ position ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMaximum ][ position ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n                break;\r\n\r\n            case WuQuant.green:\r\n                result = (moment[ cube.alphaMaximum ][ cube.redMaximum ][ position ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ position ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ position ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ position ][ cube.blueMaximum ]) -\r\n                    (moment[ cube.alphaMaximum ][ cube.redMaximum ][ position ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ position ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ position ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ position ][ cube.blueMinimum ]);\r\n                break;\r\n\r\n            case WuQuant.blue:\r\n                result = (moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ position ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ position ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ position ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ position ]) -\r\n                    (moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ position ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ position ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ position ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ position ]);\r\n                break;\r\n            default:\r\n                throw new Error(\"impossible\")\r\n        }\r\n\r\n        return result | 0;\r\n    }\r\n\r\n    /**\r\n     * Splits the cube in a given color direction at its minimum.\r\n     */\r\n    private static _bottom(cube : WuColorCube, direction : number, moment : number[][][][]) : number {\r\n        switch (direction) {\r\n            case WuQuant.alpha:\r\n                return (-moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (-moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            case WuQuant.red:\r\n                return (-moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (-moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            case WuQuant.green:\r\n                return (-moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (-moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            case WuQuant.blue:\r\n                return (-moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]) -\r\n                    (-moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            default:\r\n                // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates statistical variance for a given cube.\r\n     */\r\n    private  _calculateVariance(cube : WuColorCube) : number {\r\n        const volumeRed    = WuQuant._volume(cube, this._momentsRed),\r\n              volumeGreen  = WuQuant._volume(cube, this._momentsGreen),\r\n              volumeBlue   = WuQuant._volume(cube, this._momentsBlue),\r\n              volumeAlpha  = WuQuant._volume(cube, this._momentsAlpha),\r\n              volumeMoment = WuQuant._volumeFloat(cube, this._moments),\r\n              volumeWeight = WuQuant._volume(cube, this._weights),\r\n              distance     = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\r\n\r\n        return volumeMoment - (distance / volumeWeight);\r\n    }\r\n\r\n    /**\r\n     * Finds the optimal (maximal) position for the cut.\r\n     */\r\n    private _maximize(cube : WuColorCube, direction : number, first : number, last : number, wholeRed : number, wholeGreen : number, wholeBlue : number, wholeAlpha : number, wholeWeight : number) : {max : number; position : number} {\r\n        const bottomRed    = WuQuant._bottom(cube, direction, this._momentsRed) | 0,\r\n              bottomGreen  = WuQuant._bottom(cube, direction, this._momentsGreen) | 0,\r\n              bottomBlue   = WuQuant._bottom(cube, direction, this._momentsBlue) | 0,\r\n              bottomAlpha  = WuQuant._bottom(cube, direction, this._momentsAlpha) | 0,\r\n              bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\r\n\r\n        let result      = 0.0,\r\n            cutPosition = -1;\r\n\r\n        for (let position = first; position < last; ++position) {\r\n            // determines the cube cut at a certain position\r\n            let halfRed    = bottomRed + WuQuant._top(cube, direction, position, this._momentsRed),\r\n                halfGreen  = bottomGreen + WuQuant._top(cube, direction, position, this._momentsGreen),\r\n                halfBlue   = bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue),\r\n                halfAlpha  = bottomAlpha + WuQuant._top(cube, direction, position, this._momentsAlpha),\r\n                halfWeight = bottomWeight + WuQuant._top(cube, direction, position, this._weights);\r\n\r\n            // the cube cannot be cut at bottom (this would lead to empty cube)\r\n            if (halfWeight != 0) {\r\n                let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha,\r\n                    temp         = halfDistance / halfWeight;\r\n\r\n                halfRed    = wholeRed - halfRed;\r\n                halfGreen  = wholeGreen - halfGreen;\r\n                halfBlue   = wholeBlue - halfBlue;\r\n                halfAlpha  = wholeAlpha - halfAlpha;\r\n                halfWeight = wholeWeight - halfWeight;\r\n\r\n                if (halfWeight != 0) {\r\n                    halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\r\n                    temp += halfDistance / halfWeight;\r\n\r\n                    if (temp > result) {\r\n                        result      = temp;\r\n                        cutPosition = position;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return { max : result, position : cutPosition };\r\n    }\r\n\r\n    // Cuts a cube with another one.\r\n    private _cut(first : WuColorCube, second : WuColorCube) : boolean {\r\n        let direction : number;\r\n\r\n        const wholeRed    = WuQuant._volume(first, this._momentsRed),\r\n              wholeGreen  = WuQuant._volume(first, this._momentsGreen),\r\n              wholeBlue   = WuQuant._volume(first, this._momentsBlue),\r\n              wholeAlpha  = WuQuant._volume(first, this._momentsAlpha),\r\n              wholeWeight = WuQuant._volume(first, this._weights),\r\n\r\n              red         = this._maximize(first, WuQuant.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\r\n              green       = this._maximize(first, WuQuant.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\r\n              blue        = this._maximize(first, WuQuant.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\r\n              alpha       = this._maximize(first, WuQuant.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n\r\n        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\r\n            direction = WuQuant.alpha;\r\n\r\n            // cannot split empty cube\r\n            if (alpha.position < 0) return false;\r\n        } else {\r\n            if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\r\n                direction = WuQuant.red;\r\n            } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\r\n                direction = WuQuant.green;\r\n            } else {\r\n                direction = WuQuant.blue;\r\n            }\r\n        }\r\n\r\n        second.redMaximum   = first.redMaximum;\r\n        second.greenMaximum = first.greenMaximum;\r\n        second.blueMaximum  = first.blueMaximum;\r\n        second.alphaMaximum = first.alphaMaximum;\r\n\r\n        // cuts in a certain direction\r\n        switch (direction) {\r\n            case WuQuant.red:\r\n                second.redMinimum = first.redMaximum = red.position;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.blueMinimum  = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n\r\n            case WuQuant.green:\r\n                second.greenMinimum = first.greenMaximum = green.position;\r\n                second.redMinimum   = first.redMinimum;\r\n                second.blueMinimum  = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n\r\n            case WuQuant.blue:\r\n                second.blueMinimum = first.blueMaximum = blue.position;\r\n                second.redMinimum   = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n\r\n            case WuQuant.alpha:\r\n                second.alphaMinimum = first.alphaMaximum = alpha.position;\r\n                second.blueMinimum  = first.blueMinimum;\r\n                second.redMinimum   = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                break;\r\n        }\r\n\r\n        // determines the volumes after cut\r\n        first.volume  = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\r\n        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\r\n\r\n        // the cut was successful\r\n        return true;\r\n    }\r\n\r\n    private _initialize(colors : number) : void {\r\n        this._colors = colors;\r\n\r\n        // creates all the _cubes\r\n        this._cubes = [];\r\n\r\n        // initializes all the _cubes\r\n        for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\r\n            this._cubes[ cubeIndex ] = new WuColorCube();\r\n        }\r\n\r\n        // resets the reference minimums\r\n        this._cubes[ 0 ].redMinimum   = 0;\r\n        this._cubes[ 0 ].greenMinimum = 0;\r\n        this._cubes[ 0 ].blueMinimum  = 0;\r\n        this._cubes[ 0 ].alphaMinimum = 0;\r\n\r\n        // resets the reference maximums\r\n        this._cubes[ 0 ].redMaximum   = this._maxSideIndex;\r\n        this._cubes[ 0 ].greenMaximum = this._maxSideIndex;\r\n        this._cubes[ 0 ].blueMaximum  = this._maxSideIndex;\r\n        this._cubes[ 0 ].alphaMaximum = this._alphaMaxSideIndex;\r\n\r\n        this._weights      = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsRed   = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsBlue  = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._moments      = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n\r\n        this._table = [];\r\n        for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\r\n            this._table[ tableIndex ] = tableIndex * tableIndex;\r\n        }\r\n\r\n        this._pixels = [];\r\n    }\r\n\r\n    private _setQuality(significantBitsPerChannel : number = 5) : void {\r\n        this._significantBitsPerChannel = significantBitsPerChannel;\r\n        this._maxSideIndex              = 1 << this._significantBitsPerChannel;\r\n        this._alphaMaxSideIndex         = this._maxSideIndex;\r\n\r\n        this._sideSize      = this._maxSideIndex + 1;\r\n        this._alphaSideSize = this._alphaMaxSideIndex + 1;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/wu/wuQuant.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { NearestColor } from \"./nearestColor\"\r\nimport { ErrorDiffusionArray, ErrorDiffusionArrayKernel } from \"./array\"\r\nimport { ErrorDiffusionRiemersma } from \"./riemersma\"\r\n\r\nexport {\r\n    IImageDitherer,\r\n    NearestColor,\r\n    ErrorDiffusionArray,\r\n    ErrorDiffusionArrayKernel,\r\n    ErrorDiffusionRiemersma\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/index.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * nearestColor.ts - part of Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Palette } from \"../utils/palette\"\r\n\r\nexport class NearestColor implements IImageDitherer {\r\n    private _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator) {\r\n        this._distance = colorDistanceCalculator;\r\n    }\r\n\r\n    quantize(pointBuffer : PointContainer, palette : Palette) : PointContainer {\r\n        const pointArray = pointBuffer.getPointArray(),\r\n              width      = pointBuffer.getWidth(),\r\n              height     = pointBuffer.getHeight();\r\n\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0, idx = y * width; x < width; x++, idx++) {\r\n                // Image pixel\r\n                const point = pointArray[ idx ];\r\n                // Reduced pixel\r\n                point.from(palette.getNearestColor(this._distance, point));\r\n            }\r\n        }\r\n        return pointBuffer;\r\n    }\r\n}\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/nearestColor.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Palette } from \"../utils/palette\"\r\nimport { Point } from \"../utils/point\"\r\nimport { inRange0to255Rounded } from \"../utils/arithmetic\"\r\n\r\n// TODO: is it the best name for this enum \"kernel\"?\r\nexport enum ErrorDiffusionArrayKernel {\r\n    FloydSteinberg = 0,\r\n    FalseFloydSteinberg,\r\n    Stucki,\r\n    Atkinson,\r\n    Jarvis,\r\n    Burkes,\r\n    Sierra,\r\n    TwoSierra,\r\n    SierraLite\r\n}\r\n\r\n// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\r\nexport class ErrorDiffusionArray implements IImageDitherer {\r\n    private _minColorDistance : number;\r\n    private _serpentine : boolean;\r\n    private _kernel : number[][];\r\n    /** true = GIMP, false = XNVIEW */\r\n            private _calculateErrorLikeGIMP : boolean;\r\n\r\n    private _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, kernel : ErrorDiffusionArrayKernel, serpentine : boolean = true, minimumColorDistanceToDither : number = 0, calculateErrorLikeGIMP : boolean = false) {\r\n        this._setKernel(kernel);\r\n\r\n        this._distance               = colorDistanceCalculator;\r\n        this._minColorDistance       = minimumColorDistanceToDither;\r\n        this._serpentine             = serpentine;\r\n        this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\r\n    }\r\n\r\n    // adapted from http://jsbin.com/iXofIji/2/edit by PAEz\r\n    // fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\r\n    quantize(pointBuffer : PointContainer, palette : Palette) : PointContainer {\r\n        const pointArray                = pointBuffer.getPointArray(),\r\n              originalPoint             = new Point(),\r\n              width                     = pointBuffer.getWidth(),\r\n              height                    = pointBuffer.getHeight(),\r\n              errorLines : number[][][] = [];\r\n\r\n        let dir           = 1,\r\n            maxErrorLines = 1;\r\n\r\n        // initial error lines (number is taken from dithering kernel)\r\n        for (let i = 0; i < this._kernel.length; i++) {\r\n            const kernelErrorLines = this._kernel[ i ][ 2 ] + 1;\r\n            if (maxErrorLines < kernelErrorLines) maxErrorLines = kernelErrorLines;\r\n        }\r\n        for (let i = 0; i < maxErrorLines; i++) {\r\n            this._fillErrorLine(errorLines[ i ] = [], width);\r\n        }\r\n\r\n        for (let y = 0; y < height; y++) {\r\n            // always serpentine\r\n            if (this._serpentine) dir = dir * -1;\r\n\r\n            const lni    = y * width,\r\n                  xStart = dir == 1 ? 0 : width - 1,\r\n                  xEnd   = dir == 1 ? width : -1;\r\n\r\n            // cyclic shift with erasing\r\n            this._fillErrorLine(errorLines[ 0 ], width);\r\n            // TODO: why it is needed to cast types here?\r\n            errorLines.push(<number[][]>errorLines.shift());\r\n\r\n            const errorLine = errorLines[ 0 ];\r\n            for (let x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {\r\n                // Image pixel\r\n                const point = pointArray[ idx ],\r\n                      //originalPoint = new Utils.Point(),\r\n                      error = errorLine[ x ];\r\n\r\n                originalPoint.from(point);\r\n\r\n                const correctedPoint = Point.createByRGBA(\r\n                    inRange0to255Rounded(point.r + error[ 0 ]),\r\n                    inRange0to255Rounded(point.g + error[ 1 ]),\r\n                    inRange0to255Rounded(point.b + error[ 2 ]),\r\n                    inRange0to255Rounded(point.a + error[ 3 ])\r\n                );\r\n\r\n                // Reduced pixel\r\n                const palettePoint = palette.getNearestColor(this._distance, correctedPoint);\r\n                point.from(palettePoint);\r\n\r\n                // dithering strength\r\n                if (this._minColorDistance) {\r\n                    const dist = this._distance.calculateNormalized(point, palettePoint);\r\n                    if (dist < this._minColorDistance) continue;\r\n                }\r\n\r\n                // Component distance\r\n                let er : number, eg : number, eb : number, ea : number;\r\n                if (this._calculateErrorLikeGIMP) {\r\n                    er = correctedPoint.r - palettePoint.r;\r\n                    eg = correctedPoint.g - palettePoint.g;\r\n                    eb = correctedPoint.b - palettePoint.b;\r\n                    ea = correctedPoint.a - palettePoint.a;\r\n                } else {\r\n                    er = originalPoint.r - palettePoint.r;\r\n                    eg = originalPoint.g - palettePoint.g;\r\n                    eb = originalPoint.b - palettePoint.b;\r\n                    ea = originalPoint.a - palettePoint.a;\r\n                }\r\n\r\n                const dStart = dir == 1 ? 0 : this._kernel.length - 1,\r\n                      dEnd   = dir == 1 ? this._kernel.length : -1;\r\n\r\n                for (let i = dStart; i !== dEnd; i += dir) {\r\n                    const x1 = this._kernel[ i ][ 1 ] * dir,\r\n                          y1 = this._kernel[ i ][ 2 ];\r\n\r\n                    if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\r\n                        const d = this._kernel[ i ][ 0 ],\r\n                              e = errorLines[ y1 ][ x1 + x ];\r\n\r\n                        e[ 0 ] = e[ 0 ] + er * d;\r\n                        e[ 1 ] = e[ 1 ] + eg * d;\r\n                        e[ 2 ] = e[ 2 ] + eb * d;\r\n                        e[ 3 ] = e[ 3 ] + ea * d;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return pointBuffer;\r\n    }\r\n\r\n    private _fillErrorLine(errorLine : number[][], width : number) : void {\r\n        // shrink\r\n        if (errorLine.length > width) {\r\n            errorLine.length = width;\r\n        }\r\n\r\n        // reuse existing arrays\r\n        const l = errorLine.length;\r\n        for (let i = 0; i < l; i++) {\r\n            const error = errorLine[ i ];\r\n            error[ 0 ]  = error[ 1 ] = error[ 2 ] = error[ 3 ] = 0;\r\n        }\r\n\r\n        // create missing arrays\r\n        for (let i = l; i < width; i++) {\r\n            errorLine[ i ] = [ 0.0, 0.0, 0.0, 0.0 ];\r\n        }\r\n    }\r\n\r\n    private _setKernel(kernel : ErrorDiffusionArrayKernel) {\r\n        switch (kernel) {\r\n            case ErrorDiffusionArrayKernel.FloydSteinberg:\r\n                this._kernel = [\r\n                    [ 7 / 16, 1, 0 ],\r\n                    [ 3 / 16, -1, 1 ],\r\n                    [ 5 / 16, 0, 1 ],\r\n                    [ 1 / 16, 1, 1 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\r\n                this._kernel = [\r\n                    [ 3 / 8, 1, 0 ],\r\n                    [ 3 / 8, 0, 1 ],\r\n                    [ 2 / 8, 1, 1 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Stucki:\r\n                this._kernel = [\r\n                    [ 8 / 42, 1, 0 ],\r\n                    [ 4 / 42, 2, 0 ],\r\n                    [ 2 / 42, -2, 1 ],\r\n                    [ 4 / 42, -1, 1 ],\r\n                    [ 8 / 42, 0, 1 ],\r\n                    [ 4 / 42, 1, 1 ],\r\n                    [ 2 / 42, 2, 1 ],\r\n                    [ 1 / 42, -2, 2 ],\r\n                    [ 2 / 42, -1, 2 ],\r\n                    [ 4 / 42, 0, 2 ],\r\n                    [ 2 / 42, 1, 2 ],\r\n                    [ 1 / 42, 2, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Atkinson:\r\n                this._kernel = [\r\n                    [ 1 / 8, 1, 0 ],\r\n                    [ 1 / 8, 2, 0 ],\r\n                    [ 1 / 8, -1, 1 ],\r\n                    [ 1 / 8, 0, 1 ],\r\n                    [ 1 / 8, 1, 1 ],\r\n                    [ 1 / 8, 0, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Jarvis:\r\n                this._kernel = [\t\t\t// Jarvis, Judice, and Ninke / JJN?\r\n                    [ 7 / 48, 1, 0 ],\r\n                    [ 5 / 48, 2, 0 ],\r\n                    [ 3 / 48, -2, 1 ],\r\n                    [ 5 / 48, -1, 1 ],\r\n                    [ 7 / 48, 0, 1 ],\r\n                    [ 5 / 48, 1, 1 ],\r\n                    [ 3 / 48, 2, 1 ],\r\n                    [ 1 / 48, -2, 2 ],\r\n                    [ 3 / 48, -1, 2 ],\r\n                    [ 5 / 48, 0, 2 ],\r\n                    [ 3 / 48, 1, 2 ],\r\n                    [ 1 / 48, 2, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Burkes:\r\n                this._kernel = [\r\n                    [ 8 / 32, 1, 0 ],\r\n                    [ 4 / 32, 2, 0 ],\r\n                    [ 2 / 32, -2, 1 ],\r\n                    [ 4 / 32, -1, 1 ],\r\n                    [ 8 / 32, 0, 1 ],\r\n                    [ 4 / 32, 1, 1 ],\r\n                    [ 2 / 32, 2, 1 ],\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Sierra:\r\n                this._kernel = [\r\n                    [ 5 / 32, 1, 0 ],\r\n                    [ 3 / 32, 2, 0 ],\r\n                    [ 2 / 32, -2, 1 ],\r\n                    [ 4 / 32, -1, 1 ],\r\n                    [ 5 / 32, 0, 1 ],\r\n                    [ 4 / 32, 1, 1 ],\r\n                    [ 2 / 32, 2, 1 ],\r\n                    [ 2 / 32, -1, 2 ],\r\n                    [ 3 / 32, 0, 2 ],\r\n                    [ 2 / 32, 1, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.TwoSierra:\r\n                this._kernel = [\r\n                    [ 4 / 16, 1, 0 ],\r\n                    [ 3 / 16, 2, 0 ],\r\n                    [ 1 / 16, -2, 1 ],\r\n                    [ 2 / 16, -1, 1 ],\r\n                    [ 3 / 16, 0, 1 ],\r\n                    [ 2 / 16, 1, 1 ],\r\n                    [ 1 / 16, 2, 1 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.SierraLite:\r\n                this._kernel = [\r\n                    [ 2 / 4, 1, 0 ],\r\n                    [ 1 / 4, -1, 1 ],\r\n                    [ 1 / 4, 0, 1 ]\r\n                ];\r\n                break;\r\n\r\n            default:\r\n                throw new Error(\"ErrorDiffusionArray: unknown kernel = \" + kernel);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/array.ts\n **/","/**\r\n * @preserve\r\n * MIT License\r\n *\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n *\r\n * nearestColor.ts - part of Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { HilbertCurveBase } from \"./spaceFillingCurves/hilbertCurve\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Palette } from \"../utils/palette\"\r\nimport { Point } from \"../utils/point\"\r\nimport { inRange0to255Rounded } from \"../utils/arithmetic\"\r\n\r\nexport class ErrorDiffusionRiemersma implements IImageDitherer {\r\n    private _distance : AbstractDistanceCalculator;\r\n    private _weights : number[];\r\n    private _errorQueueSize : number;\r\n    private _errorPropagation : number;\r\n    private _max : number;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, errorQueueSize : number = 16, errorPropagation : number = 1) {\r\n        this._distance         = colorDistanceCalculator;\r\n        this._errorPropagation = errorPropagation;\r\n        this._errorQueueSize   = errorQueueSize;\r\n        this._max              = this._errorQueueSize;\r\n        this._createWeights();\r\n    }\r\n\r\n    quantize(pointBuffer : PointContainer, palette : Palette) : PointContainer {\r\n        const curve                                                           = new HilbertCurveBase(),\r\n              pointArray                                                      = pointBuffer.getPointArray(),\r\n              width                                                           = pointBuffer.getWidth(),\r\n              height                                                          = pointBuffer.getHeight(),\r\n              errorQueue : {r : number; g : number; b : number; a : number}[] = [];\r\n\r\n        let head = 0;\r\n\r\n        for (let i = 0; i < this._errorQueueSize; i++) {\r\n            errorQueue[ i ] = { r : 0, g : 0, b : 0, a : 0 };\r\n        }\r\n\r\n        curve.walk(width, height, (x, y) => {\r\n            const p = pointArray[ x + y * width ];\r\n            let r   = p.r, g = p.g, b = p.b, a = p.a;\r\n            for (let i = 0; i < this._errorQueueSize; i++) {\r\n                const weight = this._weights[ i ],\r\n                      e      = errorQueue[ (i + head) % this._errorQueueSize ];\r\n\r\n                r += e.r * weight;\r\n                g += e.g * weight;\r\n                b += e.b * weight;\r\n                a += e.a * weight;\r\n            }\r\n\r\n            const correctedPoint = Point.createByRGBA(\r\n                inRange0to255Rounded(r),\r\n                inRange0to255Rounded(g),\r\n                inRange0to255Rounded(b),\r\n                inRange0to255Rounded(a)\r\n            );\r\n\r\n            const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);\r\n\r\n            // update head and calculate tail\r\n            head       = (head + 1) % this._errorQueueSize;\r\n            const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\r\n\r\n            // update error with new value\r\n            errorQueue[ tail ].r = p.r - quantizedPoint.r;\r\n            errorQueue[ tail ].g = p.g - quantizedPoint.g;\r\n            errorQueue[ tail ].b = p.b - quantizedPoint.b;\r\n            errorQueue[ tail ].a = p.a - quantizedPoint.a;\r\n\r\n            // update point\r\n            p.from(quantizedPoint);\r\n        });\r\n\r\n        return pointBuffer;\r\n    }\r\n\r\n    private _createWeights() : void {\r\n        this._weights = [];\r\n\r\n        const multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1));\r\n        for (let i = 0, next = 1; i < this._errorQueueSize; i++) {\r\n            this._weights[ i ] = (((next + 0.5) | 0) / this._max) * this._errorPropagation;\r\n            next *= multiplier;\r\n        }\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/riemersma.ts\n **/","enum Direction {\r\n    NONE = 0,\r\n    UP,\r\n    LEFT,\r\n    RIGHT,\r\n    DOWN,\r\n}\r\n\r\n// Check code against double-entrance into walk (walk=> callback => walk)\r\nexport class HilbertCurveBase {\r\n    private _x : number;\r\n    private _y : number;\r\n    private _d : number;\r\n    private _width : number;\r\n    private _height : number;\r\n    private _callback : (x : number, y : number, d : number) => void;\r\n    private _level : number;\r\n\r\n    walk(width : number, height : number, visitorCallback : (x : number, y : number, d : number) => void) : void {\r\n        this._x        = 0;\r\n        this._y        = 0;\r\n        this._d        = 0;\r\n        this._width    = width;\r\n        this._height   = height;\r\n        this._callback = visitorCallback;\r\n\r\n        const maxBound = Math.max(width, height);\r\n\r\n        this._level = (Math.log(maxBound) / Math.log(2) + 1) | 0;\r\n        this._walkHilbert(Direction.UP);\r\n        this._visit(Direction.NONE);\r\n    }\r\n\r\n    private _walkHilbert(direction : Direction) {\r\n        if (this._level < 1) return;\r\n\r\n        this._level--;\r\n        switch (direction) {\r\n            case Direction.LEFT:\r\n                this._walkHilbert(Direction.UP);\r\n                this._visit(Direction.RIGHT);\r\n                this._walkHilbert(Direction.LEFT);\r\n                this._visit(Direction.DOWN);\r\n                this._walkHilbert(Direction.LEFT);\r\n                this._visit(Direction.LEFT);\r\n                this._walkHilbert(Direction.DOWN);\r\n                break;\r\n\r\n            case Direction.RIGHT:\r\n                this._walkHilbert(Direction.DOWN);\r\n                this._visit(Direction.LEFT);\r\n                this._walkHilbert(Direction.RIGHT);\r\n                this._visit(Direction.UP);\r\n                this._walkHilbert(Direction.RIGHT);\r\n                this._visit(Direction.RIGHT);\r\n                this._walkHilbert(Direction.UP);\r\n                break;\r\n\r\n            case Direction.UP:\r\n                this._walkHilbert(Direction.LEFT);\r\n                this._visit(Direction.DOWN);\r\n                this._walkHilbert(Direction.UP);\r\n                this._visit(Direction.RIGHT);\r\n                this._walkHilbert(Direction.UP);\r\n                this._visit(Direction.UP);\r\n                this._walkHilbert(Direction.RIGHT);\r\n                break;\r\n\r\n            case Direction.DOWN:\r\n                this._walkHilbert(Direction.RIGHT);\r\n                this._visit(Direction.UP);\r\n                this._walkHilbert(Direction.DOWN);\r\n                this._visit(Direction.LEFT);\r\n                this._walkHilbert(Direction.DOWN);\r\n                this._visit(Direction.DOWN);\r\n                this._walkHilbert(Direction.LEFT);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        this._level++;\r\n    }\r\n\r\n    private _visit(direction : Direction) : void {\r\n        if (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height) {\r\n            this._callback(this._x, this._y, this._d);\r\n            this._d++;\r\n        }\r\n        switch (direction) {\r\n            case Direction.LEFT:\r\n                this._x--;\r\n                break;\r\n            case Direction.RIGHT:\r\n                this._x++;\r\n                break;\r\n            case Direction.UP:\r\n                this._y--;\r\n                break;\r\n            case Direction.DOWN:\r\n                this._y++;\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/spaceFillingCurves/hilbertCurve.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { SSIM } from \"./ssim\"\r\n\r\nexport {\r\n    SSIM\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/quality/index.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ssim.ts - part of Image Quantization Library\r\n */\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n// based on https://github.com/rhys-e/structural-similarity\r\n// http://en.wikipedia.org/wiki/Structural_similarity\r\nconst K1 = 0.01,\r\n      K2 = 0.03;\r\n\r\nexport class SSIM {\r\n    compare(image1 : PointContainer, image2 : PointContainer) {\r\n        if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\r\n            throw new Error(\"Images have different sizes!\");\r\n        }\r\n\r\n        const bitsPerComponent = 8,\r\n              L                = (1 << bitsPerComponent) - 1,\r\n              c1               = Math.pow((K1 * L), 2),\r\n              c2               = Math.pow((K2 * L), 2);\r\n\r\n        let numWindows = 0,\r\n            mssim      = 0.0;\r\n\r\n        //calculate ssim for each window\r\n        this._iterate(image1, image2, (lumaValues1 : number[], lumaValues2 : number[], averageLumaValue1 : number, averageLumaValue2 : number) => {\r\n            //calculate variance and covariance\r\n            let sigxy  = 0.0,\r\n                sigsqx = 0.0,\r\n                sigsqy = 0.0;\r\n\r\n            for (let i = 0; i < lumaValues1.length; i++) {\r\n                sigsqx += Math.pow((lumaValues1[ i ] - averageLumaValue1), 2);\r\n                sigsqy += Math.pow((lumaValues2[ i ] - averageLumaValue2), 2);\r\n\r\n                sigxy += (lumaValues1[ i ] - averageLumaValue1) * (lumaValues2[ i ] - averageLumaValue2);\r\n            }\r\n\r\n            const numPixelsInWin = lumaValues1.length - 1;\r\n            sigsqx /= numPixelsInWin;\r\n            sigsqy /= numPixelsInWin;\r\n            sigxy /= numPixelsInWin;\r\n\r\n            //perform ssim calculation on window\r\n            const numerator   = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2),\r\n                  denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2),\r\n                  ssim        = numerator / denominator;\r\n\r\n            mssim += ssim;\r\n            numWindows++;\r\n\r\n        });\r\n        return mssim / numWindows;\r\n    }\r\n\r\n    private _iterate(image1 : PointContainer, image2 : PointContainer, callback : (lumaValues1 : number[], lumaValues2 : number[], averageLumaValue1 : number, averageLumaValue2 : number) => void) {\r\n        const windowSize = 8,\r\n              width      = image1.getWidth(),\r\n              height     = image1.getHeight();\r\n\r\n        for (let y = 0; y < height; y += windowSize) {\r\n            for (let x = 0; x < width; x += windowSize) {\r\n                // avoid out-of-width/height\r\n                const windowWidth  = Math.min(windowSize, width - x),\r\n                      windowHeight = Math.min(windowSize, height - y);\r\n\r\n                const lumaValues1  = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight),\r\n                      lumaValues2  = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight),\r\n                      averageLuma1 = this._calculateAverageLuma(lumaValues1),\r\n                      averageLuma2 = this._calculateAverageLuma(lumaValues2);\r\n\r\n                callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _calculateLumaValuesForWindow(image : PointContainer, x : number, y : number, width : number, height : number) : number[] {\r\n        const pointArray            = image.getPointArray(),\r\n              lumaValues : number[] = [];\r\n\r\n        let counter = 0;\r\n\r\n        for (let j = y; j < y + height; j++) {\r\n            const offset = j * image.getWidth();\r\n            for (let i = x; i < x + width; i++) {\r\n                const point           = pointArray[ offset + i ];\r\n                lumaValues[ counter ] = point.r * Y.RED + point.g * Y.GREEN + point.b * Y.BLUE;\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return lumaValues;\r\n    }\r\n\r\n    private _calculateAverageLuma(lumaValues : number[]) : number {\r\n        let sumLuma = 0.0;\r\n        for (let i = 0; i < lumaValues.length; i++) {\r\n            sumLuma += lumaValues[ i ];\r\n        }\r\n\r\n        return sumLuma / lumaValues.length;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/quality/ssim.ts\n **/","/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport * as arithmetic from \"./arithmetic\"\r\nimport { HueStatistics } from \"./hueStatistics\"\r\nimport { Palette } from \"./palette\"\r\nimport { Point } from \"./point\"\r\nimport { PointContainer } from \"./pointContainer\"\r\n\r\nexport {\r\n    Point,\r\n    PointContainer,\r\n    Palette,\r\n    HueStatistics,\r\n    arithmetic\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/index.ts\n **/"]},"metadata":{},"sourceType":"script"}