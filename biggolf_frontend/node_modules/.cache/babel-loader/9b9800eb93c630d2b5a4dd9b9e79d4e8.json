{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractAllTo = extractAllTo;\nexports.readEntries = readEntries;\nexports.toInMemoryZip = toInMemoryZip;\nexports._extractEntryTo = _extractEntryTo;\nexports.assertValidZip = assertValidZip;\nexports.toArchive = toArchive;\nexports.default = void 0;\nrequire(\"source-map-support/register\");\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _yauzl = _interopRequireDefault(require(\"yauzl\"));\nvar _archiver = _interopRequireDefault(require(\"archiver\"));\nvar _fs = require(\"fs\");\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _mkdirp = require(\"../lib/mkdirp\");\nvar _stream = _interopRequireDefault(require(\"stream\"));\nvar _fs2 = _interopRequireDefault(require(\"./fs\"));\nvar _system = require(\"./system\");\nvar _base64Stream = require(\"base64-stream\");\nvar _util = require(\"./util\");\nvar _timing = _interopRequireDefault(require(\"./timing\"));\nvar _logger = _interopRequireDefault(require(\"./logger\"));\nvar _getStream = _interopRequireDefault(require(\"get-stream\"));\nvar _teen_process = require(\"teen_process\");\nconst openZip = _bluebird.default.promisify(_yauzl.default.open);\nconst pipeline = _bluebird.default.promisify(_stream.default.pipeline);\nconst ZIP_MAGIC = 'PK';\nconst IFMT = 61440;\nconst IFDIR = 16384;\nconst IFLNK = 40960;\nclass ZipExtractor {\n  constructor(sourcePath) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.zipPath = sourcePath;\n    this.opts = opts;\n    this.canceled = false;\n  }\n  extractFileName(entry) {\n    return _lodash.default.isBuffer(entry.fileName) ? entry.fileName.toString(this.opts.fileNamesEncoding) : entry.fileName;\n  }\n  async extract() {\n    const {\n      dir,\n      fileNamesEncoding\n    } = this.opts;\n    this.zipfile = await openZip(this.zipPath, {\n      lazyEntries: true,\n      decodeStrings: !fileNamesEncoding\n    });\n    this.canceled = false;\n    return new _bluebird.default((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true;\n        reject(err);\n      });\n      this.zipfile.readEntry();\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          resolve();\n        }\n      });\n      this.zipfile.on('entry', async entry => {\n        if (this.canceled) {\n          return;\n        }\n        const fileName = this.extractFileName(entry);\n        if (fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry();\n          return;\n        }\n        const destDir = _path.default.dirname(_path.default.join(dir, fileName));\n        try {\n          await _fs2.default.mkdir(destDir, {\n            recursive: true\n          });\n          const canonicalDestDir = await _fs2.default.realpath(destDir);\n          const relativeDestDir = _path.default.relative(dir, canonicalDestDir);\n          if (relativeDestDir.split(_path.default.sep).includes('..')) {\n            new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${fileName}`);\n          }\n          await this.extractEntry(entry);\n          this.zipfile.readEntry();\n        } catch (err) {\n          this.canceled = true;\n          this.zipfile.close();\n          reject(err);\n        }\n      });\n    });\n  }\n  async extractEntry(entry) {\n    if (this.canceled) {\n      return;\n    }\n    const {\n      dir\n    } = this.opts;\n    const fileName = this.extractFileName(entry);\n    const dest = _path.default.join(dir, fileName);\n    const mode = entry.externalFileAttributes >> 16 & 0xFFFF;\n    const isSymlink = (mode & IFMT) === IFLNK;\n    const isDir = (mode & IFMT) === IFDIR || fileName.endsWith('/') || entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16;\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777;\n    const destDir = isDir ? dest : _path.default.dirname(dest);\n    const mkdirOptions = {\n      recursive: true\n    };\n    if (isDir) {\n      mkdirOptions.mode = procMode;\n    }\n    await _fs2.default.mkdir(destDir, mkdirOptions);\n    if (isDir) {\n      return;\n    }\n    const readStream = await _bluebird.default.promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);\n    if (isSymlink) {\n      const link = await (0, _getStream.default)(readStream);\n      await _fs2.default.symlink(link, dest);\n    } else {\n      await pipeline(readStream, _fs2.default.createWriteStream(dest, {\n        mode: procMode\n      }));\n    }\n  }\n  getExtractedMode(entryMode, isDir) {\n    const {\n      defaultDirMode,\n      defaultFileMode\n    } = this.opts;\n    let mode = entryMode;\n    if (mode === 0) {\n      if (isDir) {\n        if (defaultDirMode) {\n          mode = parseInt(defaultDirMode, 10);\n        }\n        if (!mode) {\n          mode = 0o755;\n        }\n      } else {\n        if (defaultFileMode) {\n          mode = parseInt(defaultFileMode, 10);\n        }\n        if (!mode) {\n          mode = 0o644;\n        }\n      }\n    }\n    return mode;\n  }\n}\nasync function extractAllTo(zipFilePath, destDir) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!_path.default.isAbsolute(destDir)) {\n    throw new Error(`Target path '${destDir}' is expected to be absolute`);\n  }\n  await _fs2.default.mkdir(destDir, {\n    recursive: true\n  });\n  const dir = await _fs2.default.realpath(destDir);\n  if (opts.useSystemUnzip) {\n    try {\n      await extractWithSystemUnzip(zipFilePath, dir);\n      return;\n    } catch (err) {\n      _logger.default.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);\n    }\n  }\n  const extractor = new ZipExtractor(zipFilePath, {\n    ...opts,\n    dir\n  });\n  await extractor.extract();\n}\nasync function extractWithSystemUnzip(zipFilePath, destDir) {\n  const isWindowsHost = (0, _system.isWindows)();\n  let executablePath;\n  try {\n    executablePath = await getExecutablePath(isWindowsHost ? 'powershell.exe' : 'unzip');\n  } catch (e) {\n    throw new Error('Could not find system unzip');\n  }\n  if (isWindowsHost) {\n    await (0, _teen_process.exec)(executablePath, ['-command', 'Expand-Archive', '-LiteralPath', zipFilePath, '-DestinationPath', destDir, '-Force']);\n  } else {\n    await (0, _teen_process.exec)(executablePath, ['-q', '-o', zipFilePath, '-d', destDir]);\n  }\n}\nasync function _extractEntryTo(zipFile, entry, destDir) {\n  const dstPath = _path.default.resolve(destDir, entry.fileName);\n  if (/\\/$/.test(entry.fileName)) {\n    if (!(await _fs2.default.exists(dstPath))) {\n      await (0, _mkdirp.mkdirp)(dstPath);\n    }\n    return;\n  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {\n    await (0, _mkdirp.mkdirp)(_path.default.dirname(dstPath));\n  }\n  const writeStream = (0, _fs.createWriteStream)(dstPath, {\n    flags: 'w'\n  });\n  const writeStreamPromise = new _bluebird.default((resolve, reject) => {\n    writeStream.once('finish', resolve);\n    writeStream.once('error', reject);\n  });\n  const zipReadStream = await new _bluebird.default((resolve, reject) => {\n    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));\n  });\n  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {\n    zipReadStream.once('end', resolve);\n    zipReadStream.once('error', reject);\n  });\n  zipReadStream.pipe(writeStream);\n  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);\n}\nasync function readEntries(zipFilePath, onEntry) {\n  const zipfile = await openZip(zipFilePath, {\n    lazyEntries: true\n  });\n  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {\n    zipfile.once('end', resolve);\n    zipfile.once('error', reject);\n    zipfile.on('entry', async entry => {\n      const res = await onEntry({\n        entry,\n        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)\n      });\n      if (res === false) {\n        return zipfile.emit('end');\n      }\n      zipfile.readEntry();\n    });\n  });\n  zipfile.readEntry();\n  return await zipReadStreamPromise;\n}\nasync function toInMemoryZip(srcPath) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!(await _fs2.default.exists(srcPath))) {\n    throw new Error(`No such file or folder: ${srcPath}`);\n  }\n  const {\n    isMetered = true,\n    encodeToBase64 = false,\n    maxSize = 1 * _util.GiB,\n    level = 9\n  } = opts;\n  const resultBuffers = [];\n  let resultBuffersSize = 0;\n  const resultWriteStream = new _stream.default.Writable({\n    write: (buffer, encoding, next) => {\n      resultBuffers.push(buffer);\n      resultBuffersSize += buffer.length;\n      if (maxSize > 0 && resultBuffersSize > maxSize) {\n        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));\n      }\n      next();\n    }\n  });\n  const archive = (0, _archiver.default)('zip', {\n    zlib: {\n      level\n    }\n  });\n  let srcSize = null;\n  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;\n  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {\n    resultWriteStream.once('error', e => {\n      if (base64EncoderStream) {\n        archive.unpipe(base64EncoderStream);\n        base64EncoderStream.unpipe(resultWriteStream);\n      } else {\n        archive.unpipe(resultWriteStream);\n      }\n      archive.abort();\n      archive.destroy();\n      reject(e);\n    });\n    resultWriteStream.once('finish', () => {\n      srcSize = archive.pointer();\n      resolve();\n    });\n  });\n  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {\n    archive.once('finish', resolve);\n    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));\n  });\n  const timer = isMetered ? new _timing.default().start() : null;\n  if ((await _fs2.default.stat(srcPath)).isDirectory()) {\n    archive.directory(srcPath, false);\n  } else {\n    archive.file(srcPath, {\n      name: _path.default.basename(srcPath)\n    });\n  }\n  if (base64EncoderStream) {\n    archive.pipe(base64EncoderStream);\n    base64EncoderStream.pipe(resultWriteStream);\n  } else {\n    archive.pipe(resultWriteStream);\n  }\n  archive.finalize();\n  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);\n  if (timer) {\n    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);\n  }\n  return Buffer.concat(resultBuffers);\n}\nasync function assertValidZip(filePath) {\n  if (!(await _fs2.default.exists(filePath))) {\n    throw new Error(`The file at '${filePath}' does not exist`);\n  }\n  const {\n    size\n  } = await _fs2.default.stat(filePath);\n  if (size < 4) {\n    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);\n  }\n  const fd = await _fs2.default.open(filePath, 'r');\n  try {\n    const buffer = Buffer.alloc(ZIP_MAGIC.length);\n    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);\n    const signature = buffer.toString('ascii');\n    if (signature !== ZIP_MAGIC) {\n      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);\n    }\n    return true;\n  } finally {\n    await _fs2.default.close(fd);\n  }\n}\nasync function toArchive(dstPath) {\n  let src = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    level = 9\n  } = opts;\n  const {\n    pattern = '**/*',\n    cwd = _path.default.dirname(dstPath),\n    ignore = []\n  } = src;\n  const archive = (0, _archiver.default)('zip', {\n    zlib: {\n      level\n    }\n  });\n  const stream = _fs2.default.createWriteStream(dstPath);\n  return await new _bluebird.default((resolve, reject) => {\n    archive.glob(pattern, {\n      cwd,\n      ignore\n    }).on('error', reject).pipe(stream);\n    stream.on('error', e => {\n      archive.unpipe(stream);\n      archive.abort();\n      archive.destroy();\n      reject(e);\n    }).on('finish', resolve);\n    archive.finalize();\n  });\n}\nconst getExecutablePath = _lodash.default.memoize(async function getExecutablePath(binaryName) {\n  const fullPath = await _fs2.default.which(binaryName);\n  _logger.default.debug(`Found '%s' at '%s'`, binaryName, fullPath);\n  return fullPath;\n});\nvar _default = {\n  extractAllTo,\n  readEntries,\n  toInMemoryZip,\n  assertValidZip,\n  toArchive\n};\nexports.default = _default;\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["openZip","B","promisify","yauzl","open","pipeline","stream","ZIP_MAGIC","IFMT","IFDIR","IFLNK","ZipExtractor","constructor","sourcePath","opts","zipPath","canceled","extractFileName","entry","_","isBuffer","fileName","toString","fileNamesEncoding","extract","dir","zipfile","lazyEntries","decodeStrings","resolve","reject","on","err","readEntry","startsWith","destDir","path","dirname","join","fs","mkdir","recursive","canonicalDestDir","realpath","relativeDestDir","relative","split","sep","includes","Error","extractEntry","close","dest","mode","externalFileAttributes","isSymlink","isDir","endsWith","versionMadeBy","procMode","getExtractedMode","mkdirOptions","readStream","openReadStream","bind","link","symlink","createWriteStream","entryMode","defaultDirMode","defaultFileMode","parseInt","extractAllTo","zipFilePath","isAbsolute","useSystemUnzip","extractWithSystemUnzip","log","warn","stderr","message","extractor","isWindowsHost","executablePath","getExecutablePath","e","_extractEntryTo","zipFile","dstPath","test","exists","writeStream","flags","writeStreamPromise","once","zipReadStream","zipReadStreamPromise","pipe","all","readEntries","onEntry","res","extractEntryTo","emit","toInMemoryZip","srcPath","isMetered","encodeToBase64","maxSize","GiB","level","resultBuffers","resultBuffersSize","resultWriteStream","Writable","write","buffer","encoding","next","push","length","archive","zlib","srcSize","base64EncoderStream","Base64Encode","resultWriteStreamPromise","unpipe","abort","destroy","pointer","archiveStreamPromise","timer","Timer","start","stat","isDirectory","directory","file","name","basename","finalize","debug","getDuration","asSeconds","toFixed","Buffer","concat","assertValidZip","filePath","size","fd","alloc","read","signature","toArchive","src","pattern","cwd","ignore","glob","memoize","binaryName","fullPath","which"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\zip.js"],"sourcesContent":["import _ from 'lodash';\nimport B from 'bluebird';\nimport yauzl from 'yauzl';\nimport archiver from 'archiver';\nimport { createWriteStream } from 'fs';\nimport path from 'path';\nimport { mkdirp } from '../lib/mkdirp';\nimport stream from 'stream';\nimport fs from './fs';\nimport { isWindows } from './system';\nimport { Base64Encode } from 'base64-stream';\nimport { toReadableSizeString, GiB } from './util';\nimport Timer from './timing';\nimport log from './logger';\nimport getStream from 'get-stream';\nimport { exec } from 'teen_process';\n\nconst openZip = B.promisify(yauzl.open);\nconst pipeline = B.promisify(stream.pipeline);\nconst ZIP_MAGIC = 'PK';\nconst IFMT = 61440;\nconst IFDIR = 16384;\nconst IFLNK = 40960;\n\n// This class is mostly copied from https://github.com/maxogden/extract-zip/blob/master/index.js\nclass ZipExtractor {\n  constructor (sourcePath, opts = {}) {\n    this.zipPath = sourcePath;\n    this.opts = opts;\n    this.canceled = false;\n  }\n\n  extractFileName (entry) {\n    return _.isBuffer(entry.fileName) ? entry.fileName.toString(this.opts.fileNamesEncoding) : entry.fileName;\n  }\n\n  async extract () {\n    const {\n      dir,\n      fileNamesEncoding,\n    } = this.opts;\n    this.zipfile = await openZip(this.zipPath, {\n      lazyEntries: true,\n      // https://github.com/thejoshwolfe/yauzl/commit/cc7455ac789ba84973184e5ebde0581cdc4c3b39#diff-04c6e90faac2675aa89e2176d2eec7d8R95\n      decodeStrings: !fileNamesEncoding,\n    });\n    this.canceled = false;\n\n    return new B((resolve, reject) => {\n      this.zipfile.on('error', (err) => {\n        this.canceled = true;\n        reject(err);\n      });\n      this.zipfile.readEntry();\n\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          resolve();\n        }\n      });\n\n      this.zipfile.on('entry', async (entry) => {\n        if (this.canceled) {\n          return;\n        }\n\n        const fileName = this.extractFileName(entry);\n        if (fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry();\n          return;\n        }\n\n        const destDir = path.dirname(path.join(dir, fileName));\n        try {\n          await fs.mkdir(destDir, {recursive: true});\n\n          const canonicalDestDir = await fs.realpath(destDir);\n          const relativeDestDir = path.relative(dir, canonicalDestDir);\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${fileName}`);\n          }\n\n          await this.extractEntry(entry);\n          this.zipfile.readEntry();\n        } catch (err) {\n          this.canceled = true;\n          this.zipfile.close();\n          reject(err);\n        }\n      });\n    });\n  }\n\n  async extractEntry (entry) {\n    if (this.canceled) {\n      return;\n    }\n\n    const {\n      dir,\n    } = this.opts;\n\n    const fileName = this.extractFileName(entry);\n    const dest = path.join(dir, fileName);\n\n    // convert external file attr int into a fs stat mode int\n    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF;\n    // check if it's a symlink or dir (using stat mode constants)\n    const isSymlink = (mode & IFMT) === IFLNK;\n    const isDir = (mode & IFMT) === IFDIR\n      // Failsafe, borrowed from jsZip\n      || fileName.endsWith('/')\n      // check for windows weird way of specifying a directory\n      // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n      || (entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16);\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777;\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest);\n    const mkdirOptions = { recursive: true };\n    if (isDir) {\n      mkdirOptions.mode = procMode;\n    }\n    await fs.mkdir(destDir, mkdirOptions);\n    if (isDir) {\n      return;\n    }\n\n    const readStream = await B.promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);\n    if (isSymlink) {\n      const link = await getStream(readStream);\n      await fs.symlink(link, dest);\n    } else {\n      await pipeline(readStream, fs.createWriteStream(dest, { mode: procMode }));\n    }\n  }\n\n  getExtractedMode (entryMode, isDir) {\n    const {\n      defaultDirMode,\n      defaultFileMode,\n    } = this.opts;\n\n    let mode = entryMode;\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (defaultDirMode) {\n          mode = parseInt(defaultDirMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o755;\n        }\n      } else {\n        if (defaultFileMode) {\n          mode = parseInt(defaultFileMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o644;\n        }\n      }\n    }\n\n    return mode;\n  }\n}\n\n\n/**\n * @typedef {Object} ExtractAllOptions\n * @property {?string} fileNamesEncoding The encoding to use for extracted file names.\n * For ZIP archives created on MacOS it is usually expected to be `utf8`.\n * By default it is autodetected based on the entry metadata and is only needed to be set explicitly\n * if the particular archive does not comply to the standards, which leads to corrupted file names\n * after extraction. Only applicable if system unzip binary is NOT being used.\n * @property {?boolean} useSystemUnzip [false] If true, attempt to use system unzip; if this fails,\n * fallback to the JS unzip implementation.\n */\n\n/**\n * Extract zipfile to a directory\n *\n * @param {string} zipFilePath The full path to the source ZIP file\n * @param {string} destDir The full path to the destination folder\n * @param {?ExtractAllOptions} opts\n */\nasync function extractAllTo (zipFilePath, destDir, opts = {}) {\n  if (!path.isAbsolute(destDir)) {\n    throw new Error(`Target path '${destDir}' is expected to be absolute`);\n  }\n\n  await fs.mkdir(destDir, {recursive: true});\n  const dir = await fs.realpath(destDir);\n  if (opts.useSystemUnzip) {\n    try {\n      await extractWithSystemUnzip(zipFilePath, dir);\n      return;\n    } catch (err) {\n      log.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);\n    }\n  }\n  const extractor = new ZipExtractor(zipFilePath, {\n    ...opts,\n    dir,\n  });\n  await extractor.extract();\n}\n\n/**\n * Executes system unzip (e.g., `/usr/bin/unzip`). If available, it is\n * significantly faster than the JS implementation.\n * By default all files in the destDir get overridden if already exist.\n *\n * @param {string} zipFilePath The full path to the source ZIP file\n * @param {string} destDir The full path to the destination folder.\n * This folder is expected to already exist before extracting the archive.\n */\nasync function extractWithSystemUnzip (zipFilePath, destDir) {\n  const isWindowsHost = isWindows();\n  let executablePath;\n  try {\n    executablePath = await getExecutablePath(\n      isWindowsHost ? 'powershell.exe' : 'unzip'\n    );\n  } catch (e) {\n    throw new Error('Could not find system unzip');\n  }\n\n  if (isWindowsHost) {\n    // on Windows we use PowerShell to unzip files\n    await exec(executablePath, [\n      '-command', 'Expand-Archive',\n      '-LiteralPath', zipFilePath,\n      '-DestinationPath', destDir,\n      '-Force'\n    ]);\n  } else {\n    // -q means quiet (no stdout)\n    // -o means overwrite\n    // -d is the dest dir\n    await exec(executablePath, [\n      '-q',\n      '-o', zipFilePath,\n      '-d', destDir\n    ]);\n  }\n}\n\n/**\n * Extract a single zip entry to a directory\n *\n * @param {Streamable} zipFile The source ZIP stream\n * @param {yauzl.ZipEntry} entry The entry instance\n * @param {string} destDir The full path to the destination folder\n */\nasync function _extractEntryTo (zipFile, entry, destDir) {\n  const dstPath = path.resolve(destDir, entry.fileName);\n\n  // Create dest directory if doesn't exist already\n  if (/\\/$/.test(entry.fileName)) {\n    if (!await fs.exists(dstPath)) {\n      await mkdirp(dstPath);\n    }\n    return;\n  } else if (!await fs.exists(path.dirname(dstPath))) {\n    await mkdirp(path.dirname(dstPath));\n  }\n\n  // Create a write stream\n  const writeStream = createWriteStream(dstPath, {flags: 'w'});\n  const writeStreamPromise = new B((resolve, reject) => {\n    writeStream.once('finish', resolve);\n    writeStream.once('error', reject);\n  });\n\n  // Create zipReadStream and pipe data to the write stream\n  // (for some odd reason B.promisify doesn't work on zipfile.openReadStream, it causes an error 'closed')\n  const zipReadStream = await new B((resolve, reject) => {\n    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));\n  });\n  const zipReadStreamPromise = new B((resolve, reject) => {\n    zipReadStream.once('end', resolve);\n    zipReadStream.once('error', reject);\n  });\n  zipReadStream.pipe(writeStream);\n\n  // Wait for the zipReadStream and writeStream to end before returning\n  return await B.all([\n    zipReadStreamPromise,\n    writeStreamPromise,\n  ]);\n}\n\n/**\n * @typedef {Object} ZipEntry\n * @property {yauzl.ZipEntry} entry The actual entry instance\n * @property {function} extractEntryTo An async function, which accepts one parameter.\n * This parameter contains the destination folder path to which this function is going to extract the entry.\n */\n\n/**\n * Get entries for a zip folder\n *\n * @param {string} zipFilePath The full path to the source ZIP file\n * @param {function} onEntry Callback when entry is read.\n * The callback is expected to accept one argument of ZipEntry type.\n * The iteration through the source zip file will bi terminated as soon as\n * the result of this function equals to `false`.\n */\nasync function readEntries (zipFilePath, onEntry) {\n  // Open a zip file and start reading entries\n  const zipfile = await openZip(zipFilePath, {lazyEntries: true});\n  const zipReadStreamPromise = new B((resolve, reject) => {\n    zipfile.once('end', resolve);\n    zipfile.once('error', reject);\n\n    // On each entry, call 'onEntry' and then read the next entry\n    zipfile.on('entry', async (entry) => {\n      const res = await onEntry({\n        entry,\n        extractEntryTo: async (destDir) => await _extractEntryTo(zipfile, entry, destDir)\n      });\n      if (res === false) {\n        return zipfile.emit('end');\n      }\n      zipfile.readEntry();\n    });\n  });\n  zipfile.readEntry();\n\n  // Wait for the entries to finish being iterated through\n  return await zipReadStreamPromise;\n}\n\n/**\n * @typedef {Object} ZipOptions\n * @property {boolean} encodeToBase64 [false] Whether to encode\n * the resulting archive to a base64-encoded string\n * @property {boolean} isMetered [true] Whether to log the actual\n * archiver performance\n * @property {number} maxSize [1073741824] The maximum size of\n * the resulting archive in bytes. This is set to 1GB by default, because\n * Appium limits the maximum HTTP body size to 1GB. Also, the NodeJS heap\n * size must be enough to keep the resulting object (usually this size is\n * limited to 1.4 GB)\n * @property {number} level [9] The compression level. The maximum\n * level is 9 (the best compression, worst performance). The minimum\n * compression level is 0 (no compression).\n */\n\n/**\n * Converts contents of local directory to an in-memory .zip buffer\n *\n * @param {string} srcPath The full path to the folder or file being zipped\n * @param {ZipOptions} opts Zipping options\n * @returns {Buffer} Zipped (and encoded if `encodeToBase64` is truthy)\n * content of the source path as memory buffer\n * @throws {Error} if there was an error while reading the source\n * or the source is too big\n */\nasync function toInMemoryZip (srcPath, opts = {}) {\n  if (!await fs.exists(srcPath)) {\n    throw new Error(`No such file or folder: ${srcPath}`);\n  }\n\n  const {\n    isMetered = true,\n    encodeToBase64 = false,\n    maxSize = 1 * GiB,\n    level = 9,\n  } = opts;\n  const resultBuffers = [];\n  let resultBuffersSize = 0;\n  // Create a writable stream that zip buffers will be streamed to\n  const resultWriteStream = new stream.Writable({\n    write: (buffer, encoding, next) => {\n      resultBuffers.push(buffer);\n      resultBuffersSize += buffer.length;\n      if (maxSize > 0 && resultBuffersSize > maxSize) {\n        resultWriteStream.emit('error', new Error(`The size of the resulting ` +\n          `archive must not be greater than ${toReadableSizeString(maxSize)}`));\n      }\n      next();\n    },\n  });\n\n  // Zip 'srcDir' and stream it to the above writable stream\n  const archive = archiver('zip', {\n    zlib: {level}\n  });\n  let srcSize = null;\n  const base64EncoderStream = encodeToBase64 ? new Base64Encode() : null;\n  const resultWriteStreamPromise = new B((resolve, reject) => {\n    resultWriteStream.once('error', (e) => {\n      if (base64EncoderStream) {\n        archive.unpipe(base64EncoderStream);\n        base64EncoderStream.unpipe(resultWriteStream);\n      } else {\n        archive.unpipe(resultWriteStream);\n      }\n      archive.abort();\n      archive.destroy();\n      reject(e);\n    });\n    resultWriteStream.once('finish', () => {\n      srcSize = archive.pointer();\n      resolve();\n    });\n  });\n  const archiveStreamPromise = new B((resolve, reject) => {\n    archive.once('finish', resolve);\n    archive.once('error', (e) => reject(\n      new Error(`Failed to archive '${srcPath}': ${e.message}`)));\n  });\n  const timer = isMetered ? new Timer().start() : null;\n  if ((await fs.stat(srcPath)).isDirectory()) {\n    archive.directory(srcPath, false);\n  } else {\n    archive.file(srcPath, {\n      name: path.basename(srcPath),\n    });\n  }\n  if (base64EncoderStream) {\n    archive.pipe(base64EncoderStream);\n    base64EncoderStream.pipe(resultWriteStream);\n  } else {\n    archive.pipe(resultWriteStream);\n  }\n  archive.finalize();\n\n  // Wait for the streams to finish\n  await B.all([archiveStreamPromise, resultWriteStreamPromise]);\n\n  if (timer) {\n    log.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` +\n      `'${path.basename(srcPath)}' ` +\n      (srcSize ? `(${toReadableSizeString(srcSize)}) ` : '') +\n      `in ${timer.getDuration().asSeconds.toFixed(3)}s ` +\n      `(compression level: ${level})`);\n  }\n  // Return the array of zip buffers concatenated into one buffer\n  return Buffer.concat(resultBuffers);\n}\n\n/**\n * Verifies whether the given file is a valid ZIP archive\n *\n * @param {string} filePath - Full path to the file\n * @throws {Error} If the file does not exist or is not a valid ZIP archive\n */\nasync function assertValidZip (filePath) {\n  if (!await fs.exists(filePath)) {\n    throw new Error(`The file at '${filePath}' does not exist`);\n  }\n\n  const {size} = await fs.stat(filePath);\n  if (size < 4) {\n    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);\n  }\n  const fd = await fs.open(filePath, 'r');\n  try {\n    const buffer = Buffer.alloc(ZIP_MAGIC.length);\n    await fs.read(fd, buffer, 0, ZIP_MAGIC.length, 0);\n    const signature = buffer.toString('ascii');\n    if (signature !== ZIP_MAGIC) {\n      throw new Error(`The file signature '${signature}' of '${filePath}' ` +\n        `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);\n    }\n    return true;\n  } finally {\n    await fs.close(fd);\n  }\n}\n\n/**\n * @typedef {Object} ZipCompressionOptions\n * @property {number} level [9] - Compression level in range 0..9\n * (greater numbers mean better compression, but longer processing time)\n */\n\n/**\n * @typedef {Object} ZipSourceOptions\n * @property {!string} pattern ['**\\/*'] - GLOB pattern for compression\n * @property {!string} cwd - The source root folder (the parent folder of\n * the destination file by default)\n * @property {?Array<string>} ignore - The list of ignored patterns\n */\n\n/**\n * Creates an archive based on the given glob pattern\n *\n * @param {string} dstPath - The resulting archive path\n * @param {ZipSourceOptions} src - Source options\n * @param {ZipCompressionOptions} opts - Compression options\n * @throws {Error} If there was an error while creating the archive\n */\nasync function toArchive (dstPath, src = {}, opts = {}) {\n  const {\n    level = 9,\n  } = opts;\n  const {\n    pattern = '**/*',\n    cwd = path.dirname(dstPath),\n    ignore = [],\n  } = src;\n  const archive = archiver('zip', { zlib: { level }});\n  const stream = fs.createWriteStream(dstPath);\n  return await new B((resolve, reject) => {\n    archive\n      .glob(pattern, {\n        cwd,\n        ignore,\n      })\n      .on('error', reject)\n      .pipe(stream);\n    stream\n      .on('error', (e) => {\n        archive.unpipe(stream);\n        archive.abort();\n        archive.destroy();\n        reject(e);\n      })\n      .on('finish', resolve);\n    archive.finalize();\n  });\n}\n\n/**\n * Finds and memoizes the full path to the given executable.\n * Rejects if it is not found.\n */\nconst getExecutablePath = _.memoize(\n  /**\n   * @returns {B<string>} Full Path to the executable\n   */\n  async function getExecutablePath (binaryName) {\n    const fullPath = await fs.which(binaryName);\n    log.debug(`Found '%s' at '%s'`, binaryName, fullPath);\n    return fullPath;\n  }\n);\n\nexport { extractAllTo, readEntries, toInMemoryZip, _extractEntryTo,\n  assertValidZip, toArchive };\nexport default { extractAllTo, readEntries, toInMemoryZip, assertValidZip, toArchive };\n"]},"metadata":{},"sourceType":"script"}