{"ast":null,"code":"\"use strict\";\n\nlet util = require(\"util\");\nlet Stream = require(\"stream\");\nlet ChunkStream = module.exports = function () {\n  Stream.call(this);\n  this._buffers = [];\n  this._buffered = 0;\n  this._reads = [];\n  this._paused = false;\n  this._encoding = \"utf8\";\n  this.writable = true;\n};\nutil.inherits(ChunkStream, Stream);\nChunkStream.prototype.read = function (length, callback) {\n  this._reads.push({\n    length: Math.abs(length),\n    // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n  process.nextTick(function () {\n    this._process();\n\n    // its paused and there is not enought data then ask for more\n    if (this._paused && this._reads && this._reads.length > 0) {\n      this._paused = false;\n      this.emit(\"drain\");\n    }\n  }.bind(this));\n};\nChunkStream.prototype.write = function (data, encoding) {\n  if (!this.writable) {\n    this.emit(\"error\", new Error(\"Stream not writable\"));\n    return false;\n  }\n  let dataBuffer;\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  } else {\n    dataBuffer = Buffer.from(data, encoding || this._encoding);\n  }\n  this._buffers.push(dataBuffer);\n  this._buffered += dataBuffer.length;\n  this._process();\n\n  // ok if there are no more read requests\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n  return this.writable && !this._paused;\n};\nChunkStream.prototype.end = function (data, encoding) {\n  if (data) {\n    this.write(data, encoding);\n  }\n  this.writable = false;\n\n  // already destroyed\n  if (!this._buffers) {\n    return;\n  }\n\n  // enqueue or handle end\n  if (this._buffers.length === 0) {\n    this._end();\n  } else {\n    this._buffers.push(null);\n    this._process();\n  }\n};\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\nChunkStream.prototype._end = function () {\n  if (this._reads.length > 0) {\n    this.emit(\"error\", new Error(\"Unexpected end of input\"));\n  }\n  this.destroy();\n};\nChunkStream.prototype.destroy = function () {\n  if (!this._buffers) {\n    return;\n  }\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n  this.emit(\"close\");\n};\nChunkStream.prototype._processReadAllowingLess = function (read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n\n  // first we need to peek into first buffer\n  let smallerBuf = this._buffers[0];\n\n  // ok there is more data than we need\n  if (smallerBuf.length > read.length) {\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n    read.func.call(this, smallerBuf.slice(0, read.length));\n  } else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n    this._buffers.shift(); // == smallerBuf\n\n    read.func.call(this, smallerBuf);\n  }\n};\nChunkStream.prototype._processRead = function (read) {\n  this._reads.shift(); // == read\n\n  let pos = 0;\n  let count = 0;\n  let data = Buffer.alloc(read.length);\n\n  // create buffer for all data\n  while (pos < read.length) {\n    let buf = this._buffers[count++];\n    let len = Math.min(buf.length, read.length - pos);\n    buf.copy(data, pos, 0, len);\n    pos += len;\n\n    // last buffer wasn't used all so just slice it and leave\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  }\n\n  // remove all used buffers\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n  this._buffered -= read.length;\n  read.func.call(this, data);\n};\nChunkStream.prototype._process = function () {\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n      let read = this._reads[0];\n\n      // read any data (but no more than length)\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n      } else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n\n        this._processRead(read);\n      } else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n    if (this._buffers && !this.writable) {\n      this._end();\n    }\n  } catch (ex) {\n    this.emit(\"error\", ex);\n  }\n};","map":{"version":3,"names":["util","require","Stream","ChunkStream","module","exports","call","_buffers","_buffered","_reads","_paused","_encoding","writable","inherits","prototype","read","length","callback","push","Math","abs","allowLess","func","process","nextTick","_process","emit","bind","write","data","encoding","Error","dataBuffer","Buffer","isBuffer","from","end","_end","destroySoon","destroy","_processReadAllowingLess","shift","smallerBuf","slice","_processRead","pos","count","alloc","buf","len","min","copy","splice","ex"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/pngjs/lib/chunkstream.js"],"sourcesContent":["\"use strict\";\n\nlet util = require(\"util\");\nlet Stream = require(\"stream\");\n\nlet ChunkStream = (module.exports = function () {\n  Stream.call(this);\n\n  this._buffers = [];\n  this._buffered = 0;\n\n  this._reads = [];\n  this._paused = false;\n\n  this._encoding = \"utf8\";\n  this.writable = true;\n});\nutil.inherits(ChunkStream, Stream);\n\nChunkStream.prototype.read = function (length, callback) {\n  this._reads.push({\n    length: Math.abs(length), // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback,\n  });\n\n  process.nextTick(\n    function () {\n      this._process();\n\n      // its paused and there is not enought data then ask for more\n      if (this._paused && this._reads && this._reads.length > 0) {\n        this._paused = false;\n\n        this.emit(\"drain\");\n      }\n    }.bind(this)\n  );\n};\n\nChunkStream.prototype.write = function (data, encoding) {\n  if (!this.writable) {\n    this.emit(\"error\", new Error(\"Stream not writable\"));\n    return false;\n  }\n\n  let dataBuffer;\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  } else {\n    dataBuffer = Buffer.from(data, encoding || this._encoding);\n  }\n\n  this._buffers.push(dataBuffer);\n  this._buffered += dataBuffer.length;\n\n  this._process();\n\n  // ok if there are no more read requests\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n\n  return this.writable && !this._paused;\n};\n\nChunkStream.prototype.end = function (data, encoding) {\n  if (data) {\n    this.write(data, encoding);\n  }\n\n  this.writable = false;\n\n  // already destroyed\n  if (!this._buffers) {\n    return;\n  }\n\n  // enqueue or handle end\n  if (this._buffers.length === 0) {\n    this._end();\n  } else {\n    this._buffers.push(null);\n    this._process();\n  }\n};\n\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\n\nChunkStream.prototype._end = function () {\n  if (this._reads.length > 0) {\n    this.emit(\"error\", new Error(\"Unexpected end of input\"));\n  }\n\n  this.destroy();\n};\n\nChunkStream.prototype.destroy = function () {\n  if (!this._buffers) {\n    return;\n  }\n\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n\n  this.emit(\"close\");\n};\n\nChunkStream.prototype._processReadAllowingLess = function (read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n\n  // first we need to peek into first buffer\n  let smallerBuf = this._buffers[0];\n\n  // ok there is more data than we need\n  if (smallerBuf.length > read.length) {\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n\n    read.func.call(this, smallerBuf.slice(0, read.length));\n  } else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n    this._buffers.shift(); // == smallerBuf\n\n    read.func.call(this, smallerBuf);\n  }\n};\n\nChunkStream.prototype._processRead = function (read) {\n  this._reads.shift(); // == read\n\n  let pos = 0;\n  let count = 0;\n  let data = Buffer.alloc(read.length);\n\n  // create buffer for all data\n  while (pos < read.length) {\n    let buf = this._buffers[count++];\n    let len = Math.min(buf.length, read.length - pos);\n\n    buf.copy(data, pos, 0, len);\n    pos += len;\n\n    // last buffer wasn't used all so just slice it and leave\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  }\n\n  // remove all used buffers\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n\n  this._buffered -= read.length;\n\n  read.func.call(this, data);\n};\n\nChunkStream.prototype._process = function () {\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n      let read = this._reads[0];\n\n      // read any data (but no more than length)\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n      } else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n\n        this._processRead(read);\n      } else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n\n    if (this._buffers && !this.writable) {\n      this._end();\n    }\n  } catch (ex) {\n    this.emit(\"error\", ex);\n  }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAE9B,IAAIE,WAAW,GAAIC,MAAM,CAACC,OAAO,GAAG,YAAY;EAC9CH,MAAM,CAACI,IAAI,CAAC,IAAI,CAAC;EAEjB,IAAI,CAACC,QAAQ,GAAG,EAAE;EAClB,IAAI,CAACC,SAAS,GAAG,CAAC;EAElB,IAAI,CAACC,MAAM,GAAG,EAAE;EAChB,IAAI,CAACC,OAAO,GAAG,KAAK;EAEpB,IAAI,CAACC,SAAS,GAAG,MAAM;EACvB,IAAI,CAACC,QAAQ,GAAG,IAAI;AACtB,CAAE;AACFZ,IAAI,CAACa,QAAQ,CAACV,WAAW,EAAED,MAAM,CAAC;AAElCC,WAAW,CAACW,SAAS,CAACC,IAAI,GAAG,UAAUC,MAAM,EAAEC,QAAQ,EAAE;EACvD,IAAI,CAACR,MAAM,CAACS,IAAI,CAAC;IACfF,MAAM,EAAEG,IAAI,CAACC,GAAG,CAACJ,MAAM,CAAC;IAAE;IAC1BK,SAAS,EAAEL,MAAM,GAAG,CAAC;IACrBM,IAAI,EAAEL;EACR,CAAC,CAAC;EAEFM,OAAO,CAACC,QAAQ,CACd,YAAY;IACV,IAAI,CAACC,QAAQ,EAAE;;IAEf;IACA,IAAI,IAAI,CAACf,OAAO,IAAI,IAAI,CAACD,MAAM,IAAI,IAAI,CAACA,MAAM,CAACO,MAAM,GAAG,CAAC,EAAE;MACzD,IAAI,CAACN,OAAO,GAAG,KAAK;MAEpB,IAAI,CAACgB,IAAI,CAAC,OAAO,CAAC;IACpB;EACF,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CACb;AACH,CAAC;AAEDxB,WAAW,CAACW,SAAS,CAACc,KAAK,GAAG,UAAUC,IAAI,EAAEC,QAAQ,EAAE;EACtD,IAAI,CAAC,IAAI,CAAClB,QAAQ,EAAE;IAClB,IAAI,CAACc,IAAI,CAAC,OAAO,EAAE,IAAIK,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACpD,OAAO,KAAK;EACd;EAEA,IAAIC,UAAU;EACd,IAAIC,MAAM,CAACC,QAAQ,CAACL,IAAI,CAAC,EAAE;IACzBG,UAAU,GAAGH,IAAI;EACnB,CAAC,MAAM;IACLG,UAAU,GAAGC,MAAM,CAACE,IAAI,CAACN,IAAI,EAAEC,QAAQ,IAAI,IAAI,CAACnB,SAAS,CAAC;EAC5D;EAEA,IAAI,CAACJ,QAAQ,CAACW,IAAI,CAACc,UAAU,CAAC;EAC9B,IAAI,CAACxB,SAAS,IAAIwB,UAAU,CAAChB,MAAM;EAEnC,IAAI,CAACS,QAAQ,EAAE;;EAEf;EACA,IAAI,IAAI,CAAChB,MAAM,IAAI,IAAI,CAACA,MAAM,CAACO,MAAM,KAAK,CAAC,EAAE;IAC3C,IAAI,CAACN,OAAO,GAAG,IAAI;EACrB;EAEA,OAAO,IAAI,CAACE,QAAQ,IAAI,CAAC,IAAI,CAACF,OAAO;AACvC,CAAC;AAEDP,WAAW,CAACW,SAAS,CAACsB,GAAG,GAAG,UAAUP,IAAI,EAAEC,QAAQ,EAAE;EACpD,IAAID,IAAI,EAAE;IACR,IAAI,CAACD,KAAK,CAACC,IAAI,EAAEC,QAAQ,CAAC;EAC5B;EAEA,IAAI,CAAClB,QAAQ,GAAG,KAAK;;EAErB;EACA,IAAI,CAAC,IAAI,CAACL,QAAQ,EAAE;IAClB;EACF;;EAEA;EACA,IAAI,IAAI,CAACA,QAAQ,CAACS,MAAM,KAAK,CAAC,EAAE;IAC9B,IAAI,CAACqB,IAAI,EAAE;EACb,CAAC,MAAM;IACL,IAAI,CAAC9B,QAAQ,CAACW,IAAI,CAAC,IAAI,CAAC;IACxB,IAAI,CAACO,QAAQ,EAAE;EACjB;AACF,CAAC;AAEDtB,WAAW,CAACW,SAAS,CAACwB,WAAW,GAAGnC,WAAW,CAACW,SAAS,CAACsB,GAAG;AAE7DjC,WAAW,CAACW,SAAS,CAACuB,IAAI,GAAG,YAAY;EACvC,IAAI,IAAI,CAAC5B,MAAM,CAACO,MAAM,GAAG,CAAC,EAAE;IAC1B,IAAI,CAACU,IAAI,CAAC,OAAO,EAAE,IAAIK,KAAK,CAAC,yBAAyB,CAAC,CAAC;EAC1D;EAEA,IAAI,CAACQ,OAAO,EAAE;AAChB,CAAC;AAEDpC,WAAW,CAACW,SAAS,CAACyB,OAAO,GAAG,YAAY;EAC1C,IAAI,CAAC,IAAI,CAAChC,QAAQ,EAAE;IAClB;EACF;EAEA,IAAI,CAACK,QAAQ,GAAG,KAAK;EACrB,IAAI,CAACH,MAAM,GAAG,IAAI;EAClB,IAAI,CAACF,QAAQ,GAAG,IAAI;EAEpB,IAAI,CAACmB,IAAI,CAAC,OAAO,CAAC;AACpB,CAAC;AAEDvB,WAAW,CAACW,SAAS,CAAC0B,wBAAwB,GAAG,UAAUzB,IAAI,EAAE;EAC/D;EACA,IAAI,CAACN,MAAM,CAACgC,KAAK,EAAE,CAAC,CAAC;;EAErB;EACA,IAAIC,UAAU,GAAG,IAAI,CAACnC,QAAQ,CAAC,CAAC,CAAC;;EAEjC;EACA,IAAImC,UAAU,CAAC1B,MAAM,GAAGD,IAAI,CAACC,MAAM,EAAE;IACnC,IAAI,CAACR,SAAS,IAAIO,IAAI,CAACC,MAAM;IAC7B,IAAI,CAACT,QAAQ,CAAC,CAAC,CAAC,GAAGmC,UAAU,CAACC,KAAK,CAAC5B,IAAI,CAACC,MAAM,CAAC;IAEhDD,IAAI,CAACO,IAAI,CAAChB,IAAI,CAAC,IAAI,EAAEoC,UAAU,CAACC,KAAK,CAAC,CAAC,EAAE5B,IAAI,CAACC,MAAM,CAAC,CAAC;EACxD,CAAC,MAAM;IACL;IACA,IAAI,CAACR,SAAS,IAAIkC,UAAU,CAAC1B,MAAM;IACnC,IAAI,CAACT,QAAQ,CAACkC,KAAK,EAAE,CAAC,CAAC;;IAEvB1B,IAAI,CAACO,IAAI,CAAChB,IAAI,CAAC,IAAI,EAAEoC,UAAU,CAAC;EAClC;AACF,CAAC;AAEDvC,WAAW,CAACW,SAAS,CAAC8B,YAAY,GAAG,UAAU7B,IAAI,EAAE;EACnD,IAAI,CAACN,MAAM,CAACgC,KAAK,EAAE,CAAC,CAAC;;EAErB,IAAII,GAAG,GAAG,CAAC;EACX,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIjB,IAAI,GAAGI,MAAM,CAACc,KAAK,CAAChC,IAAI,CAACC,MAAM,CAAC;;EAEpC;EACA,OAAO6B,GAAG,GAAG9B,IAAI,CAACC,MAAM,EAAE;IACxB,IAAIgC,GAAG,GAAG,IAAI,CAACzC,QAAQ,CAACuC,KAAK,EAAE,CAAC;IAChC,IAAIG,GAAG,GAAG9B,IAAI,CAAC+B,GAAG,CAACF,GAAG,CAAChC,MAAM,EAAED,IAAI,CAACC,MAAM,GAAG6B,GAAG,CAAC;IAEjDG,GAAG,CAACG,IAAI,CAACtB,IAAI,EAAEgB,GAAG,EAAE,CAAC,EAAEI,GAAG,CAAC;IAC3BJ,GAAG,IAAII,GAAG;;IAEV;IACA,IAAIA,GAAG,KAAKD,GAAG,CAAChC,MAAM,EAAE;MACtB,IAAI,CAACT,QAAQ,CAAC,EAAEuC,KAAK,CAAC,GAAGE,GAAG,CAACL,KAAK,CAACM,GAAG,CAAC;IACzC;EACF;;EAEA;EACA,IAAIH,KAAK,GAAG,CAAC,EAAE;IACb,IAAI,CAACvC,QAAQ,CAAC6C,MAAM,CAAC,CAAC,EAAEN,KAAK,CAAC;EAChC;EAEA,IAAI,CAACtC,SAAS,IAAIO,IAAI,CAACC,MAAM;EAE7BD,IAAI,CAACO,IAAI,CAAChB,IAAI,CAAC,IAAI,EAAEuB,IAAI,CAAC;AAC5B,CAAC;AAED1B,WAAW,CAACW,SAAS,CAACW,QAAQ,GAAG,YAAY;EAC3C,IAAI;IACF;IACA,OAAO,IAAI,CAACjB,SAAS,GAAG,CAAC,IAAI,IAAI,CAACC,MAAM,IAAI,IAAI,CAACA,MAAM,CAACO,MAAM,GAAG,CAAC,EAAE;MAClE,IAAID,IAAI,GAAG,IAAI,CAACN,MAAM,CAAC,CAAC,CAAC;;MAEzB;MACA,IAAIM,IAAI,CAACM,SAAS,EAAE;QAClB,IAAI,CAACmB,wBAAwB,CAACzB,IAAI,CAAC;MACrC,CAAC,MAAM,IAAI,IAAI,CAACP,SAAS,IAAIO,IAAI,CAACC,MAAM,EAAE;QACxC;;QAEA,IAAI,CAAC4B,YAAY,CAAC7B,IAAI,CAAC;MACzB,CAAC,MAAM;QACL;QACA;QACA;MACF;IACF;IAEA,IAAI,IAAI,CAACR,QAAQ,IAAI,CAAC,IAAI,CAACK,QAAQ,EAAE;MACnC,IAAI,CAACyB,IAAI,EAAE;IACb;EACF,CAAC,CAAC,OAAOgB,EAAE,EAAE;IACX,IAAI,CAAC3B,IAAI,CAAC,OAAO,EAAE2B,EAAE,CAAC;EACxB;AACF,CAAC"},"metadata":{},"sourceType":"script"}