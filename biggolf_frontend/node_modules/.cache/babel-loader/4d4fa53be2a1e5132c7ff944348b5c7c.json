{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SecureValuesPreprocessor = exports.SECURE_VALUES_PREPROCESSOR = void 0;\nrequire(\"source-map-support/register\");\nvar _fs = _interopRequireDefault(require(\"./fs\"));\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nconst DEFAULT_REPLACER = '**SECURE**';\nclass SecureValuesPreprocessor {\n  constructor() {\n    this._rules = [];\n  }\n  get rules() {\n    return this._rules;\n  }\n  parseRule(rule) {\n    const raiseError = msg => {\n      throw new Error(`${JSON.stringify(rule)} -> ${msg}`);\n    };\n    let pattern;\n    let replacer = DEFAULT_REPLACER;\n    let flags = ['g'];\n    if (_lodash.default.isString(rule)) {\n      if (rule.length === 0) {\n        raiseError('The value must not be empty');\n      }\n      pattern = `\\\\b${_lodash.default.escapeRegExp(rule)}\\\\b`;\n    } else if (_lodash.default.isPlainObject(rule)) {\n      if (_lodash.default.has(rule, 'pattern')) {\n        if (!_lodash.default.isString(rule.pattern) || rule.pattern.length === 0) {\n          raiseError(`The value of 'pattern' must be a valid non-empty string`);\n        }\n        pattern = rule.pattern;\n      } else if (_lodash.default.has(rule, 'text')) {\n        if (!_lodash.default.isString(rule.text) || rule.text.length === 0) {\n          raiseError(`The value of 'text' must be a valid non-empty string`);\n        }\n        pattern = `\\\\b${_lodash.default.escapeRegExp(rule.text)}\\\\b`;\n      }\n      if (!pattern) {\n        raiseError(`Must either have a field named 'pattern' or 'text'`);\n      }\n      if (_lodash.default.has(rule, 'flags')) {\n        for (const flag of ['i', 'g', 'm', 's', 'u', 'y']) {\n          if (_lodash.default.includes(rule.flags, flag)) {\n            flags.push(flag);\n          }\n        }\n        flags = _lodash.default.uniq(flags);\n      }\n      if (_lodash.default.isString(rule.replacer)) {\n        replacer = rule.replacer;\n      }\n    } else {\n      raiseError('Must either be a string or an object');\n    }\n    try {\n      return {\n        pattern: new RegExp(pattern, flags.join('')),\n        replacer\n      };\n    } catch (e) {\n      raiseError(e.message);\n    }\n  }\n  async loadRules(source) {\n    let rules;\n    if (_lodash.default.isArray(source)) {\n      rules = source;\n    } else {\n      if (!(await _fs.default.exists(source))) {\n        throw new Error(`'${source}' does not exist or is not accessible`);\n      }\n      try {\n        rules = JSON.parse(await _fs.default.readFile(source, 'utf8'));\n      } catch (e) {\n        throw new Error(`'${source}' must be a valid JSON file. Original error: ${e.message}`);\n      }\n      if (!_lodash.default.isArray(rules)) {\n        throw new Error(`'${source}' must contain a valid JSON array`);\n      }\n    }\n    const issues = [];\n    this._rules = [];\n    for (const rule of rules) {\n      try {\n        this._rules.push(this.parseRule(rule));\n      } catch (e) {\n        issues.push(e.message);\n      }\n    }\n    return issues;\n  }\n  preprocess(str) {\n    if (this._rules.length === 0 || !_lodash.default.isString(str)) {\n      return str;\n    }\n    let result = str;\n    for (const rule of this._rules) {\n      result = result.replace(rule.pattern, rule.replacer);\n    }\n    return result;\n  }\n}\nexports.SecureValuesPreprocessor = SecureValuesPreprocessor;\nconst SECURE_VALUES_PREPROCESSOR = new SecureValuesPreprocessor();\nexports.SECURE_VALUES_PREPROCESSOR = SECURE_VALUES_PREPROCESSOR;\nvar _default = SECURE_VALUES_PREPROCESSOR;\nexports.default = _default;\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["DEFAULT_REPLACER","SecureValuesPreprocessor","constructor","_rules","rules","parseRule","rule","raiseError","msg","Error","JSON","stringify","pattern","replacer","flags","_","isString","length","escapeRegExp","isPlainObject","has","text","flag","includes","push","uniq","RegExp","join","e","message","loadRules","source","isArray","fs","exists","parse","readFile","issues","preprocess","str","result","replace","SECURE_VALUES_PREPROCESSOR"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\log-internal.js"],"sourcesContent":["import fs from './fs';\nimport _ from 'lodash';\n\nconst DEFAULT_REPLACER = '**SECURE**';\n\n/**\n * @typedef {Object} SecureValuePreprocessingRule\n * @property {RegExp} pattern The parsed pattern which is going to be used for replacement\n * @property {string} replacer [DEFAULT_SECURE_REPLACER] The replacer value to use. By default\n * equals to `DEFAULT_SECURE_REPLACER`\n */\n\nclass SecureValuesPreprocessor {\n  constructor () {\n    this._rules = [];\n  }\n\n  /**\n   * @returns {Array<SecureValuePreprocessingRule>} The list of successfully\n   * parsed preprocessing rules\n   */\n  get rules () {\n    return this._rules;\n  }\n\n  /**\n   * @typedef {Object} Rule\n   * @property {string} pattern A valid RegExp pattern to be replaced\n   * @property {string} text A text match to replace. Either this property or the\n   * above one must be provided. `pattern` has priority over `text` if both are provided.\n   * @property {string} flags ['g'] Regular expression flags for the given pattern.\n   * Supported flag are the same as for the standard JavaScript RegExp constructor:\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags_2\n   * The 'g' (global matching) is always enabled though.\n   * @property {string} replacer [DEFAULT_SECURE_REPLACER] The replacer value to use. By default\n   * equals to `DEFAULT_SECURE_REPLACER`\n   */\n\n  /**\n   * Parses single rule from the given JSON file\n   *\n   * @param {string|Rule} rule The rule might either be represented as a single string\n   * or a configuration object\n   * @throws {Error} If there was an error while parsing the rule\n   * @returns {SecureValuePreprocessingRule} The parsed rule\n   */\n  parseRule (rule) {\n    const raiseError = (msg) => {\n      throw new Error(`${JSON.stringify(rule)} -> ${msg}`);\n    };\n\n    let pattern;\n    let replacer = DEFAULT_REPLACER;\n    let flags = ['g'];\n    if (_.isString(rule)) {\n      if (rule.length === 0) {\n        raiseError('The value must not be empty');\n      }\n      pattern = `\\\\b${_.escapeRegExp(rule)}\\\\b`;\n    } else if (_.isPlainObject(rule)) {\n      if (_.has(rule, 'pattern')) {\n        if (!_.isString(rule.pattern) || rule.pattern.length === 0) {\n          raiseError(`The value of 'pattern' must be a valid non-empty string`);\n        }\n        pattern = rule.pattern;\n      } else if (_.has(rule, 'text')) {\n        if (!_.isString(rule.text) || rule.text.length === 0) {\n          raiseError(`The value of 'text' must be a valid non-empty string`);\n        }\n        pattern = `\\\\b${_.escapeRegExp(rule.text)}\\\\b`;\n      }\n      if (!pattern) {\n        raiseError(`Must either have a field named 'pattern' or 'text'`);\n      }\n\n      if (_.has(rule, 'flags')) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags_2\n        for (const flag of ['i', 'g', 'm', 's', 'u', 'y']) {\n          if (_.includes(rule.flags, flag)) {\n            flags.push(flag);\n          }\n        }\n        flags = _.uniq(flags);\n      }\n\n      if (_.isString(rule.replacer)) {\n        replacer = rule.replacer;\n      }\n    } else {\n      raiseError('Must either be a string or an object');\n    }\n\n    try {\n      return {\n        pattern: new RegExp(pattern, flags.join('')),\n        replacer,\n      };\n    } catch (e) {\n      raiseError(e.message);\n    }\n  }\n\n  /**\n   * Loads rules from the given JSON file\n   *\n   * @param {string|Array<string|Rule>} source The full path to the JSON file containing secure\n   * values replacement rules or the rules themselves represented as an array\n   * @throws {Error} If the format of the source file is invalid or\n   * it does not exist\n   * @returns {Array<string>} The list of issues found while parsing each rule.\n   * An empty list is returned if no rule parsing issues were found\n   */\n  async loadRules (source) {\n    let rules;\n    if (_.isArray(source)) {\n      rules = source;\n    } else {\n      if (!await fs.exists(source)) {\n        throw new Error(`'${source}' does not exist or is not accessible`);\n      }\n      try {\n        rules = JSON.parse(await fs.readFile(source, 'utf8'));\n      } catch (e) {\n        throw new Error(`'${source}' must be a valid JSON file. Original error: ${e.message}`);\n      }\n      if (!_.isArray(rules)) {\n        throw new Error(`'${source}' must contain a valid JSON array`);\n      }\n    }\n\n    const issues = [];\n    this._rules = [];\n    for (const rule of rules) {\n      try {\n        this._rules.push(this.parseRule(rule));\n      } catch (e) {\n        issues.push(e.message);\n      }\n    }\n    return issues;\n  }\n\n  /**\n   * Performs secure values replacement inside the given string\n   * according to the previously loaded rules. No replacement is made\n   * if there are no rules or the given value is not a string\n   *\n   * @param {string} str The string to make replacements in\n   * @returns {string} The string with replacements made\n   */\n  preprocess (str) {\n    if (this._rules.length === 0 || !_.isString(str)) {\n      return str;\n    }\n\n    let result = str;\n    for (const rule of this._rules) {\n      result = result.replace(rule.pattern, rule.replacer);\n    }\n    return result;\n  }\n}\n\nconst SECURE_VALUES_PREPROCESSOR = new SecureValuesPreprocessor();\n\nexport { SECURE_VALUES_PREPROCESSOR, SecureValuesPreprocessor };\nexport default SECURE_VALUES_PREPROCESSOR;\n"]},"metadata":{},"sourceType":"script"}