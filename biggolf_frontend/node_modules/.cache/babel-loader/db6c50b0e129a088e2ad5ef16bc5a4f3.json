{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patchLogger = patchLogger;\nexports.getLogger = getLogger;\nexports.loadSecureValuesPreprocessingRules = loadSecureValuesPreprocessingRules;\nexports.default = exports.log = void 0;\nrequire(\"source-map-support/register\");\nvar _npmlog = _interopRequireDefault(require(\"npmlog\"));\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _util = require(\"./util\");\nvar _moment = _interopRequireDefault(require(\"moment\"));\nvar _logInternal = _interopRequireDefault(require(\"./log-internal\"));\nconst NPM_LEVELS = ['silly', 'verbose', 'debug', 'info', 'http', 'warn', 'error'];\nconst MAX_LOG_RECORDS_COUNT = 3000;\nconst PREFIX_TIMESTAMP_FORMAT = 'HH-mm-ss:SSS';\nlet mockLog = {};\nfor (let level of NPM_LEVELS) {\n  mockLog[level] = () => {};\n}\nfunction patchLogger(logger) {\n  if (!logger.debug) {\n    logger.addLevel('debug', 1000, {\n      fg: 'blue',\n      bg: 'black'\n    }, 'dbug');\n  }\n}\nfunction _getLogger() {\n  const testingMode = parseInt(process.env._TESTING, 10) === 1;\n  const forceLogMode = parseInt(process.env._FORCE_LOGS, 10) === 1;\n  const usingGlobalLog = !!global._global_npmlog;\n  let logger;\n  if (testingMode && !forceLogMode) {\n    logger = mockLog;\n  } else {\n    logger = global._global_npmlog || _npmlog.default;\n    logger.maxRecordSize = MAX_LOG_RECORDS_COUNT;\n  }\n  patchLogger(logger);\n  return [logger, usingGlobalLog];\n}\nfunction getActualPrefix(prefix) {\n  let logTimestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let actualPrefix = _lodash.default.isFunction(prefix) ? prefix() : prefix;\n  if (logTimestamp) {\n    actualPrefix = `[${(0, _moment.default)().format(PREFIX_TIMESTAMP_FORMAT)}] ${actualPrefix}`;\n  }\n  return actualPrefix;\n}\nfunction getLogger() {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let [logger, usingGlobalLog] = _getLogger();\n  let wrappedLogger = {\n    unwrap: () => logger\n  };\n  Object.defineProperty(wrappedLogger, 'level', {\n    get() {\n      return logger.level;\n    },\n    set(newValue) {\n      logger.level = newValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  const logTimestamp = parseInt(process.env._LOG_TIMESTAMP, 10) === 1;\n  for (const level of NPM_LEVELS) {\n    wrappedLogger[level] = function () {\n      const actualPrefix = getActualPrefix(prefix, logTimestamp);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      for (const arg of args) {\n        const out = _lodash.default.isError(arg) && arg.stack ? arg.stack : `${arg}`;\n        for (const line of out.split('\\n')) {\n          const unleakedLine = (0, _util.unleakString)(line);\n          logger[level](actualPrefix, _logInternal.default.preprocess(unleakedLine));\n        }\n      }\n    };\n  }\n  wrappedLogger.errorAndThrow = function (err) {\n    this.error(err);\n    throw _lodash.default.isError(err) ? err : new Error((0, _util.unleakString)(err));\n  };\n  if (!usingGlobalLog) {\n    wrappedLogger.level = 'verbose';\n  }\n  wrappedLogger.levels = NPM_LEVELS;\n  return wrappedLogger;\n}\nasync function loadSecureValuesPreprocessingRules(rulesJsonPath) {\n  const issues = await _logInternal.default.loadRules(rulesJsonPath);\n  return {\n    issues,\n    rules: _lodash.default.cloneDeep(_logInternal.default.rules)\n  };\n}\nconst log = getLogger();\nexports.log = log;\nvar _default = log;\nexports.default = _default;\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["NPM_LEVELS","MAX_LOG_RECORDS_COUNT","PREFIX_TIMESTAMP_FORMAT","mockLog","level","patchLogger","logger","debug","addLevel","fg","bg","_getLogger","testingMode","parseInt","process","env","_TESTING","forceLogMode","_FORCE_LOGS","usingGlobalLog","global","_global_npmlog","npmlog","maxRecordSize","getActualPrefix","prefix","logTimestamp","actualPrefix","_","isFunction","format","getLogger","wrappedLogger","unwrap","Object","defineProperty","get","set","newValue","enumerable","configurable","_LOG_TIMESTAMP","args","arg","out","isError","stack","line","split","unleakedLine","SECURE_VALUES_PREPROCESSOR","preprocess","errorAndThrow","err","error","Error","levels","loadSecureValuesPreprocessingRules","rulesJsonPath","issues","loadRules","rules","cloneDeep","log"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\logging.js"],"sourcesContent":["import npmlog from 'npmlog';\nimport _ from 'lodash';\nimport { unleakString } from './util';\nimport moment from 'moment';\nimport SECURE_VALUES_PREPROCESSOR from './log-internal';\n\n// levels that are available from `npmlog`\nconst NPM_LEVELS = ['silly', 'verbose', 'debug', 'info', 'http', 'warn', 'error'];\nconst MAX_LOG_RECORDS_COUNT = 3000;\n\nconst PREFIX_TIMESTAMP_FORMAT = 'HH-mm-ss:SSS';\n\n// mock log object used in testing mode\nlet mockLog = {};\nfor (let level of NPM_LEVELS) {\n  mockLog[level] = () => {};\n}\n\nfunction patchLogger (logger) {\n  if (!logger.debug) {\n    logger.addLevel('debug', 1000, { fg: 'blue', bg: 'black' }, 'dbug');\n  }\n}\n\nfunction _getLogger () {\n  // check if the user set the `_TESTING` or `_FORCE_LOGS` flag\n  const testingMode = parseInt(process.env._TESTING, 10) === 1;\n  const forceLogMode = parseInt(process.env._FORCE_LOGS, 10) === 1;\n\n  // if is possible that there is a logger instance that is already around,\n  // in which case we want t o use that\n  const usingGlobalLog = !!global._global_npmlog;\n  let logger;\n  if (testingMode && !forceLogMode) {\n    // in testing mode, use a mock logger object that we can query\n    logger = mockLog;\n  } else {\n    // otherwise, either use the global, or a new `npmlog` object\n    logger = global._global_npmlog || npmlog;\n    // The default value is 10000, which causes excessive memory usage\n    logger.maxRecordSize = MAX_LOG_RECORDS_COUNT;\n  }\n  patchLogger(logger);\n  return [logger, usingGlobalLog];\n}\n\nfunction getActualPrefix (prefix, logTimestamp = false) {\n  let actualPrefix = _.isFunction(prefix) ? prefix() : prefix;\n  if (logTimestamp) {\n    actualPrefix = `[${moment().format(PREFIX_TIMESTAMP_FORMAT)}] ${actualPrefix}`;\n  }\n  return actualPrefix;\n}\n\nfunction getLogger (prefix = null) {\n  let [logger, usingGlobalLog] = _getLogger();\n\n  // wrap the logger so that we can catch and modify any logging\n  let wrappedLogger = {unwrap: () => logger};\n\n  // allow access to the level of the underlying logger\n  Object.defineProperty(wrappedLogger, 'level', {\n    get () {\n      return logger.level;\n    },\n    set (newValue) {\n      logger.level = newValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  const logTimestamp = parseInt(process.env._LOG_TIMESTAMP, 10) === 1;\n\n  // add all the levels from `npmlog`, and map to the underlying logger\n  for (const level of NPM_LEVELS) {\n    wrappedLogger[level] = function (...args) {\n      const actualPrefix = getActualPrefix(prefix, logTimestamp);\n      for (const arg of args) {\n        const out = (_.isError(arg) && arg.stack) ? arg.stack : `${arg}`;\n        for (const line of out.split('\\n')) {\n          // it is necessary to unleak each line because `split` call\n          // creates \"views\" to the original string as well as the `substring` one\n          const unleakedLine = unleakString(line);\n          logger[level](actualPrefix, SECURE_VALUES_PREPROCESSOR.preprocess(unleakedLine));\n        }\n      }\n    };\n  }\n  // add method to log an error, and throw it, for convenience\n  wrappedLogger.errorAndThrow = function (err) {\n    this.error(err);\n    // make sure we have an `Error` object. Wrap if necessary\n    throw (_.isError(err) ? err : new Error(unleakString(err)));\n  };\n  if (!usingGlobalLog) {\n    // if we're not using a global log specified from some top-level package,\n    // set the log level to a default of verbose. Otherwise, let the top-level\n    // package set the log level\n    wrappedLogger.level = 'verbose';\n  }\n  wrappedLogger.levels = NPM_LEVELS;\n  return wrappedLogger;\n}\n\n/**\n * @typedef {Object} LoadResult\n * @property {List<string>} issues The list of rule parsing issues (one item per rule).\n * Rules with issues are skipped. An empty list is returned if no parsing issues exist.\n * @property {List<SecureValuePreprocessingRule>} rules The list of successfully loaded\n * replacement rules. The list could be empty if no rules were loaded.\n */\n\n/**\n * Loads the JSON file containing secure values replacement rules.\n * This might be necessary to hide sensitive values that may possibly\n * appear in Appium logs.\n * Each call to this method replaces the previously loaded rules if any existed.\n *\n * @param {string} rulesJsonPath The full path to the JSON file containing\n * the replacement rules. Each rule could either be a string to be replaced\n * or an object with predefined properties. See the `Rule` type definition in\n * `log-internals.js` to get more details on its format.\n * @throws {Error} If the given file cannot be loaded\n * @returns {LoadResult}\n */\nasync function loadSecureValuesPreprocessingRules (rulesJsonPath) {\n  const issues = await SECURE_VALUES_PREPROCESSOR.loadRules(rulesJsonPath);\n  return {\n    issues,\n    rules: _.cloneDeep(SECURE_VALUES_PREPROCESSOR.rules),\n  };\n}\n\n// export a default logger with no prefix\nconst log = getLogger();\n\nexport { log, patchLogger, getLogger, loadSecureValuesPreprocessingRules };\nexport default log;\n"]},"metadata":{},"sourceType":"script"}