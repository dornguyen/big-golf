{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Duration = exports.Timer = void 0;\nrequire(\"source-map-support/register\");\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nconst NS_PER_S = 1e9;\nconst NS_PER_MS = 1e6;\nclass Duration {\n  constructor(nanos) {\n    this._nanos = nanos;\n  }\n  get nanos() {\n    return this._nanos;\n  }\n  get asNanoSeconds() {\n    return this.nanos;\n  }\n  get asMilliSeconds() {\n    return this.nanos / NS_PER_MS;\n  }\n  get asSeconds() {\n    return this.nanos / NS_PER_S;\n  }\n  toString() {\n    return this.asMilliSeconds.toFixed(0);\n  }\n}\nexports.Duration = Duration;\nclass Timer {\n  constructor() {\n    this._startTime = null;\n  }\n  get startTime() {\n    return this._startTime;\n  }\n  start() {\n    if (!_lodash.default.isNull(this.startTime)) {\n      throw new Error('Timer has already been started.');\n    }\n    this._startTime = _lodash.default.isFunction(process.hrtime.bigint) ? process.hrtime.bigint() : process.hrtime();\n    return this;\n  }\n  getDuration() {\n    if (_lodash.default.isNull(this.startTime)) {\n      throw new Error(`Unable to get duration. Timer was not started`);\n    }\n    let nanoDuration;\n    if (_lodash.default.isArray(this.startTime)) {\n      const [seconds, nanos] = process.hrtime(this.startTime);\n      nanoDuration = seconds * NS_PER_S + nanos;\n    } else if (typeof this.startTime === 'bigint' && _lodash.default.isFunction(process.hrtime.bigint)) {\n      const endTime = process.hrtime.bigint();\n      nanoDuration = Number(endTime - this.startTime);\n    } else {\n      throw new Error(`Unable to get duration. Start time '${this.startTime}' cannot be parsed`);\n    }\n    return new Duration(nanoDuration);\n  }\n  toString() {\n    try {\n      return this.getDuration().toString();\n    } catch (err) {\n      return `<err: ${err.message}>`;\n    }\n  }\n}\nexports.Timer = Timer;\nvar _default = Timer;\nexports.default = _default;\nrequire('source-map-support').install();","map":{"version":3,"mappings":";;;;;;;;AAAA;AAGA,MAAMA,QAAQ,GAAG,GAAjB;AACA,MAAMC,SAAS,GAAG,GAAlB;AAMA,MAAMC,QAAN,CAAe;EACbC,WAAW,CAAEC,KAAF,EAAS;IAClB,KAAKC,MAAL,GAAcD,KAAd;EACD;EAED,IAAIA,KAAJ,GAAa;IACX,OAAO,KAAKC,MAAZ;EACD;EAOD,IAAIC,aAAJ,GAAqB;IACnB,OAAO,KAAKF,KAAZ;EACD;EAOD,IAAIG,cAAJ,GAAsB;IACpB,OAAO,KAAKH,KAAL,GAAaH,SAApB;EACD;EAOD,IAAIO,SAAJ,GAAiB;IACf,OAAO,KAAKJ,KAAL,GAAaJ,QAApB;EACD;EAEDS,QAAQ,GAAI;IAEV,OAAO,KAAKF,cAAL,CAAoBG,OAApB,CAA4B,CAA5B,CAAP;EACD;AAvCY;;AA0Cf,MAAMC,KAAN,CAAY;EAIVR,WAAW,GAAI;IACb,KAAKS,UAAL,GAAkB,IAAlB;EACD;EAED,IAAIC,SAAJ,GAAiB;IACf,OAAO,KAAKD,UAAZ;EACD;EAODE,KAAK,GAAI;IACP,IAAI,CAACC,gBAAEC,MAAF,CAAS,KAAKH,SAAd,CAAL,EAA+B;MAC7B,MAAM,IAAII,KAAJ,CAAU,iCAAV,CAAN;IACD;IAED,KAAKL,UAAL,GAAkBG,gBAAEG,UAAF,CAAaC,OAAO,CAACC,MAAR,CAAeC,MAA5B,IACdF,OAAO,CAACC,MAAR,CAAeC,MAAf,EADc,GAEdF,OAAO,CAACC,MAAR,EAFJ;IAGA,OAAO,IAAP;EACD;EAODE,WAAW,GAAI;IACb,IAAIP,gBAAEC,MAAF,CAAS,KAAKH,SAAd,CAAJ,EAA8B;MAC5B,MAAM,IAAII,KAAJ,CAAW,+CAAX,CAAN;IACD;IAED,IAAIM,YAAJ;IACA,IAAIR,gBAAES,OAAF,CAAU,KAAKX,SAAf,CAAJ,EAA+B;MAE7B,MAAM,CAACY,OAAD,EAAUrB,KAAV,IAAmBe,OAAO,CAACC,MAAR,CAAe,KAAKP,SAApB,CAAzB;MACAU,YAAY,GAAGE,OAAO,GAAGzB,QAAV,GAAqBI,KAApC;IACD,CAJD,MAIO,IAAI,OAAO,KAAKS,SAAZ,KAA0B,QAA1B,IAAsCE,gBAAEG,UAAF,CAAaC,OAAO,CAACC,MAAR,CAAeC,MAA5B,CAA1C,EAA+E;MAEpF,MAAMK,OAAO,GAAGP,OAAO,CAACC,MAAR,CAAeC,MAAf,EAAhB;MAEAE,YAAY,GAAGI,MAAM,CAACD,OAAO,GAAG,KAAKb,SAAhB,CAArB;IACD,CALM,MAKA;MACL,MAAM,IAAII,KAAJ,CAAW,uCAAsC,KAAKJ,SAAU,oBAAhE,CAAN;IACD;IAED,OAAO,IAAIX,QAAJ,CAAaqB,YAAb,CAAP;EACD;EAEDd,QAAQ,GAAI;IACV,IAAI;MACF,OAAO,KAAKa,WAAL,GAAmBb,QAAnB,EAAP;IACD,CAFD,CAEE,OAAOmB,GAAP,EAAY;MACZ,OAAQ,SAAQA,GAAG,CAACC,OAAQ,GAA5B;IACD;EACF;AA7DS;;eAkEGlB,K","names":["NS_PER_S","NS_PER_MS","Duration","constructor","nanos","_nanos","asNanoSeconds","asMilliSeconds","asSeconds","toString","toFixed","Timer","_startTime","startTime","start","_","isNull","Error","isFunction","process","hrtime","bigint","getDuration","nanoDuration","isArray","seconds","endTime","Number","err","message"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\appium-support\\lib\\timing.js"],"sourcesContent":["import _ from 'lodash';\n\n\nconst NS_PER_S = 1e9;\nconst NS_PER_MS = 1e6;\n\n\n/**\n * Class representing a duration, encapsulating the number and units.\n */\nclass Duration {\n  constructor (nanos) {\n    this._nanos = nanos;\n  }\n\n  get nanos () {\n    return this._nanos;\n  }\n\n  /**\n   * Get the duration as nanoseconds\n   *\n   * @returns {number} The duration as nanoseconds\n   */\n  get asNanoSeconds () {\n    return this.nanos;\n  }\n\n  /**\n   * Get the duration converted into milliseconds\n   *\n   * @returns {number} The duration as milliseconds\n   */\n  get asMilliSeconds () {\n    return this.nanos / NS_PER_MS;\n  }\n\n  /**\n   * Get the duration converted into seconds\n   *\n   * @returns {number} The duration fas seconds\n   */\n  get asSeconds () {\n    return this.nanos / NS_PER_S;\n  }\n\n  toString () {\n    // default to milliseconds, rounded\n    return this.asMilliSeconds.toFixed(0);\n  }\n}\n\nclass Timer {\n  /**\n   * Creates a timer\n   */\n  constructor () {\n    this._startTime = null;\n  }\n\n  get startTime () {\n    return this._startTime;\n  }\n\n  /**\n   * Start the timer\n   *\n   * @return {Timer} The current instance, for chaining\n   */\n  start () {\n    if (!_.isNull(this.startTime)) {\n      throw new Error('Timer has already been started.');\n    }\n    // once Node 10 is no longer supported, this check can be removed\n    this._startTime = _.isFunction(process.hrtime.bigint)\n      ? process.hrtime.bigint()\n      : process.hrtime();\n    return this;\n  }\n\n  /**\n   * Get the duration since the timer was started\n   *\n   * @return {Duration} the duration\n   */\n  getDuration () {\n    if (_.isNull(this.startTime)) {\n      throw new Error(`Unable to get duration. Timer was not started`);\n    }\n\n    let nanoDuration;\n    if (_.isArray(this.startTime)) {\n      // startTime was created using process.hrtime()\n      const [seconds, nanos] = process.hrtime(this.startTime);\n      nanoDuration = seconds * NS_PER_S + nanos;\n    } else if (typeof this.startTime === 'bigint' && _.isFunction(process.hrtime.bigint)) {\n      // startTime was created using process.hrtime.bigint()\n      const endTime = process.hrtime.bigint();\n      // get the difference, and convert to number\n      nanoDuration = Number(endTime - this.startTime);\n    } else {\n      throw new Error(`Unable to get duration. Start time '${this.startTime}' cannot be parsed`);\n    }\n\n    return new Duration(nanoDuration);\n  }\n\n  toString () {\n    try {\n      return this.getDuration().toString();\n    } catch (err) {\n      return `<err: ${err.message}>`;\n    }\n  }\n}\n\n\nexport { Timer, Duration };\nexport default Timer;\n"]},"metadata":{},"sourceType":"script"}