{"ast":null,"code":"\"use strict\";\n\nlet interlaceUtils = require(\"./interlace\");\nlet pixelBppMapper = [\n// 0 - dummy entry\nfunction () {},\n// 1 - L\n// 0: 0, 1: 0, 2: 0, 3: 0xff\nfunction (pxData, data, pxPos, rawPos) {\n  if (rawPos === data.length) {\n    throw new Error(\"Ran out of data\");\n  }\n  let pixel = data[rawPos];\n  pxData[pxPos] = pixel;\n  pxData[pxPos + 1] = pixel;\n  pxData[pxPos + 2] = pixel;\n  pxData[pxPos + 3] = 0xff;\n},\n// 2 - LA\n// 0: 0, 1: 0, 2: 0, 3: 1\nfunction (pxData, data, pxPos, rawPos) {\n  if (rawPos + 1 >= data.length) {\n    throw new Error(\"Ran out of data\");\n  }\n  let pixel = data[rawPos];\n  pxData[pxPos] = pixel;\n  pxData[pxPos + 1] = pixel;\n  pxData[pxPos + 2] = pixel;\n  pxData[pxPos + 3] = data[rawPos + 1];\n},\n// 3 - RGB\n// 0: 0, 1: 1, 2: 2, 3: 0xff\nfunction (pxData, data, pxPos, rawPos) {\n  if (rawPos + 2 >= data.length) {\n    throw new Error(\"Ran out of data\");\n  }\n  pxData[pxPos] = data[rawPos];\n  pxData[pxPos + 1] = data[rawPos + 1];\n  pxData[pxPos + 2] = data[rawPos + 2];\n  pxData[pxPos + 3] = 0xff;\n},\n// 4 - RGBA\n// 0: 0, 1: 1, 2: 2, 3: 3\nfunction (pxData, data, pxPos, rawPos) {\n  if (rawPos + 3 >= data.length) {\n    throw new Error(\"Ran out of data\");\n  }\n  pxData[pxPos] = data[rawPos];\n  pxData[pxPos + 1] = data[rawPos + 1];\n  pxData[pxPos + 2] = data[rawPos + 2];\n  pxData[pxPos + 3] = data[rawPos + 3];\n}];\nlet pixelBppCustomMapper = [\n// 0 - dummy entry\nfunction () {},\n// 1 - L\n// 0: 0, 1: 0, 2: 0, 3: 0xff\nfunction (pxData, pixelData, pxPos, maxBit) {\n  let pixel = pixelData[0];\n  pxData[pxPos] = pixel;\n  pxData[pxPos + 1] = pixel;\n  pxData[pxPos + 2] = pixel;\n  pxData[pxPos + 3] = maxBit;\n},\n// 2 - LA\n// 0: 0, 1: 0, 2: 0, 3: 1\nfunction (pxData, pixelData, pxPos) {\n  let pixel = pixelData[0];\n  pxData[pxPos] = pixel;\n  pxData[pxPos + 1] = pixel;\n  pxData[pxPos + 2] = pixel;\n  pxData[pxPos + 3] = pixelData[1];\n},\n// 3 - RGB\n// 0: 0, 1: 1, 2: 2, 3: 0xff\nfunction (pxData, pixelData, pxPos, maxBit) {\n  pxData[pxPos] = pixelData[0];\n  pxData[pxPos + 1] = pixelData[1];\n  pxData[pxPos + 2] = pixelData[2];\n  pxData[pxPos + 3] = maxBit;\n},\n// 4 - RGBA\n// 0: 0, 1: 1, 2: 2, 3: 3\nfunction (pxData, pixelData, pxPos) {\n  pxData[pxPos] = pixelData[0];\n  pxData[pxPos + 1] = pixelData[1];\n  pxData[pxPos + 2] = pixelData[2];\n  pxData[pxPos + 3] = pixelData[3];\n}];\nfunction bitRetriever(data, depth) {\n  let leftOver = [];\n  let i = 0;\n  function split() {\n    if (i === data.length) {\n      throw new Error(\"Ran out of data\");\n    }\n    let byte = data[i];\n    i++;\n    let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;\n    switch (depth) {\n      default:\n        throw new Error(\"unrecognised depth\");\n      case 16:\n        byte2 = data[i];\n        i++;\n        leftOver.push((byte << 8) + byte2);\n        break;\n      case 4:\n        byte2 = byte & 0x0f;\n        byte1 = byte >> 4;\n        leftOver.push(byte1, byte2);\n        break;\n      case 2:\n        byte4 = byte & 3;\n        byte3 = byte >> 2 & 3;\n        byte2 = byte >> 4 & 3;\n        byte1 = byte >> 6 & 3;\n        leftOver.push(byte1, byte2, byte3, byte4);\n        break;\n      case 1:\n        byte8 = byte & 1;\n        byte7 = byte >> 1 & 1;\n        byte6 = byte >> 2 & 1;\n        byte5 = byte >> 3 & 1;\n        byte4 = byte >> 4 & 1;\n        byte3 = byte >> 5 & 1;\n        byte2 = byte >> 6 & 1;\n        byte1 = byte >> 7 & 1;\n        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);\n        break;\n    }\n  }\n  return {\n    get: function (count) {\n      while (leftOver.length < count) {\n        split();\n      }\n      let returner = leftOver.slice(0, count);\n      leftOver = leftOver.slice(count);\n      return returner;\n    },\n    resetAfterLine: function () {\n      leftOver.length = 0;\n    },\n    end: function () {\n      if (i !== data.length) {\n        throw new Error(\"extra data found\");\n      }\n    }\n  };\n}\nfunction mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {\n  // eslint-disable-line max-params\n  let imageWidth = image.width;\n  let imageHeight = image.height;\n  let imagePass = image.index;\n  for (let y = 0; y < imageHeight; y++) {\n    for (let x = 0; x < imageWidth; x++) {\n      let pxPos = getPxPos(x, y, imagePass);\n      pixelBppMapper[bpp](pxData, data, pxPos, rawPos);\n      rawPos += bpp; //eslint-disable-line no-param-reassign\n    }\n  }\n\n  return rawPos;\n}\nfunction mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {\n  // eslint-disable-line max-params\n  let imageWidth = image.width;\n  let imageHeight = image.height;\n  let imagePass = image.index;\n  for (let y = 0; y < imageHeight; y++) {\n    for (let x = 0; x < imageWidth; x++) {\n      let pixelData = bits.get(bpp);\n      let pxPos = getPxPos(x, y, imagePass);\n      pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);\n    }\n    bits.resetAfterLine();\n  }\n}\nexports.dataToBitMap = function (data, bitmapInfo) {\n  let width = bitmapInfo.width;\n  let height = bitmapInfo.height;\n  let depth = bitmapInfo.depth;\n  let bpp = bitmapInfo.bpp;\n  let interlace = bitmapInfo.interlace;\n  let bits;\n  if (depth !== 8) {\n    bits = bitRetriever(data, depth);\n  }\n  let pxData;\n  if (depth <= 8) {\n    pxData = Buffer.alloc(width * height * 4);\n  } else {\n    pxData = new Uint16Array(width * height * 4);\n  }\n  let maxBit = Math.pow(2, depth) - 1;\n  let rawPos = 0;\n  let images;\n  let getPxPos;\n  if (interlace) {\n    images = interlaceUtils.getImagePasses(width, height);\n    getPxPos = interlaceUtils.getInterlaceIterator(width, height);\n  } else {\n    let nonInterlacedPxPos = 0;\n    getPxPos = function () {\n      let returner = nonInterlacedPxPos;\n      nonInterlacedPxPos += 4;\n      return returner;\n    };\n    images = [{\n      width: width,\n      height: height\n    }];\n  }\n  for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {\n    if (depth === 8) {\n      rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);\n    } else {\n      mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);\n    }\n  }\n  if (depth === 8) {\n    if (rawPos !== data.length) {\n      throw new Error(\"extra data found\");\n    }\n  } else {\n    bits.end();\n  }\n  return pxData;\n};","map":{"version":3,"names":["interlaceUtils","require","pixelBppMapper","pxData","data","pxPos","rawPos","length","Error","pixel","pixelBppCustomMapper","pixelData","maxBit","bitRetriever","depth","leftOver","i","split","byte","byte8","byte7","byte6","byte5","byte4","byte3","byte2","byte1","push","get","count","returner","slice","resetAfterLine","end","mapImage8Bit","image","getPxPos","bpp","imageWidth","width","imageHeight","height","imagePass","index","y","x","mapImageCustomBit","bits","exports","dataToBitMap","bitmapInfo","interlace","Buffer","alloc","Uint16Array","Math","pow","images","getImagePasses","getInterlaceIterator","nonInterlacedPxPos","imageIndex"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/pngjs/lib/bitmapper.js"],"sourcesContent":["\"use strict\";\n\nlet interlaceUtils = require(\"./interlace\");\n\nlet pixelBppMapper = [\n  // 0 - dummy entry\n  function () {},\n\n  // 1 - L\n  // 0: 0, 1: 0, 2: 0, 3: 0xff\n  function (pxData, data, pxPos, rawPos) {\n    if (rawPos === data.length) {\n      throw new Error(\"Ran out of data\");\n    }\n\n    let pixel = data[rawPos];\n    pxData[pxPos] = pixel;\n    pxData[pxPos + 1] = pixel;\n    pxData[pxPos + 2] = pixel;\n    pxData[pxPos + 3] = 0xff;\n  },\n\n  // 2 - LA\n  // 0: 0, 1: 0, 2: 0, 3: 1\n  function (pxData, data, pxPos, rawPos) {\n    if (rawPos + 1 >= data.length) {\n      throw new Error(\"Ran out of data\");\n    }\n\n    let pixel = data[rawPos];\n    pxData[pxPos] = pixel;\n    pxData[pxPos + 1] = pixel;\n    pxData[pxPos + 2] = pixel;\n    pxData[pxPos + 3] = data[rawPos + 1];\n  },\n\n  // 3 - RGB\n  // 0: 0, 1: 1, 2: 2, 3: 0xff\n  function (pxData, data, pxPos, rawPos) {\n    if (rawPos + 2 >= data.length) {\n      throw new Error(\"Ran out of data\");\n    }\n\n    pxData[pxPos] = data[rawPos];\n    pxData[pxPos + 1] = data[rawPos + 1];\n    pxData[pxPos + 2] = data[rawPos + 2];\n    pxData[pxPos + 3] = 0xff;\n  },\n\n  // 4 - RGBA\n  // 0: 0, 1: 1, 2: 2, 3: 3\n  function (pxData, data, pxPos, rawPos) {\n    if (rawPos + 3 >= data.length) {\n      throw new Error(\"Ran out of data\");\n    }\n\n    pxData[pxPos] = data[rawPos];\n    pxData[pxPos + 1] = data[rawPos + 1];\n    pxData[pxPos + 2] = data[rawPos + 2];\n    pxData[pxPos + 3] = data[rawPos + 3];\n  },\n];\n\nlet pixelBppCustomMapper = [\n  // 0 - dummy entry\n  function () {},\n\n  // 1 - L\n  // 0: 0, 1: 0, 2: 0, 3: 0xff\n  function (pxData, pixelData, pxPos, maxBit) {\n    let pixel = pixelData[0];\n    pxData[pxPos] = pixel;\n    pxData[pxPos + 1] = pixel;\n    pxData[pxPos + 2] = pixel;\n    pxData[pxPos + 3] = maxBit;\n  },\n\n  // 2 - LA\n  // 0: 0, 1: 0, 2: 0, 3: 1\n  function (pxData, pixelData, pxPos) {\n    let pixel = pixelData[0];\n    pxData[pxPos] = pixel;\n    pxData[pxPos + 1] = pixel;\n    pxData[pxPos + 2] = pixel;\n    pxData[pxPos + 3] = pixelData[1];\n  },\n\n  // 3 - RGB\n  // 0: 0, 1: 1, 2: 2, 3: 0xff\n  function (pxData, pixelData, pxPos, maxBit) {\n    pxData[pxPos] = pixelData[0];\n    pxData[pxPos + 1] = pixelData[1];\n    pxData[pxPos + 2] = pixelData[2];\n    pxData[pxPos + 3] = maxBit;\n  },\n\n  // 4 - RGBA\n  // 0: 0, 1: 1, 2: 2, 3: 3\n  function (pxData, pixelData, pxPos) {\n    pxData[pxPos] = pixelData[0];\n    pxData[pxPos + 1] = pixelData[1];\n    pxData[pxPos + 2] = pixelData[2];\n    pxData[pxPos + 3] = pixelData[3];\n  },\n];\n\nfunction bitRetriever(data, depth) {\n  let leftOver = [];\n  let i = 0;\n\n  function split() {\n    if (i === data.length) {\n      throw new Error(\"Ran out of data\");\n    }\n    let byte = data[i];\n    i++;\n    let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;\n    switch (depth) {\n      default:\n        throw new Error(\"unrecognised depth\");\n      case 16:\n        byte2 = data[i];\n        i++;\n        leftOver.push((byte << 8) + byte2);\n        break;\n      case 4:\n        byte2 = byte & 0x0f;\n        byte1 = byte >> 4;\n        leftOver.push(byte1, byte2);\n        break;\n      case 2:\n        byte4 = byte & 3;\n        byte3 = (byte >> 2) & 3;\n        byte2 = (byte >> 4) & 3;\n        byte1 = (byte >> 6) & 3;\n        leftOver.push(byte1, byte2, byte3, byte4);\n        break;\n      case 1:\n        byte8 = byte & 1;\n        byte7 = (byte >> 1) & 1;\n        byte6 = (byte >> 2) & 1;\n        byte5 = (byte >> 3) & 1;\n        byte4 = (byte >> 4) & 1;\n        byte3 = (byte >> 5) & 1;\n        byte2 = (byte >> 6) & 1;\n        byte1 = (byte >> 7) & 1;\n        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);\n        break;\n    }\n  }\n\n  return {\n    get: function (count) {\n      while (leftOver.length < count) {\n        split();\n      }\n      let returner = leftOver.slice(0, count);\n      leftOver = leftOver.slice(count);\n      return returner;\n    },\n    resetAfterLine: function () {\n      leftOver.length = 0;\n    },\n    end: function () {\n      if (i !== data.length) {\n        throw new Error(\"extra data found\");\n      }\n    },\n  };\n}\n\nfunction mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {\n  // eslint-disable-line max-params\n  let imageWidth = image.width;\n  let imageHeight = image.height;\n  let imagePass = image.index;\n  for (let y = 0; y < imageHeight; y++) {\n    for (let x = 0; x < imageWidth; x++) {\n      let pxPos = getPxPos(x, y, imagePass);\n      pixelBppMapper[bpp](pxData, data, pxPos, rawPos);\n      rawPos += bpp; //eslint-disable-line no-param-reassign\n    }\n  }\n  return rawPos;\n}\n\nfunction mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {\n  // eslint-disable-line max-params\n  let imageWidth = image.width;\n  let imageHeight = image.height;\n  let imagePass = image.index;\n  for (let y = 0; y < imageHeight; y++) {\n    for (let x = 0; x < imageWidth; x++) {\n      let pixelData = bits.get(bpp);\n      let pxPos = getPxPos(x, y, imagePass);\n      pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);\n    }\n    bits.resetAfterLine();\n  }\n}\n\nexports.dataToBitMap = function (data, bitmapInfo) {\n  let width = bitmapInfo.width;\n  let height = bitmapInfo.height;\n  let depth = bitmapInfo.depth;\n  let bpp = bitmapInfo.bpp;\n  let interlace = bitmapInfo.interlace;\n  let bits;\n\n  if (depth !== 8) {\n    bits = bitRetriever(data, depth);\n  }\n  let pxData;\n  if (depth <= 8) {\n    pxData = Buffer.alloc(width * height * 4);\n  } else {\n    pxData = new Uint16Array(width * height * 4);\n  }\n  let maxBit = Math.pow(2, depth) - 1;\n  let rawPos = 0;\n  let images;\n  let getPxPos;\n\n  if (interlace) {\n    images = interlaceUtils.getImagePasses(width, height);\n    getPxPos = interlaceUtils.getInterlaceIterator(width, height);\n  } else {\n    let nonInterlacedPxPos = 0;\n    getPxPos = function () {\n      let returner = nonInterlacedPxPos;\n      nonInterlacedPxPos += 4;\n      return returner;\n    };\n    images = [{ width: width, height: height }];\n  }\n\n  for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {\n    if (depth === 8) {\n      rawPos = mapImage8Bit(\n        images[imageIndex],\n        pxData,\n        getPxPos,\n        bpp,\n        data,\n        rawPos\n      );\n    } else {\n      mapImageCustomBit(\n        images[imageIndex],\n        pxData,\n        getPxPos,\n        bpp,\n        bits,\n        maxBit\n      );\n    }\n  }\n  if (depth === 8) {\n    if (rawPos !== data.length) {\n      throw new Error(\"extra data found\");\n    }\n  } else {\n    bits.end();\n  }\n\n  return pxData;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}