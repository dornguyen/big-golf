{"ast":null,"code":"\"use strict\";\n\nlet constants = require(\"./constants\");\nmodule.exports = function (dataIn, width, height, options) {\n  let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;\n  if (options.colorType === options.inputColorType) {\n    let bigEndian = function () {\n      let buffer = new ArrayBuffer(2);\n      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n      // Int16Array uses the platform's endianness.\n      return new Int16Array(buffer)[0] !== 256;\n    }();\n    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route\n    if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {\n      return dataIn;\n    }\n  }\n\n  // map to a UInt16 array if data is 16bit, fix endianness below\n  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);\n  let maxValue = 255;\n  let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];\n  if (inBpp === 4 && !options.inputHasAlpha) {\n    inBpp = 3;\n  }\n  let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];\n  if (options.bitDepth === 16) {\n    maxValue = 65535;\n    outBpp *= 2;\n  }\n  let outData = Buffer.alloc(width * height * outBpp);\n  let inIndex = 0;\n  let outIndex = 0;\n  let bgColor = options.bgColor || {};\n  if (bgColor.red === undefined) {\n    bgColor.red = maxValue;\n  }\n  if (bgColor.green === undefined) {\n    bgColor.green = maxValue;\n  }\n  if (bgColor.blue === undefined) {\n    bgColor.blue = maxValue;\n  }\n  function getRGBA() {\n    let red;\n    let green;\n    let blue;\n    let alpha = maxValue;\n    switch (options.inputColorType) {\n      case constants.COLORTYPE_COLOR_ALPHA:\n        alpha = data[inIndex + 3];\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_COLOR:\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_ALPHA:\n        alpha = data[inIndex + 1];\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      case constants.COLORTYPE_GRAYSCALE:\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      default:\n        throw new Error(\"input color type:\" + options.inputColorType + \" is not supported at present\");\n    }\n    if (options.inputHasAlpha) {\n      if (!outHasAlpha) {\n        alpha /= maxValue;\n        red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);\n        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);\n        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);\n      }\n    }\n    return {\n      red: red,\n      green: green,\n      blue: blue,\n      alpha: alpha\n    };\n  }\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let rgba = getRGBA(data, inIndex);\n      switch (options.colorType) {\n        case constants.COLORTYPE_COLOR_ALPHA:\n        case constants.COLORTYPE_COLOR:\n          if (options.bitDepth === 8) {\n            outData[outIndex] = rgba.red;\n            outData[outIndex + 1] = rgba.green;\n            outData[outIndex + 2] = rgba.blue;\n            if (outHasAlpha) {\n              outData[outIndex + 3] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(rgba.red, outIndex);\n            outData.writeUInt16BE(rgba.green, outIndex + 2);\n            outData.writeUInt16BE(rgba.blue, outIndex + 4);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 6);\n            }\n          }\n          break;\n        case constants.COLORTYPE_ALPHA:\n        case constants.COLORTYPE_GRAYSCALE:\n          {\n            // Convert to grayscale and alpha\n            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;\n            if (options.bitDepth === 8) {\n              outData[outIndex] = grayscale;\n              if (outHasAlpha) {\n                outData[outIndex + 1] = rgba.alpha;\n              }\n            } else {\n              outData.writeUInt16BE(grayscale, outIndex);\n              if (outHasAlpha) {\n                outData.writeUInt16BE(rgba.alpha, outIndex + 2);\n              }\n            }\n            break;\n          }\n        default:\n          throw new Error(\"unrecognised color Type \" + options.colorType);\n      }\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n  return outData;\n};","map":{"version":3,"names":["constants","require","module","exports","dataIn","width","height","options","outHasAlpha","COLORTYPE_COLOR_ALPHA","COLORTYPE_ALPHA","indexOf","colorType","inputColorType","bigEndian","buffer","ArrayBuffer","DataView","setInt16","Int16Array","bitDepth","data","Uint16Array","maxValue","inBpp","COLORTYPE_TO_BPP_MAP","inputHasAlpha","outBpp","outData","Buffer","alloc","inIndex","outIndex","bgColor","red","undefined","green","blue","getRGBA","alpha","COLORTYPE_COLOR","COLORTYPE_GRAYSCALE","Error","Math","min","max","round","y","x","rgba","writeUInt16BE","grayscale"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/pngjs/lib/bitpacker.js"],"sourcesContent":["\"use strict\";\n\nlet constants = require(\"./constants\");\n\nmodule.exports = function (dataIn, width, height, options) {\n  let outHasAlpha =\n    [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(\n      options.colorType\n    ) !== -1;\n  if (options.colorType === options.inputColorType) {\n    let bigEndian = (function () {\n      let buffer = new ArrayBuffer(2);\n      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n      // Int16Array uses the platform's endianness.\n      return new Int16Array(buffer)[0] !== 256;\n    })();\n    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route\n    if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)) {\n      return dataIn;\n    }\n  }\n\n  // map to a UInt16 array if data is 16bit, fix endianness below\n  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);\n\n  let maxValue = 255;\n  let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];\n  if (inBpp === 4 && !options.inputHasAlpha) {\n    inBpp = 3;\n  }\n  let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];\n  if (options.bitDepth === 16) {\n    maxValue = 65535;\n    outBpp *= 2;\n  }\n  let outData = Buffer.alloc(width * height * outBpp);\n\n  let inIndex = 0;\n  let outIndex = 0;\n\n  let bgColor = options.bgColor || {};\n  if (bgColor.red === undefined) {\n    bgColor.red = maxValue;\n  }\n  if (bgColor.green === undefined) {\n    bgColor.green = maxValue;\n  }\n  if (bgColor.blue === undefined) {\n    bgColor.blue = maxValue;\n  }\n\n  function getRGBA() {\n    let red;\n    let green;\n    let blue;\n    let alpha = maxValue;\n    switch (options.inputColorType) {\n      case constants.COLORTYPE_COLOR_ALPHA:\n        alpha = data[inIndex + 3];\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_COLOR:\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_ALPHA:\n        alpha = data[inIndex + 1];\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      case constants.COLORTYPE_GRAYSCALE:\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      default:\n        throw new Error(\n          \"input color type:\" +\n            options.inputColorType +\n            \" is not supported at present\"\n        );\n    }\n\n    if (options.inputHasAlpha) {\n      if (!outHasAlpha) {\n        alpha /= maxValue;\n        red = Math.min(\n          Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),\n          maxValue\n        );\n        green = Math.min(\n          Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),\n          maxValue\n        );\n        blue = Math.min(\n          Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),\n          maxValue\n        );\n      }\n    }\n    return { red: red, green: green, blue: blue, alpha: alpha };\n  }\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let rgba = getRGBA(data, inIndex);\n\n      switch (options.colorType) {\n        case constants.COLORTYPE_COLOR_ALPHA:\n        case constants.COLORTYPE_COLOR:\n          if (options.bitDepth === 8) {\n            outData[outIndex] = rgba.red;\n            outData[outIndex + 1] = rgba.green;\n            outData[outIndex + 2] = rgba.blue;\n            if (outHasAlpha) {\n              outData[outIndex + 3] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(rgba.red, outIndex);\n            outData.writeUInt16BE(rgba.green, outIndex + 2);\n            outData.writeUInt16BE(rgba.blue, outIndex + 4);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 6);\n            }\n          }\n          break;\n        case constants.COLORTYPE_ALPHA:\n        case constants.COLORTYPE_GRAYSCALE: {\n          // Convert to grayscale and alpha\n          let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;\n          if (options.bitDepth === 8) {\n            outData[outIndex] = grayscale;\n            if (outHasAlpha) {\n              outData[outIndex + 1] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(grayscale, outIndex);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 2);\n            }\n          }\n          break;\n        }\n        default:\n          throw new Error(\"unrecognised color Type \" + options.colorType);\n      }\n\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n\n  return outData;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}