{"ast":null,"code":"'use strict';\n\n// adapted from http://code.google.com/p/plist/source/browse/trunk/src/main/java/com/dd/plist/BinaryPropertyListWriter.java\nvar streamBuffers = require(\"stream-buffers\");\nvar debug = false;\nfunction Real(value) {\n  this.value = value;\n}\nmodule.exports = function (dicts) {\n  var buffer = new streamBuffers.WritableStreamBuffer();\n  buffer.write(Buffer.from(\"bplist00\"));\n  if (debug) {\n    console.log('create', require('util').inspect(dicts, false, 10));\n  }\n  if (dicts instanceof Array && dicts.length === 1) {\n    dicts = dicts[0];\n  }\n  var entries = toEntries(dicts);\n  if (debug) {\n    console.log('entries', entries);\n  }\n  var idSizeInBytes = computeIdSizeInBytes(entries.length);\n  var offsets = [];\n  var offsetSizeInBytes;\n  var offsetTableOffset;\n  updateEntryIds();\n  entries.forEach(function (entry, entryIdx) {\n    offsets[entryIdx] = buffer.size();\n    if (!entry) {\n      buffer.write(0x00);\n    } else {\n      write(entry);\n    }\n  });\n  writeOffsetTable();\n  writeTrailer();\n  return buffer.getContents();\n  function updateEntryIds() {\n    var strings = {};\n    var entryId = 0;\n    entries.forEach(function (entry) {\n      if (entry.id) {\n        return;\n      }\n      if (entry.type === 'string') {\n        if (!entry.bplistOverride && strings.hasOwnProperty(entry.value)) {\n          entry.type = 'stringref';\n          entry.id = strings[entry.value];\n        } else {\n          strings[entry.value] = entry.id = entryId++;\n        }\n      } else {\n        entry.id = entryId++;\n      }\n    });\n    entries = entries.filter(function (entry) {\n      return entry.type !== 'stringref';\n    });\n  }\n  function writeTrailer() {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer');\n    }\n    // 6 null bytes\n    buffer.write(Buffer.from([0, 0, 0, 0, 0, 0]));\n\n    // size of an offset\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offsetSizeInBytes):', offsetSizeInBytes);\n    }\n    writeByte(offsetSizeInBytes);\n\n    // size of a ref\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offsetSizeInBytes):', idSizeInBytes);\n    }\n    writeByte(idSizeInBytes);\n\n    // number of objects\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(number of objects):', entries.length);\n    }\n    writeLong(entries.length);\n\n    // top object\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(top object)');\n    }\n    writeLong(0);\n\n    // offset table offset\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offset table offset):', offsetTableOffset);\n    }\n    writeLong(offsetTableOffset);\n  }\n  function writeOffsetTable() {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeOffsetTable');\n    }\n    offsetTableOffset = buffer.size();\n    offsetSizeInBytes = computeOffsetSizeInBytes(offsetTableOffset);\n    offsets.forEach(function (offset) {\n      writeBytes(offset, offsetSizeInBytes);\n    });\n  }\n  function write(entry) {\n    switch (entry.type) {\n      case 'dict':\n        writeDict(entry);\n        break;\n      case 'number':\n      case 'double':\n        writeNumber(entry);\n        break;\n      case 'UID':\n        writeUID(entry);\n        break;\n      case 'array':\n        writeArray(entry);\n        break;\n      case 'boolean':\n        writeBoolean(entry);\n        break;\n      case 'string':\n      case 'string-utf16':\n        writeString(entry);\n        break;\n      case 'date':\n        writeDate(entry);\n        break;\n      case 'data':\n        writeData(entry);\n        break;\n      default:\n        throw new Error(\"unhandled entry type: \" + entry.type);\n    }\n  }\n  function writeDate(entry) {\n    writeByte(0x33);\n    var date = Date.parse(entry.value) / 1000 - 978307200;\n    writeDouble(date);\n  }\n  function writeDict(entry) {\n    if (debug) {\n      var keysStr = entry.entryKeys.map(function (k) {\n        return k.id;\n      });\n      var valsStr = entry.entryValues.map(function (k) {\n        return k.id;\n      });\n      console.log('0x' + buffer.size().toString(16), 'writeDict', '(id: ' + entry.id + ')', '(keys: ' + keysStr + ')', '(values: ' + valsStr + ')');\n    }\n    writeIntHeader(0xD, entry.entryKeys.length);\n    entry.entryKeys.forEach(function (entry) {\n      writeID(entry.id);\n    });\n    entry.entryValues.forEach(function (entry) {\n      writeID(entry.id);\n    });\n  }\n  function writeNumber(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeNumber', entry.value, ' (type: ' + entry.type + ')', '(id: ' + entry.id + ')');\n    }\n    if (typeof entry.value === 'bigint') {\n      var width = 16;\n      var hex = entry.value.toString(width);\n      var buf = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n      writeByte(0x14);\n      buffer.write(buf);\n    } else if (entry.type !== 'double' && parseFloat(entry.value).toFixed() == entry.value) {\n      if (entry.value < 0) {\n        writeByte(0x13);\n        writeBytes(entry.value, 8, true);\n      } else if (entry.value <= 0xff) {\n        writeByte(0x10);\n        writeBytes(entry.value, 1);\n      } else if (entry.value <= 0xffff) {\n        writeByte(0x11);\n        writeBytes(entry.value, 2);\n      } else if (entry.value <= 0xffffffff) {\n        writeByte(0x12);\n        writeBytes(entry.value, 4);\n      } else {\n        writeByte(0x13);\n        writeBytes(entry.value, 8);\n      }\n    } else {\n      writeByte(0x23);\n      writeDouble(entry.value);\n    }\n  }\n  function writeUID(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeUID', entry.value, ' (type: ' + entry.type + ')', '(id: ' + entry.id + ')');\n    }\n    writeIntHeader(0x8, 0x0);\n    writeID(entry.value);\n  }\n  function writeArray(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeArray (length: ' + entry.entries.length + ')', '(id: ' + entry.id + ')');\n    }\n    writeIntHeader(0xA, entry.entries.length);\n    entry.entries.forEach(function (e) {\n      writeID(e.id);\n    });\n  }\n  function writeBoolean(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeBoolean', entry.value, '(id: ' + entry.id + ')');\n    }\n    writeByte(entry.value ? 0x09 : 0x08);\n  }\n  function writeString(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeString', entry.value, '(id: ' + entry.id + ')');\n    }\n    if (entry.type === 'string-utf16' || mustBeUtf16(entry.value)) {\n      var utf16 = Buffer.from(entry.value, 'ucs2');\n      writeIntHeader(0x6, utf16.length / 2);\n      // needs to be big endian so swap the bytes\n      for (var i = 0; i < utf16.length; i += 2) {\n        var t = utf16[i + 0];\n        utf16[i + 0] = utf16[i + 1];\n        utf16[i + 1] = t;\n      }\n      buffer.write(utf16);\n    } else {\n      var utf8 = Buffer.from(entry.value, 'ascii');\n      writeIntHeader(0x5, utf8.length);\n      buffer.write(utf8);\n    }\n  }\n  function writeData(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeData', entry.value, '(id: ' + entry.id + ')');\n    }\n    writeIntHeader(0x4, entry.value.length);\n    buffer.write(entry.value);\n  }\n  function writeLong(l) {\n    writeBytes(l, 8);\n  }\n  function writeByte(b) {\n    buffer.write(Buffer.from([b]));\n  }\n  function writeDouble(v) {\n    var buf = Buffer.alloc(8);\n    buf.writeDoubleBE(v, 0);\n    buffer.write(buf);\n  }\n  function writeIntHeader(kind, value) {\n    if (value < 15) {\n      writeByte((kind << 4) + value);\n    } else if (value < 256) {\n      writeByte((kind << 4) + 15);\n      writeByte(0x10);\n      writeBytes(value, 1);\n    } else if (value < 65536) {\n      writeByte((kind << 4) + 15);\n      writeByte(0x11);\n      writeBytes(value, 2);\n    } else {\n      writeByte((kind << 4) + 15);\n      writeByte(0x12);\n      writeBytes(value, 4);\n    }\n  }\n  function writeID(id) {\n    writeBytes(id, idSizeInBytes);\n  }\n  function writeBytes(value, bytes, is_signedint) {\n    // write low-order bytes big-endian style\n    var buf = Buffer.alloc(bytes);\n    var z = 0;\n\n    // javascript doesn't handle large numbers\n    while (bytes > 4) {\n      buf[z++] = is_signedint ? 0xff : 0;\n      bytes--;\n    }\n    for (var i = bytes - 1; i >= 0; i--) {\n      buf[z++] = value >> 8 * i;\n    }\n    buffer.write(buf);\n  }\n  function mustBeUtf16(string) {\n    return Buffer.byteLength(string, 'utf8') != string.length;\n  }\n};\nfunction toEntries(dicts) {\n  if (dicts.bplistOverride) {\n    return [dicts];\n  }\n  if (dicts instanceof Array) {\n    return toEntriesArray(dicts);\n  } else if (dicts instanceof Buffer) {\n    return [{\n      type: 'data',\n      value: dicts\n    }];\n  } else if (dicts instanceof Real) {\n    return [{\n      type: 'double',\n      value: dicts.value\n    }];\n  } else if (typeof dicts === 'object') {\n    if (dicts instanceof Date) {\n      return [{\n        type: 'date',\n        value: dicts\n      }];\n    } else if (Object.keys(dicts).length == 1 && typeof dicts.UID === 'number') {\n      return [{\n        type: 'UID',\n        value: dicts.UID\n      }];\n    } else {\n      return toEntriesObject(dicts);\n    }\n  } else if (typeof dicts === 'string') {\n    return [{\n      type: 'string',\n      value: dicts\n    }];\n  } else if (typeof dicts === 'number') {\n    return [{\n      type: 'number',\n      value: dicts\n    }];\n  } else if (typeof dicts === 'boolean') {\n    return [{\n      type: 'boolean',\n      value: dicts\n    }];\n  } else if (typeof dicts === 'bigint') {\n    return [{\n      type: 'number',\n      value: dicts\n    }];\n  } else {\n    throw new Error('unhandled entry: ' + dicts);\n  }\n}\nfunction toEntriesArray(arr) {\n  if (debug) {\n    console.log('toEntriesArray');\n  }\n  var results = [{\n    type: 'array',\n    entries: []\n  }];\n  arr.forEach(function (v) {\n    var entry = toEntries(v);\n    results[0].entries.push(entry[0]);\n    results = results.concat(entry);\n  });\n  return results;\n}\nfunction toEntriesObject(dict) {\n  if (debug) {\n    console.log('toEntriesObject');\n  }\n  var results = [{\n    type: 'dict',\n    entryKeys: [],\n    entryValues: []\n  }];\n  Object.keys(dict).forEach(function (key) {\n    var entryKey = toEntries(key);\n    results[0].entryKeys.push(entryKey[0]);\n    results = results.concat(entryKey[0]);\n  });\n  Object.keys(dict).forEach(function (key) {\n    var entryValue = toEntries(dict[key]);\n    results[0].entryValues.push(entryValue[0]);\n    results = results.concat(entryValue);\n  });\n  return results;\n}\nfunction computeOffsetSizeInBytes(maxOffset) {\n  if (maxOffset < 256) {\n    return 1;\n  }\n  if (maxOffset < 65536) {\n    return 2;\n  }\n  if (maxOffset < 4294967296) {\n    return 4;\n  }\n  return 8;\n}\nfunction computeIdSizeInBytes(numberOfIds) {\n  if (numberOfIds < 256) {\n    return 1;\n  }\n  if (numberOfIds < 65536) {\n    return 2;\n  }\n  return 4;\n}\nmodule.exports.Real = Real;","map":{"version":3,"names":["streamBuffers","require","debug","Real","value","module","exports","dicts","buffer","WritableStreamBuffer","write","Buffer","from","console","log","inspect","Array","length","entries","toEntries","idSizeInBytes","computeIdSizeInBytes","offsets","offsetSizeInBytes","offsetTableOffset","updateEntryIds","forEach","entry","entryIdx","size","writeOffsetTable","writeTrailer","getContents","strings","entryId","id","type","bplistOverride","hasOwnProperty","filter","toString","writeByte","writeLong","computeOffsetSizeInBytes","offset","writeBytes","writeDict","writeNumber","writeUID","writeArray","writeBoolean","writeString","writeDate","writeData","Error","date","Date","parse","writeDouble","keysStr","entryKeys","map","k","valsStr","entryValues","writeIntHeader","writeID","width","hex","buf","padStart","slice","parseFloat","toFixed","e","mustBeUtf16","utf16","i","t","utf8","l","b","v","alloc","writeDoubleBE","kind","bytes","is_signedint","z","string","byteLength","toEntriesArray","Object","keys","UID","toEntriesObject","arr","results","push","concat","dict","key","entryKey","entryValue","maxOffset","numberOfIds"],"sources":["C:/Users/Daniel/node_modules/appium/node_modules/bplist-creator/bplistCreator.js"],"sourcesContent":["'use strict';\n\n// adapted from http://code.google.com/p/plist/source/browse/trunk/src/main/java/com/dd/plist/BinaryPropertyListWriter.java\n\nvar streamBuffers = require(\"stream-buffers\");\n\nvar debug = false;\n\nfunction Real(value) {\n  this.value = value;\n}\n\nmodule.exports = function(dicts) {\n  var buffer = new streamBuffers.WritableStreamBuffer();\n  buffer.write(Buffer.from(\"bplist00\"));\n\n  if (debug) {\n    console.log('create', require('util').inspect(dicts, false, 10));\n  }\n\n  if (dicts instanceof Array && dicts.length === 1) {\n    dicts = dicts[0];\n  }\n\n  var entries = toEntries(dicts);\n  if (debug) {\n    console.log('entries', entries);\n  }\n  var idSizeInBytes = computeIdSizeInBytes(entries.length);\n  var offsets = [];\n  var offsetSizeInBytes;\n  var offsetTableOffset;\n\n  updateEntryIds();\n\n  entries.forEach(function(entry, entryIdx) {\n    offsets[entryIdx] = buffer.size();\n    if (!entry) {\n      buffer.write(0x00);\n    } else {\n      write(entry);\n    }\n  });\n\n  writeOffsetTable();\n  writeTrailer();\n  return buffer.getContents();\n\n  function updateEntryIds() {\n    var strings = {};\n    var entryId = 0;\n    entries.forEach(function(entry) {\n      if (entry.id) {\n        return;\n      }\n      if (entry.type === 'string') {\n        if (!entry.bplistOverride && strings.hasOwnProperty(entry.value)) {\n          entry.type = 'stringref';\n          entry.id = strings[entry.value];\n        } else {\n          strings[entry.value] = entry.id = entryId++;\n        }\n      } else {\n        entry.id = entryId++;\n      }\n    });\n\n    entries = entries.filter(function(entry) {\n      return (entry.type !== 'stringref');\n    });\n  }\n\n  function writeTrailer() {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer');\n    }\n    // 6 null bytes\n    buffer.write(Buffer.from([0, 0, 0, 0, 0, 0]));\n\n    // size of an offset\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offsetSizeInBytes):', offsetSizeInBytes);\n    }\n    writeByte(offsetSizeInBytes);\n\n    // size of a ref\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offsetSizeInBytes):', idSizeInBytes);\n    }\n    writeByte(idSizeInBytes);\n\n    // number of objects\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(number of objects):', entries.length);\n    }\n    writeLong(entries.length);\n\n    // top object\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(top object)');\n    }\n    writeLong(0);\n\n    // offset table offset\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeTrailer(offset table offset):', offsetTableOffset);\n    }\n    writeLong(offsetTableOffset);\n  }\n\n  function writeOffsetTable() {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeOffsetTable');\n    }\n    offsetTableOffset = buffer.size();\n    offsetSizeInBytes = computeOffsetSizeInBytes(offsetTableOffset);\n    offsets.forEach(function(offset) {\n      writeBytes(offset, offsetSizeInBytes);\n    });\n  }\n\n  function write(entry) {\n    switch (entry.type) {\n    case 'dict':\n      writeDict(entry);\n      break;\n    case 'number':\n    case 'double':\n      writeNumber(entry);\n      break;\n    case 'UID':\n      writeUID(entry);\n      break;\n    case 'array':\n      writeArray(entry);\n      break;\n    case 'boolean':\n      writeBoolean(entry);\n      break;\n    case 'string':\n    case 'string-utf16':\n      writeString(entry);\n      break;\n    case 'date':\n      writeDate(entry);\n      break;\n    case 'data':\n      writeData(entry);\n      break;\n    default:\n      throw new Error(\"unhandled entry type: \" + entry.type);\n    }\n  }\n\n  function writeDate(entry) {\n    writeByte(0x33);\n    var date = (Date.parse(entry.value)/1000) - 978307200\n    writeDouble(date)\n  }\n\n  function writeDict(entry) {\n    if (debug) {\n      var keysStr = entry.entryKeys.map(function(k) {return k.id;});\n      var valsStr = entry.entryValues.map(function(k) {return k.id;});\n      console.log('0x' + buffer.size().toString(16), 'writeDict', '(id: ' + entry.id + ')', '(keys: ' + keysStr + ')', '(values: ' + valsStr + ')');\n    }\n    writeIntHeader(0xD, entry.entryKeys.length);\n    entry.entryKeys.forEach(function(entry) {\n      writeID(entry.id);\n    });\n    entry.entryValues.forEach(function(entry) {\n      writeID(entry.id);\n    });\n  }\n\n  function writeNumber(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeNumber', entry.value, ' (type: ' + entry.type + ')', '(id: ' + entry.id + ')');\n    }\n\n    if (typeof entry.value === 'bigint') {\n      var width = 16;\n      var hex = entry.value.toString(width);\n      var buf = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n      writeByte(0x14);\n      buffer.write(buf);\n    } else if (entry.type !== 'double' && parseFloat(entry.value).toFixed() == entry.value) {\n      if (entry.value < 0) {\n        writeByte(0x13);\n        writeBytes(entry.value, 8, true);\n      } else if (entry.value <= 0xff) {\n        writeByte(0x10);\n        writeBytes(entry.value, 1);\n      } else if (entry.value <= 0xffff) {\n        writeByte(0x11);\n        writeBytes(entry.value, 2);\n      } else if (entry.value <= 0xffffffff) {\n        writeByte(0x12);\n        writeBytes(entry.value, 4);\n      } else {\n        writeByte(0x13);\n        writeBytes(entry.value, 8);\n      }\n    } else {\n      writeByte(0x23);\n      writeDouble(entry.value);\n    }\n  }\n\n  function writeUID(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeUID', entry.value, ' (type: ' + entry.type + ')', '(id: ' + entry.id + ')');\n    }\n\n    writeIntHeader(0x8, 0x0);\n    writeID(entry.value);\n  }\n\n  function writeArray(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeArray (length: ' + entry.entries.length + ')', '(id: ' + entry.id + ')');\n    }\n    writeIntHeader(0xA, entry.entries.length);\n    entry.entries.forEach(function(e) {\n      writeID(e.id);\n    });\n  }\n\n  function writeBoolean(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeBoolean', entry.value, '(id: ' + entry.id + ')');\n    }\n    writeByte(entry.value ? 0x09 : 0x08);\n  }\n\n  function writeString(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeString', entry.value, '(id: ' + entry.id + ')');\n    }\n    if (entry.type === 'string-utf16' || mustBeUtf16(entry.value)) {\n      var utf16 = Buffer.from(entry.value, 'ucs2');\n      writeIntHeader(0x6, utf16.length / 2);\n      // needs to be big endian so swap the bytes\n      for (var i = 0; i < utf16.length; i += 2) {\n        var t = utf16[i + 0];\n        utf16[i + 0] = utf16[i + 1];\n        utf16[i + 1] = t;\n      }\n      buffer.write(utf16);\n    } else {\n      var utf8 = Buffer.from(entry.value, 'ascii');\n      writeIntHeader(0x5, utf8.length);\n      buffer.write(utf8);\n    }\n  }\n\n  function writeData(entry) {\n    if (debug) {\n      console.log('0x' + buffer.size().toString(16), 'writeData', entry.value, '(id: ' + entry.id + ')');\n    }\n    writeIntHeader(0x4, entry.value.length);\n    buffer.write(entry.value);\n  }\n\n  function writeLong(l) {\n    writeBytes(l, 8);\n  }\n\n  function writeByte(b) {\n    buffer.write(Buffer.from([b]));\n  }\n\n  function writeDouble(v) {\n    var buf = Buffer.alloc(8);\n    buf.writeDoubleBE(v, 0);\n    buffer.write(buf);\n  }\n\n  function writeIntHeader(kind, value) {\n    if (value < 15) {\n      writeByte((kind << 4) + value);\n    } else if (value < 256) {\n      writeByte((kind << 4) + 15);\n      writeByte(0x10);\n      writeBytes(value, 1);\n    } else if (value < 65536) {\n      writeByte((kind << 4) + 15);\n      writeByte(0x11);\n      writeBytes(value, 2);\n    } else {\n      writeByte((kind << 4) + 15);\n      writeByte(0x12);\n      writeBytes(value, 4);\n    }\n  }\n\n  function writeID(id) {\n    writeBytes(id, idSizeInBytes);\n  }\n\n  function writeBytes(value, bytes, is_signedint) {\n    // write low-order bytes big-endian style\n    var buf = Buffer.alloc(bytes);\n    var z = 0;\n\n    // javascript doesn't handle large numbers\n    while (bytes > 4) {\n      buf[z++] = is_signedint ? 0xff : 0;\n      bytes--;\n    }\n\n    for (var i = bytes - 1; i >= 0; i--) {\n      buf[z++] = value >> (8 * i);\n    }\n    buffer.write(buf);\n  }\n\n  function mustBeUtf16(string) {\n    return Buffer.byteLength(string, 'utf8') != string.length;\n  }\n};\n\nfunction toEntries(dicts) {\n  if (dicts.bplistOverride) {\n    return [dicts];\n  }\n\n  if (dicts instanceof Array) {\n    return toEntriesArray(dicts);\n  } else if (dicts instanceof Buffer) {\n    return [\n      {\n        type: 'data',\n        value: dicts\n      }\n    ];\n  } else if (dicts instanceof Real) {\n    return [\n      {\n        type: 'double',\n        value: dicts.value\n      }\n    ];\n  } else if (typeof(dicts) === 'object') {\n    if (dicts instanceof Date) {\n      return [\n        {\n          type: 'date',\n          value: dicts\n        }\n      ]\n    } else if (Object.keys(dicts).length == 1 && typeof(dicts.UID) === 'number') {\n      return [\n        {\n          type: 'UID',\n          value: dicts.UID\n        }\n      ]\n    } else {\n      return toEntriesObject(dicts);\n    }\n  } else if (typeof(dicts) === 'string') {\n    return [\n      {\n        type: 'string',\n        value: dicts\n      }\n    ];\n  } else if (typeof(dicts) === 'number') {\n    return [\n      {\n        type: 'number',\n        value: dicts\n      }\n    ];\n  } else if (typeof(dicts) === 'boolean') {\n    return [\n      {\n        type: 'boolean',\n        value: dicts\n      }\n    ];\n  } else if (typeof(dicts) === 'bigint') {\n    return [\n      {\n        type: 'number',\n        value: dicts\n      }\n    ];\n  } else {\n    throw new Error('unhandled entry: ' + dicts);\n  }\n}\n\nfunction toEntriesArray(arr) {\n  if (debug) {\n    console.log('toEntriesArray');\n  }\n  var results = [\n    {\n      type: 'array',\n      entries: []\n    }\n  ];\n  arr.forEach(function(v) {\n    var entry = toEntries(v);\n    results[0].entries.push(entry[0]);\n    results = results.concat(entry);\n  });\n  return results;\n}\n\nfunction toEntriesObject(dict) {\n  if (debug) {\n    console.log('toEntriesObject');\n  }\n  var results = [\n    {\n      type: 'dict',\n      entryKeys: [],\n      entryValues: []\n    }\n  ];\n  Object.keys(dict).forEach(function(key) {\n    var entryKey = toEntries(key);\n    results[0].entryKeys.push(entryKey[0]);\n    results = results.concat(entryKey[0]);\n  });\n  Object.keys(dict).forEach(function(key) {\n    var entryValue = toEntries(dict[key]);\n    results[0].entryValues.push(entryValue[0]);\n    results = results.concat(entryValue);\n  });\n  return results;\n}\n\nfunction computeOffsetSizeInBytes(maxOffset) {\n  if (maxOffset < 256) {\n    return 1;\n  }\n  if (maxOffset < 65536) {\n    return 2;\n  }\n  if (maxOffset < 4294967296) {\n    return 4;\n  }\n  return 8;\n}\n\nfunction computeIdSizeInBytes(numberOfIds) {\n  if (numberOfIds < 256) {\n    return 1;\n  }\n  if (numberOfIds < 65536) {\n    return 2;\n  }\n  return 4;\n}\n\nmodule.exports.Real = Real;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}