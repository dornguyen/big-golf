{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SubProcess = void 0;\nrequire(\"source-map-support/register\");\nvar _child_process = require(\"child_process\");\nvar _events = _interopRequireDefault(require(\"events\"));\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\nvar _shellQuote = require(\"shell-quote\");\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\nvar _helpers = require(\"./helpers\");\nconst {\n  EventEmitter\n} = _events.default;\nconst MAX_LINE_PORTION_LENGTH = 0xFFFF;\nfunction cutSuffix(str, suffixLength) {\n  return str.length > suffixLength ? ` ${str.substr(str.length - suffixLength)}`.substr(1) : str;\n}\nclass SubProcess extends EventEmitter {\n  constructor(cmd) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    if (!cmd) throw new Error('Command is required');\n    if (!_lodash.default.isString(cmd)) throw new Error('Command must be a string');\n    if (!_lodash.default.isArray(args)) throw new Error('Args must be an array');\n    this.cmd = cmd;\n    this.args = args;\n    this.proc = null;\n    this.opts = opts;\n    this.expectingExit = false;\n    this.rep = (0, _shellQuote.quote)([cmd, ...args]);\n  }\n  get isRunning() {\n    return !!this.proc;\n  }\n  emitLines(stream, lines) {\n    for (let line of lines) {\n      this.emit('stream-line', `[${stream.toUpperCase()}] ${line}`);\n    }\n  }\n  async start() {\n    let startDetector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let timeoutMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let detach = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let startDelay = 10;\n    const genericStartDetector = function genericStartDetector(stdout, stderr) {\n      return stdout || stderr;\n    };\n    if (startDetector === null) {\n      startDetector = genericStartDetector;\n    }\n    if (_lodash.default.isNumber(startDetector)) {\n      startDelay = startDetector;\n      startDetector = null;\n    }\n    if (_lodash.default.isBoolean(startDetector) && startDetector) {\n      if (!this.opts.detached) {\n        throw new Error(`Unable to detach process that is not started with 'detached' option`);\n      }\n      detach = true;\n      startDetector = genericStartDetector;\n    } else if (_lodash.default.isBoolean(timeoutMs) && timeoutMs) {\n      if (!this.opts.detached) {\n        throw new Error(`Unable to detach process that is not started with 'detached' option`);\n      }\n      detach = true;\n      timeoutMs = null;\n    }\n    return await new _bluebird.default((resolve, reject) => {\n      this.proc = (0, _child_process.spawn)(this.cmd, this.args, this.opts);\n      if (this.proc.stdout) {\n        this.proc.stdout.setEncoding(this.opts.encoding || 'utf8');\n      }\n      if (this.proc.stderr) {\n        this.proc.stderr.setEncoding(this.opts.encoding || 'utf8');\n      }\n      this.lastLinePortion = {\n        stdout: '',\n        stderr: ''\n      };\n      const handleOutput = streams => {\n        const {\n          stdout,\n          stderr\n        } = streams;\n        try {\n          if (startDetector && startDetector(stdout, stderr)) {\n            startDetector = null;\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n        this.emit('output', stdout, stderr);\n        for (const [streamName, streamData] of _lodash.default.toPairs(streams)) {\n          if (!streamData) continue;\n          const lines = streamData.split('\\n').map(x => ` ${x}`.substr(1));\n          if (lines.length > 1) {\n            lines[0] = this.lastLinePortion[streamName] + lines[0];\n            this.lastLinePortion[streamName] = cutSuffix(_lodash.default.last(lines), MAX_LINE_PORTION_LENGTH);\n            const resultLines = lines.slice(0, -1);\n            this.emit(`lines-${streamName}`, resultLines);\n            this.emitLines(streamName, resultLines);\n          } else {\n            const currentPortion = cutSuffix(lines[0], MAX_LINE_PORTION_LENGTH);\n            if (this.lastLinePortion[streamName].length + currentPortion.length > MAX_LINE_PORTION_LENGTH) {\n              this.lastLinePortion[streamName] = currentPortion;\n            } else {\n              this.lastLinePortion[streamName] += currentPortion;\n            }\n          }\n        }\n      };\n      this.proc.on('error', err => {\n        this.proc.removeAllListeners('exit');\n        this.proc.kill('SIGINT');\n        if (err.errno === 'ENOENT') {\n          var _this$opts;\n          err = (0, _helpers.formatEnoent)(err, this.cmd, (_this$opts = this.opts) === null || _this$opts === void 0 ? void 0 : _this$opts.cwd);\n        }\n        reject(err);\n      });\n      if (this.proc.stdout) {\n        this.proc.stdout.on('data', chunk => handleOutput({\n          stdout: chunk.toString(),\n          stderr: ''\n        }));\n      }\n      if (this.proc.stderr) {\n        this.proc.stderr.on('data', chunk => handleOutput({\n          stdout: '',\n          stderr: chunk.toString()\n        }));\n      }\n      this.proc.on('exit', (code, signal) => {\n        this.handleLastLines();\n        this.emit('exit', code, signal);\n        let event = this.expectingExit ? 'stop' : 'die';\n        if (!this.expectingExit && code === 0) {\n          event = 'end';\n        }\n        this.emit(event, code, signal);\n        this.proc = null;\n        this.expectingExit = false;\n      });\n      if (!startDetector) {\n        setTimeout(() => {\n          resolve();\n        }, startDelay);\n      }\n      if (_lodash.default.isNumber(timeoutMs)) {\n        setTimeout(() => {\n          reject(new Error(`The process did not start within ${timeoutMs}ms ` + `(cmd: '${this.rep}')`));\n        }, timeoutMs);\n      }\n    }).finally(() => {\n      if (detach && this.proc) {\n        this.proc.unref();\n      }\n    });\n  }\n  handleLastLines() {\n    for (let stream of ['stdout', 'stderr']) {\n      if (this.lastLinePortion[stream]) {\n        const lastLines = [this.lastLinePortion[stream]];\n        this.emit(`lines-${stream}`, lastLines);\n        this.emitLines(stream, lastLines);\n        this.lastLinePortion[stream] = '';\n      }\n    }\n  }\n  async stop() {\n    let signal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'SIGTERM';\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    if (!this.isRunning) {\n      throw new Error(`Can't stop process; it's not currently running (cmd: '${this.rep}')`);\n    }\n    this.handleLastLines();\n    return await new _bluebird.default((resolve, reject) => {\n      this.proc.on('close', resolve);\n      this.expectingExit = true;\n      this.proc.kill(signal);\n      setTimeout(() => {\n        reject(new Error(`Process didn't end after ${timeout}ms (cmd: '${this.rep}')`));\n      }, timeout);\n    });\n  }\n  async join() {\n    let allowedExitCodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0];\n    if (!this.isRunning) {\n      throw new Error(`Cannot join process; it is not currently running (cmd: '${this.rep}')`);\n    }\n    return await new _bluebird.default((resolve, reject) => {\n      this.proc.on('exit', code => {\n        if (allowedExitCodes.indexOf(code) === -1) {\n          reject(new Error(`Process ended with exitcode ${code} (cmd: '${this.rep}')`));\n        } else {\n          resolve(code);\n        }\n      });\n    });\n  }\n  detachProcess() {\n    if (!this.opts.detached) {\n      throw new Error(`Unable to detach process that is not started with 'detached' option`);\n    }\n    if (this.proc) {\n      this.proc.unref();\n    }\n  }\n  get pid() {\n    return this.proc ? this.proc.pid : null;\n  }\n}\nexports.SubProcess = SubProcess;\nvar _default = SubProcess;\nexports.default = _default;\nrequire('source-map-support').install();","map":{"version":3,"mappings":"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","names":["EventEmitter","events","MAX_LINE_PORTION_LENGTH","cutSuffix","str","suffixLength","length","substr","SubProcess","constructor","cmd","args","opts","Error","_","isString","isArray","proc","expectingExit","rep","isRunning","emitLines","stream","lines","line","emit","toUpperCase","start","startDetector","timeoutMs","detach","startDelay","genericStartDetector","stdout","stderr","isNumber","isBoolean","detached","B","resolve","reject","setEncoding","encoding","lastLinePortion","handleOutput","streams","e","streamName","streamData","toPairs","split","map","x","last","resultLines","slice","currentPortion","on","err","removeAllListeners","kill","errno","_this$opts","cwd","chunk","toString","code","signal","handleLastLines","event","setTimeout","finally","unref","lastLines","stop","timeout","join","allowedExitCodes","indexOf","detachProcess","pid"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\teen_process\\lib\\subprocess.js"],"sourcesContent":["/* eslint-disable promise/prefer-await-to-callbacks */\n\nimport { spawn } from 'child_process';\nimport events from 'events';\nconst { EventEmitter } = events;\nimport B from 'bluebird';\nimport { quote } from 'shell-quote';\nimport _ from 'lodash';\nimport { formatEnoent } from './helpers';\n\n\n// This is needed to avoid memory leaks\n// when the process output is too long and contains\n// no line breaks\nconst MAX_LINE_PORTION_LENGTH = 0xFFFF;\n\nfunction cutSuffix (str, suffixLength) {\n  return str.length > suffixLength\n    // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n    ? ` ${str.substr(str.length - suffixLength)}`.substr(1)\n    : str;\n}\n\n\nclass SubProcess extends EventEmitter {\n  constructor (cmd, args = [], opts = {}) {\n    super();\n    if (!cmd) throw new Error('Command is required'); // eslint-disable-line curly\n    if (!_.isString(cmd)) throw new Error('Command must be a string'); // eslint-disable-line curly\n    if (!_.isArray(args)) throw new Error('Args must be an array'); // eslint-disable-line curly\n\n    this.cmd = cmd;\n    this.args = args;\n    this.proc = null;\n    this.opts = opts;\n    this.expectingExit = false;\n\n    // get a quoted representation of the command for error strings\n    this.rep = quote([cmd, ...args]);\n  }\n\n  get isRunning () {\n    // presence of `proc` means we have connected and started\n    return !!this.proc;\n  }\n\n  emitLines (stream, lines) {\n    for (let line of lines) {\n      this.emit('stream-line', `[${stream.toUpperCase()}] ${line}`);\n    }\n  }\n\n  // spawn the subprocess and return control whenever we deem that it has fully\n  // \"started\"\n  async start (startDetector = null, timeoutMs = null, detach = false) {\n    let startDelay = 10;\n\n    const genericStartDetector = function genericStartDetector (stdout, stderr) {\n      return stdout || stderr;\n    };\n\n    // the default start detector simply returns true when we get any output\n    if (startDetector === null) {\n      startDetector = genericStartDetector;\n    }\n\n    // if the user passes a number, then we simply delay a certain amount of\n    // time before returning control, rather than waiting for a condition\n    if (_.isNumber(startDetector)) {\n      startDelay = startDetector;\n      startDetector = null;\n    }\n\n    // if the user passes in a boolean as one of the arguments, use it for `detach`\n    if (_.isBoolean(startDetector) && startDetector) {\n      if (!this.opts.detached) {\n        throw new Error(`Unable to detach process that is not started with 'detached' option`);\n      }\n      detach = true;\n      startDetector = genericStartDetector;\n    } else if (_.isBoolean(timeoutMs) && timeoutMs) {\n      if (!this.opts.detached) {\n        throw new Error(`Unable to detach process that is not started with 'detached' option`);\n      }\n      detach = true;\n      timeoutMs = null;\n    }\n\n    // return a promise so we can wrap the async behavior\n    return await new B((resolve, reject) => {\n      // actually spawn the subproc\n      this.proc = spawn(this.cmd, this.args, this.opts);\n\n      if (this.proc.stdout) {\n        this.proc.stdout.setEncoding(this.opts.encoding || 'utf8');\n      }\n      if (this.proc.stderr) {\n        this.proc.stderr.setEncoding(this.opts.encoding || 'utf8');\n      }\n      this.lastLinePortion = {stdout: '', stderr: ''};\n\n      // this function handles output that we collect from the subproc\n      const handleOutput = (streams) => {\n        const {stdout, stderr} = streams;\n        // if we have a startDetector, run it on the output so we can resolve/\n        // reject and move on from start\n        try {\n          if (startDetector && startDetector(stdout, stderr)) {\n            startDetector = null;\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n\n        // emit the actual output for whomever's listening\n        this.emit('output', stdout, stderr);\n\n        // we also want to emit lines, but it's more complex since output\n        // comes in chunks and a line could come in two different chunks, so\n        // we have logic to handle that case (using this.lastLinePortion to\n        // remember a line that started but did not finish in the last chunk)\n        for (const [streamName, streamData] of _.toPairs(streams)) {\n          if (!streamData) continue; // eslint-disable-line curly\n          const lines = streamData.split('\\n')\n            // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n            .map((x) => ` ${x}`.substr(1));\n          if (lines.length > 1) {\n            lines[0] = this.lastLinePortion[streamName] + lines[0];\n            this.lastLinePortion[streamName] = cutSuffix(_.last(lines), MAX_LINE_PORTION_LENGTH);\n            const resultLines = lines.slice(0, -1);\n            this.emit(`lines-${streamName}`, resultLines);\n            this.emitLines(streamName, resultLines);\n          } else {\n            const currentPortion = cutSuffix(lines[0], MAX_LINE_PORTION_LENGTH);\n            if (this.lastLinePortion[streamName].length + currentPortion.length > MAX_LINE_PORTION_LENGTH) {\n              this.lastLinePortion[streamName] = currentPortion;\n            } else {\n              this.lastLinePortion[streamName] += currentPortion;\n            }\n          }\n        }\n      };\n\n      // if we get an error spawning the proc, reject and clean up the proc\n      this.proc.on('error', (err) => {\n        this.proc.removeAllListeners('exit');\n        this.proc.kill('SIGINT');\n\n        if (err.errno === 'ENOENT') {\n          err = formatEnoent(err, this.cmd, this.opts?.cwd);\n        }\n        reject(err);\n      });\n\n      if (this.proc.stdout) {\n        this.proc.stdout.on('data', (chunk) => handleOutput({stdout: chunk.toString(), stderr: ''}));\n      }\n\n      if (this.proc.stderr) {\n        this.proc.stderr.on('data', (chunk) => handleOutput({stdout: '', stderr: chunk.toString()}));\n      }\n\n      // when the proc exits, we might still have a buffer of lines we were\n      // waiting on more chunks to complete. Go ahead and emit those, then\n      // re-emit the exit so a listener can handle the possibly-unexpected exit\n      this.proc.on('exit', (code, signal) => {\n        this.handleLastLines();\n\n        this.emit('exit', code, signal);\n\n        // in addition to the bare exit event, also emit one of three other\n        // events that contain more helpful information:\n        // 'stop': we stopped this\n        // 'die': the process ended out of our control with a non-zero exit\n        // 'end': the process ended out of our control with a zero exit\n        let event = this.expectingExit ? 'stop' : 'die';\n        if (!this.expectingExit && code === 0) {\n          event = 'end';\n        }\n        this.emit(event, code, signal);\n\n        // finally clean up the proc and make sure to reset our exit\n        // expectations\n        this.proc = null;\n        this.expectingExit = false;\n      });\n\n      // if the user hasn't given us a startDetector, instead just resolve\n      // when startDelay ms have passed\n      if (!startDetector) {\n        setTimeout(() => { resolve(); }, startDelay);\n      }\n\n      // if the user has given us a timeout, start the clock for rejecting\n      // the promise if we take too long to start\n      if (_.isNumber(timeoutMs)) {\n        setTimeout(() => {\n          reject(new Error(`The process did not start within ${timeoutMs}ms ` +\n            `(cmd: '${this.rep}')`));\n        }, timeoutMs);\n      }\n    }).finally(() => {\n      if (detach && this.proc) {\n        this.proc.unref();\n      }\n    });\n  }\n\n  handleLastLines () {\n    for (let stream of ['stdout', 'stderr']) {\n      if (this.lastLinePortion[stream]) {\n        const lastLines = [this.lastLinePortion[stream]];\n        this.emit(`lines-${stream}`, lastLines);\n        this.emitLines(stream, lastLines);\n        this.lastLinePortion[stream] = '';\n      }\n    }\n  }\n\n  async stop (signal = 'SIGTERM', timeout = 10000) {\n    if (!this.isRunning) {\n      throw new Error(`Can't stop process; it's not currently running (cmd: '${this.rep}')`);\n    }\n    // make sure to emit any data in our lines buffer whenever we're done with\n    // the proc\n    this.handleLastLines();\n    return await new B((resolve, reject) => {\n      this.proc.on('close', resolve);\n      this.expectingExit = true;\n      this.proc.kill(signal);\n      setTimeout(() => {\n        reject(new Error(`Process didn't end after ${timeout}ms (cmd: '${this.rep}')`));\n      }, timeout);\n    });\n  }\n\n  async join (allowedExitCodes = [0]) {\n    if (!this.isRunning) {\n      throw new Error(`Cannot join process; it is not currently running (cmd: '${this.rep}')`);\n    }\n\n    return await new B((resolve, reject) => {\n      this.proc.on('exit', (code) => {\n        if (allowedExitCodes.indexOf(code) === -1) {\n          reject(new Error(`Process ended with exitcode ${code} (cmd: '${this.rep}')`));\n        } else {\n          resolve(code);\n        }\n      });\n    });\n  }\n\n  /*\n   * This will only work if the process is created with the `detached` option\n   */\n  detachProcess () {\n    if (!this.opts.detached) {\n      // this means that there is a misconfiguration in the calling code\n      throw new Error(`Unable to detach process that is not started with 'detached' option`);\n    }\n    if (this.proc) {\n      this.proc.unref();\n    }\n  }\n\n  get pid () {\n    return this.proc ? this.proc.pid : null;\n  }\n}\n\nexport { SubProcess };\nexport default SubProcess;\n"]},"metadata":{},"sourceType":"script"}