{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _utils = require(\"@jimp/utils\");\n\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  var rad = deg * Math.PI / 180;\n  var cosine = Math.cos(rad);\n  var sine = Math.sin(rad); // the final width and height will change if resize == true\n\n  var w = this.bitmap.width;\n  var h = this.bitmap.height;\n  if (mode === true || typeof mode === 'string') {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;\n    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1; // Ensure destination to have even size to a better result.\n\n    if (w % 2 !== 0) {\n      w++;\n    }\n    if (h % 2 !== 0) {\n      h++;\n    }\n    var c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n    this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);\n  }\n  var bW = this.bitmap.width;\n  var bH = this.bitmap.height;\n  var dstBuffer = Buffer.alloc(this.bitmap.data.length);\n  function createTranslationFunction(deltaX, deltaY) {\n    return function (x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n  var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);\n  for (var y = 1; y <= bH; y++) {\n    for (var x = 1; x <= bW; x++) {\n      var cartesian = translate2Cartesian(x, y);\n      var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);\n      var dstIdx = bW * (y - 1) + x - 1 << 2;\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;\n        var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n  this.bitmap.data = dstBuffer;\n  if (mode === true || typeof mode === 'string') {\n    // now crop the image to the final size\n    var _x = bW / 2 - w / 2;\n    var _y = bH / 2 - h / 2;\n    this.crop(_x, _y, w, h);\n  }\n}\nvar _default = function _default() {\n  return {\n    /**\n     * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n     * @param {number} deg the number of degrees to rotate the image by\n     * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    rotate: function rotate(deg, mode, cb) {\n      // enable overloading\n      if (typeof mode === 'undefined' || mode === null) {\n        // e.g. image.resize(120);\n        // e.g. image.resize(120, null, cb);\n        // e.g. image.resize(120, undefined, cb);\n        mode = true;\n      }\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        // e.g. image.resize(120, cb);\n        cb = mode;\n        mode = true;\n      }\n      if (typeof deg !== 'number') {\n        return _utils.throwError.call(this, 'deg must be a number', cb);\n      }\n      if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n        return _utils.throwError.call(this, 'mode must be a boolean or a string', cb);\n      }\n      advancedRotate.call(this, deg, mode, cb);\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n      return this;\n    }\n  };\n};\nexports[\"default\"] = _default;","map":{"version":3,"mappings":"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","names":["advancedRotate","deg","mode","rad","Math","PI","cosine","cos","sine","sin","w","bitmap","width","h","height","ceil","abs","c","cloneQuiet","scanQuiet","x","y","idx","data","writeUInt32BE","_background","max","resize","blit","bW","bH","dstBuffer","Buffer","alloc","length","createTranslationFunction","deltaX","deltaY","translate2Cartesian","translate2Screen","cartesian","source","dstIdx","srcIdx","pixelRGBA","readUInt32BE","crop","rotate","cb","throwError","call"],"sources":["C:\\Users\\Daniel\\node_modules\\appium\\node_modules\\@jimp\\plugin-rotate\\src\\index.js"],"sourcesContent":["import { throwError, isNodePattern } from '@jimp/utils';\n\n/**\n * Rotates an image clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  const rad = (deg * Math.PI) / 180;\n  const cosine = Math.cos(rad);\n  const sine = Math.sin(rad);\n\n  // the final width and height will change if resize == true\n  let w = this.bitmap.width;\n  let h = this.bitmap.height;\n\n  if (mode === true || typeof mode === 'string') {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w =\n      Math.ceil(\n        Math.abs(this.bitmap.width * cosine) +\n          Math.abs(this.bitmap.height * sine)\n      ) + 1;\n    h =\n      Math.ceil(\n        Math.abs(this.bitmap.width * sine) +\n          Math.abs(this.bitmap.height * cosine)\n      ) + 1;\n    // Ensure destination to have even size to a better result.\n    if (w % 2 !== 0) {\n      w++;\n    }\n\n    if (h % 2 !== 0) {\n      h++;\n    }\n\n    const c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n\n    const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n\n    this.blit(\n      c,\n      this.bitmap.width / 2 - c.bitmap.width / 2,\n      this.bitmap.height / 2 - c.bitmap.height / 2\n    );\n  }\n\n  const bW = this.bitmap.width;\n  const bH = this.bitmap.height;\n  const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n  function createTranslationFunction(deltaX, deltaY) {\n    return function(x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n\n  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  const translate2Screen = createTranslationFunction(\n    bW / 2 + 0.5,\n    bH / 2 + 0.5\n  );\n\n  for (let y = 1; y <= bH; y++) {\n    for (let x = 1; x <= bW; x++) {\n      const cartesian = translate2Cartesian(x, y);\n      const source = translate2Screen(\n        cosine * cartesian.x - sine * cartesian.y,\n        cosine * cartesian.y + sine * cartesian.x\n      );\n      const dstIdx = (bW * (y - 1) + x - 1) << 2;\n\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;\n        const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n\n  this.bitmap.data = dstBuffer;\n\n  if (mode === true || typeof mode === 'string') {\n    // now crop the image to the final size\n    const x = bW / 2 - w / 2;\n    const y = bH / 2 - h / 2;\n    this.crop(x, y, w, h);\n  }\n}\n\nexport default () => ({\n  /**\n   * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n   * @param {number} deg the number of degrees to rotate the image by\n   * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rotate(deg, mode, cb) {\n    // enable overloading\n    if (typeof mode === 'undefined' || mode === null) {\n      // e.g. image.resize(120);\n      // e.g. image.resize(120, null, cb);\n      // e.g. image.resize(120, undefined, cb);\n      mode = true;\n    }\n\n    if (typeof mode === 'function' && typeof cb === 'undefined') {\n      // e.g. image.resize(120, cb);\n      cb = mode;\n      mode = true;\n    }\n\n    if (typeof deg !== 'number') {\n      return throwError.call(this, 'deg must be a number', cb);\n    }\n\n    if (typeof mode !== 'boolean' && typeof mode !== 'string') {\n      return throwError.call(this, 'mode must be a boolean or a string', cb);\n    }\n\n    advancedRotate.call(this, deg, mode, cb);\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}